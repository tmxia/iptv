name: BV APK Sync from Source Repository

on:
  schedule:
    - cron: '0 */24 * * *'
  workflow_dispatch:

# ä½¿ç”¨åŸç”Ÿå¹¶å‘æ§åˆ¶
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    # åŸºäºç¼“å­˜çš„é”æœºåˆ¶
    - name: Acquire Repository Lock ğŸ”’
      id: lock
      run: |
        # åˆ›å»ºé”æ–‡ä»¶è·¯å¾„
        LOCK_DIR="$GITHUB_WORKSPACE/.lock"
        LOCK_FILE="$LOCK_DIR/repo-lock"
        mkdir -p "$LOCK_DIR"
        
        # å°è¯•è·å–é”
        for i in {1..10}; do
          # æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–å·¥ä½œæµæŒæœ‰é”
          if [ -f "$LOCK_FILE" ]; then
            echo "é”å·²è¢«å ç”¨ï¼Œç­‰å¾…é‡è¯• ($i/10)..."
            sleep 30
          else
            # åˆ›å»ºé”æ–‡ä»¶
            touch "$LOCK_FILE"
            echo "lock-acquired=true" >> $GITHUB_OUTPUT
            echo "æˆåŠŸè·å–é”"
            exit 0
          fi
        done
        
        echo "::error::æ— æ³•åœ¨5åˆ†é’Ÿå†…è·å–é”"
        exit 1

    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Install dependencies
      run: sudo apt-get update && sudo apt-get install -y jq curl

    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git config pull.rebase true
        git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
        
    - name: Run APK sync
      env:
        SOURCE_REPO: "aaa1115910/bv"
        TARGET_REPO: "${{ github.repository }}"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
        STABLE_APK_PATTERN: "release_default_universal.apk"
        PRE_RELEASE_APK_PATTERN: "alpha_default_universal.apk"
        STABLE_KEY_NAME: "bv.apk"
        PRE_RELEASE_KEY_NAME: "bv-beta.apk"
      run: |
        set -euo pipefail
        WORK_DIR=$(mktemp -d)
        trap 'rm -rf "$WORK_DIR"' EXIT
        
        # éªŒè¯ä»¤ç‰Œæƒé™
        if ! curl -s -H "Authorization: token $TOKEN" "https://api.github.com/repos/$TARGET_REPO" | grep -q '"id"'; then
          echo "::error::æ— æ•ˆçš„GITHUB_TOKENï¼Œè¯·æ£€æŸ¥æƒé™"
          exit 1
        fi
        
        # è·å–æºä»“åº“å‘å¸ƒä¿¡æ¯
        RELEASES_JSON=$(curl -sL "https://api.github.com/repos/$SOURCE_REPO/releases")
        if [ -z "$RELEASES_JSON" ]; then
          echo "::error::æ— æ³•è·å–æºä»“åº“å‘å¸ƒä¿¡æ¯"
          exit 1
        fi
        
        # æå–ç‰ˆæœ¬ä¿¡æ¯
        extract_version() {
          local release_json="$1"
          local tag_name=$(jq -r '.tag_name' <<< "$release_json")
          local published_at=$(jq -r '.published_at' <<< "$release_json")
          date_utc8=$(TZ=UTC date -d "$published_at" +'%Y-%m-%d')
          echo "$tag_name $date_utc8"
        }
        
        # æ ¸å¿ƒAPKå¤„ç†å‡½æ•°
        process_apk() {
          local release_json="$1"
          local pattern="$2"
          local key="$3"
          local current_version="$4"
          
          # æ£€æŸ¥ç›®æ ‡APKæ˜¯å¦å­˜åœ¨
          local status_code=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/apk/$key")
          
          # ç¡®å®šæ˜¯å¦éœ€è¦æ›´æ–°
          local latest_tag=$(jq -r '.tag_name' <<< "$release_json")
          if [ "$status_code" != "200" ] || [ "$latest_tag" != "$current_version" ]; then
            # è·å–ç²¾ç¡®åŒ¹é…çš„APK
            local url=$(jq -r --arg pattern "$pattern" '
              .assets[] | 
              select(.name | contains($pattern)) |
              .browser_download_url' <<< "$release_json" | head -1)
            
            [ -z "$url" ] && { 
              echo "::warning::æœªæ‰¾åˆ°åŒ¹é…çš„APKæ–‡ä»¶ (pattern: $pattern)";
              return 1; 
            }
            
            # ç›´æ¥ä¸‹è½½
            if ! curl -fL "$url" -o "$WORK_DIR/$key"; then
              echo "::error::æ— æ³•ä¸‹è½½APKæ–‡ä»¶: $key"
              return 1
            fi
            
            # éªŒè¯æ–‡ä»¶éç©º
            if [ ! -s "$WORK_DIR/$key" ]; then
              echo "::error::ä¸‹è½½æ–‡ä»¶ä¸ºç©º: $key"
              return 1
            fi
            
            echo "æˆåŠŸä¸‹è½½: $key (ç‰ˆæœ¬: $latest_tag)"
            return 0
          fi
          echo "æ— éœ€æ›´æ–°: $key (å½“å‰ç‰ˆæœ¬: $current_version)"
          return 0
        }
        
        # è·å–å¹¶è§£æç‰ˆæœ¬æ–‡ä»¶
        VERSION_FILE_RESP=$(curl -s -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
        
        if [ "$(jq -r '.message? // ""' <<< "$VERSION_FILE_RESP")" == "Not Found" ]; then
          echo "æœªæ‰¾åˆ°ç‰ˆæœ¬æ–‡ä»¶ï¼Œå°†åˆ›å»ºæ–°æ–‡ä»¶"
          CURRENT_VERSION_JSON="{}"
          SHA_VERSION=""
        else
          CONTENT=$(jq -r '.content' <<< "$VERSION_FILE_RESP" | base64 -d)
          SHA_VERSION=$(jq -r '.sha' <<< "$VERSION_FILE_RESP")
          
          # éªŒè¯JSONæ ¼å¼
          if ! echo "$CONTENT" | jq -e . >/dev/null 2>&1; then
            echo "::warning::ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼æ— æ•ˆï¼Œé‡ç½®ä¸ºç©ºJSON"
            CURRENT_VERSION_JSON="{}"
          else
            CURRENT_VERSION_JSON="$CONTENT"
          fi
        fi
        
        # æå–å½“å‰ç‰ˆæœ¬
        STABLE_NEED_UPDATE=false
        PRE_RELEASE_NEED_UPDATE=false
        
        CURRENT_STABLE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$STABLE_KEY_NAME\"? // \"\"" | cut -d, -f1)
        CURRENT_STABLE_DATE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$STABLE_KEY_NAME\"? // \"\"" | cut -d, -f2)
        CURRENT_PRE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$PRE_RELEASE_KEY_NAME\"? // \"\"" | cut -d, -f1)
        CURRENT_PRE_DATE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$PRE_RELEASE_KEY_NAME\"? // \"\"" | cut -d, -f2)
        
        echo "ç›®æ ‡ç¨³å®šç‰ˆ: ${CURRENT_STABLE:-æ— } (${CURRENT_STABLE_DATE:-æ— æ—¥æœŸ})"
        echo "ç›®æ ‡é¢„å‘è¡Œç‰ˆ: ${CURRENT_PRE:-æ— } (${CURRENT_PRE_DATE:-æ— æ—¥æœŸ})"
        
        # å¤„ç†ç¨³å®šç‰ˆ
        LATEST_STABLE=$(jq -r '[.[] | select(.prerelease == false)] | max_by(.published_at)' <<< "$RELEASES_JSON")
        if [ -n "$LATEST_STABLE" ] && [ "$LATEST_STABLE" != "null" ]; then
          read NEW_STABLE_VERSION NEW_STABLE_DATE <<< $(extract_version "$LATEST_STABLE")
          echo "æºç¨³å®šç‰ˆ: $NEW_STABLE_VERSION ($NEW_STABLE_DATE)"
          
          if process_apk "$LATEST_STABLE" "$STABLE_APK_PATTERN" "$STABLE_KEY_NAME" "$CURRENT_STABLE"; then
            STABLE_NEED_UPDATE=true
          else
            # ä¿ç•™å½“å‰ç‰ˆæœ¬ä¿¡æ¯
            NEW_STABLE_VERSION="$CURRENT_STABLE"
            NEW_STABLE_DATE="$CURRENT_STABLE_DATE"
          fi
        else
          echo "::warning::æœªæ‰¾åˆ°ç¨³å®šç‰ˆå‘å¸ƒ"
          NEW_STABLE_VERSION="$CURRENT_STABLE"
          NEW_STABLE_DATE="$CURRENT_STABLE_DATE"
        fi
        
        # å¤„ç†é¢„å‘å¸ƒç‰ˆ
        LATEST_PRE_RELEASE=$(jq -r '[.[] | select(.prerelease == true)] | max_by(.published_at)' <<< "$RELEASES_JSON")
        if [ -n "$LATEST_PRE_RELEASE" ] && [ "$LATEST_PRE_RELEASE" != "null" ]; then
          read NEW_PRE_RELEASE_VERSION NEW_PRE_RELEASE_DATE <<< $(extract_version "$LATEST_PRE_RELEASE")
          echo "æºé¢„å‘å¸ƒç‰ˆ: $NEW_PRE_RELEASE_VERSION ($NEW_PRE_RELEASE_DATE)"
          
          if process_apk "$LATEST_PRE_RELEASE" "$PRE_RELEASE_APK_PATTERN" "$PRE_RELEASE_KEY_NAME" "$CURRENT_PRE"; then
            PRE_RELEASE_NEED_UPDATE=true
          else
            # ä¿ç•™å½“å‰ç‰ˆæœ¬ä¿¡æ¯
            NEW_PRE_RELEASE_VERSION="$CURRENT_PRE"
            NEW_PRE_RELEASE_DATE="$CURRENT_PRE_DATE"
          fi
        else
          echo "::warning::æœªæ‰¾åˆ°é¢„å‘å¸ƒç‰ˆ"
          NEW_PRE_RELEASE_VERSION="$CURRENT_PRE"
          NEW_PRE_RELEASE_DATE="$CURRENT_PRE_DATE"
        fi
        
        # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
        UPDATE_VERSION_FILE=false
        UPDATED_VERSION_JSON=$(echo "$CURRENT_VERSION_JSON" | jq .)
        
        # ç¨³å®šç‰ˆæ›´æ–°æ£€æŸ¥
        if [ -n "$NEW_STABLE_VERSION" ] && 
           { [ "$NEW_STABLE_VERSION" != "$CURRENT_STABLE" ] || 
             [ "$NEW_STABLE_DATE" != "$CURRENT_STABLE_DATE" ]; }; then
          UPDATED_VERSION_JSON=$(jq --arg k "$STABLE_KEY_NAME" \
            --arg v "$NEW_STABLE_VERSION,$NEW_STABLE_DATE" \
            '.[$k] = $v' <<< "$UPDATED_VERSION_JSON")
          UPDATE_VERSION_FILE=true
          echo "æ›´æ–°ç¨³å®šç‰ˆ: $NEW_STABLE_VERSION ($NEW_STABLE_DATE)"
        fi
        
        # é¢„å‘å¸ƒç‰ˆæ›´æ–°æ£€æŸ¥
        if [ -n "$NEW_PRE_RELEASE_VERSION" ] && 
           { [ "$NEW_PRE_RELEASE_VERSION" != "$CURRENT_PRE" ] || 
             [ "$NEW_PRE_RELEASE_DATE" != "$CURRENT_PRE_DATE" ]; }; then
          UPDATED_VERSION_JSON=$(jq --arg k "$PRE_RELEASE_KEY_NAME" \
            --arg v "$NEW_PRE_RELEASE_VERSION,$NEW_PRE_RELEASE_DATE" \
            '.[$k] = $v' <<< "$UPDATED_VERSION_JSON")
          UPDATE_VERSION_FILE=true
          echo "æ›´æ–°é¢„å‘å¸ƒç‰ˆ: $NEW_PRE_RELEASE_VERSION ($NEW_PRE_RELEASE_DATE)"
        fi
        
        # ä¸Šä¼ ç‰ˆæœ¬æ–‡ä»¶ï¼ˆå¦‚æœæœ‰æ›´æ–°ï¼‰
        if $UPDATE_VERSION_FILE; then
          ENCODED_CONTENT=$(echo -n "$UPDATED_VERSION_JSON" | base64 -w0)
          curl -s -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg msg "æ›´æ–°ç‰ˆæœ¬å·" \
              --arg content "$ENCODED_CONTENT" \
              --arg sha "$SHA_VERSION" \
              '{message: $msg, content: $content, sha: $sha}')" \
            "https://api.github.com/repos/$TARGET_REPO/contents/version.txt" > /dev/null
        else
          echo "ç‰ˆæœ¬æ–‡ä»¶æ— éœ€æ›´æ–°"
        fi
        
        # ä¸Šä¼ APKæ–‡ä»¶
        upload_apk() {
          local key="$1"
          local version="$2"
          
          # è·å–å½“å‰æ–‡ä»¶çš„SHAï¼ˆç”¨äºæ›´æ–°ï¼‰
          local file_info=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/apk/$key")
          local sha=$(jq -r '.sha? // empty' <<< "$file_info")
          
          curl -s -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg msg "æ›´æ–°APK: $key ($version)" \
              --arg content "$(base64 -w0 "$WORK_DIR/$key")" \
              --arg sha "$sha" \
              '{message: $msg, content: $content, sha: $sha}')" \
            "https://api.github.com/repos/$TARGET_REPO/contents/apk/$key" > /dev/null
        }
        
        $STABLE_NEED_UPDATE && upload_apk "$STABLE_KEY_NAME" "$NEW_STABLE_VERSION"
        $PRE_RELEASE_NEED_UPDATE && upload_apk "$PRE_RELEASE_KEY_NAME" "$NEW_PRE_RELEASE_VERSION"
        
        echo "åŒæ­¥å®Œæˆ!"
        echo "ç¨³å®šç‰ˆ: ${NEW_STABLE_VERSION:-æ— } (${NEW_STABLE_DATE:-æ— æ—¥æœŸ})"
        echo "é¢„å‘å¸ƒç‰ˆ: ${NEW_PRE_RELEASE_VERSION:-æ— } (${NEW_PRE_RELEASE_DATE:-æ— æ—¥æœŸ})"
        exit 0

    - name: Release Repository Lock ğŸ”“
      if: always()
      run: |
        # é‡Šæ”¾é”
        LOCK_FILE="$GITHUB_WORKSPACE/.lock/repo-lock"
        if [ -f "$LOCK_FILE" ]; then
          rm -f "$LOCK_FILE"
          echo "é”å·²é‡Šæ”¾"
        else
          echo "é”æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ— éœ€é‡Šæ”¾"
        fi

  cleanup_self:
    name: Cleanup Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "BV APK Sync from Source Repository"
          repository: ${{ github.repository }}