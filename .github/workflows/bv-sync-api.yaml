name: BV APK Sync from Source Repository

on:
  schedule:
    - cron: '0 */24 * * *'
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Install dependencies
      run: sudo apt-get update && sudo apt-get install -y jq curl
        
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git config pull.rebase true
        git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
        
    - name: Acquire Repository Lock 🔒
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200

    - name: Run APK sync
      env:
        SOURCE_REPO: "aaa1115910/bv"
        TARGET_REPO: "${{ github.repository }}"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
        STABLE_APK_PATTERN: "release_default_universal.apk"
        PRE_RELEASE_APK_PATTERN: "alpha_default_universal.apk"
        STABLE_KEY_NAME: "bv.apk"
        PRE_RELEASE_KEY_NAME: "bv-beta.apk"
      run: |
        set -euo pipefail
        WORK_DIR=$(mktemp -d)
        trap 'rm -rf "$WORK_DIR"' EXIT
        
        # 验证令牌权限
        curl -s -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_REPO" | grep -q '"id"' || \
          { echo "错误: 令牌无效"; exit 1; }
        
        # 获取源仓库发布信息
        RELEASES_JSON=$(curl -sL "https://api.github.com/repos/$SOURCE_REPO/releases")
        
        # 函数: 提取版本信息
        extract_version() {
          local release_json="$1"
          local tag_name=$(jq -r '.tag_name // ""' <<< "$release_json")
          local name=$(jq -r '.name // ""' <<< "$release_json")
          local published_at=$(jq -r '.published_at' <<< "$release_json")
          
          # 提取版本号
          if [[ "$tag_name" =~ v?([0-9]+\.[0-9]+\.[0-9]+) ]]; then
            version="v${BASH_REMATCH[1]}"
          elif [[ "$name" =~ ([0-9]+\.[0-9]+\.[0-9]+) ]]; then
            version="v${BASH_REMATCH[1]}"
          else
            version="$tag_name"
          fi
          
          date_utc8=$(TZ=UTC date -d "$published_at" +'%Y-%m-%d')
          echo "$version $date_utc8"
        }
        
        # 初始化变量避免未定义错误
        NEW_STABLE_VERSION=""
        NEW_STABLE_DATE=""
        NEW_PRE_RELEASE_VERSION=""
        NEW_PRE_RELEASE_DATE=""
        STABLE_NEED_UPDATE=false
        PRE_RELEASE_NEED_UPDATE=false
        
        # 处理稳定版
        SYNC_STABLE=true
        LATEST_STABLE=$(jq -r 'map(select(.prerelease == false)) | sort_by(.published_at) | reverse | .[0]' <<< "$RELEASES_JSON")
        if [ -z "$LATEST_STABLE" ] || [ "$LATEST_STABLE" = "null" ]; then
          SYNC_STABLE=false
          echo "警告: 未找到稳定版发布"
        else
          read STABLE_VERSION STABLE_DATE_UTC8 <<< $(extract_version "$LATEST_STABLE")
          echo "稳定版: $STABLE_VERSION (发布于: $STABLE_DATE_UTC8)"
        fi
        
        # 处理预发行版
        SYNC_PRE_RELEASE=true
        LATEST_PRE_RELEASE=$(jq -r 'map(select(.prerelease == true)) | sort_by(.published_at) | reverse | .[0]' <<< "$RELEASES_JSON")
        if [ -z "$LATEST_PRE_RELEASE" ] || [ "$LATEST_PRE_RELEASE" = "null" ]; then
          SYNC_PRE_RELEASE=false
          echo "警告: 未找到预发行版发布"
        else
          read PRE_RELEASE_VERSION PRE_RELEASE_DATE_UTC8 <<< $(extract_version "$LATEST_PRE_RELEASE")
          echo "预发行版: $PRE_RELEASE_VERSION (发布于: $PRE_RELEASE_DATE_UTC8)"
        fi
        
        # 获取目标仓库当前版本
        VERSION_FILE=$(curl -s -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
        
        declare -A CURRENT_VERSIONS
        if [ "$(jq -r '.message' <<< "$VERSION_FILE")" != "Not Found" ]; then
          CONTENT=$(jq -r '.content' <<< "$VERSION_FILE" | base64 -d)
          echo "当前版本文件: $CONTENT"
          
          while IFS="=" read -r key value; do
            [[ $key ]] && CURRENT_VERSIONS[$key]=$value
          done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "$CONTENT" 2>/dev/null)
        fi
        
        # 函数: 检查并下载APK
        process_apk() {
          local release_json="$1"
          local pattern="$2"
          local key="$3"
          local target="apk/$key"
          
          local current="${CURRENT_VERSIONS[$key]%,*}"
          local latest=$(jq -r '.tag_name' <<< "$release_json")
          
          # 检查是否需要更新
          local status_code=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target")
            
          if [ "$status_code" != "200" ] || [ "$latest" != "$current" ]; then
            # 获取下载链接
            local url=$(jq -r '.assets[] | select(.name | contains("'"$pattern"'")) | .browser_download_url' <<< "$release_json" | head -1)
            [ -z "$url" ] && { echo "警告: 未找到匹配的APK文件"; return 1; }
            
            echo "下载APK: $(basename "$url")"
            curl -sL "$url" -o "$WORK_DIR/$key"
            return 0
          fi
          return 1
        }
        
        # 处理稳定版APK
        if $SYNC_STABLE; then
          if process_apk "$LATEST_STABLE" "$STABLE_APK_PATTERN" "$STABLE_KEY_NAME"; then
            STABLE_NEED_UPDATE=true
            NEW_STABLE_VERSION="$STABLE_VERSION"
            NEW_STABLE_DATE="$STABLE_DATE_UTC8"
          else
            # 使用当前版本
            if [ -n "${CURRENT_VERSIONS[$STABLE_KEY_NAME]}" ]; then
              NEW_STABLE_VERSION="${CURRENT_VERSIONS[$STABLE_KEY_NAME]%,*}"
              NEW_STABLE_DATE="${CURRENT_VERSIONS[$STABLE_KEY_NAME]#*,}"
            else
              NEW_STABLE_VERSION=""
              NEW_STABLE_DATE=""
            fi
          fi
        else
          # 使用当前版本
          if [ -n "${CURRENT_VERSIONS[$STABLE_KEY_NAME]}" ]; then
            NEW_STABLE_VERSION="${CURRENT_VERSIONS[$STABLE_KEY_NAME]%,*}"
            NEW_STABLE_DATE="${CURRENT_VERSIONS[$STABLE_KEY_NAME]#*,}"
          fi
        fi
        
        # 处理预发行版APK
        if $SYNC_PRE_RELEASE; then
          if process_apk "$LATEST_PRE_RELEASE" "$PRE_RELEASE_APK_PATTERN" "$PRE_RELEASE_KEY_NAME"; then
            PRE_RELEASE_NEED_UPDATE=true
            NEW_PRE_RELEASE_VERSION="$PRE_RELEASE_VERSION"
            NEW_PRE_RELEASE_DATE="$PRE_RELEASE_DATE_UTC8"
          else
            # 使用当前版本
            if [ -n "${CURRENT_VERSIONS[$PRE_RELEASE_KEY_NAME]}" ]; then
              NEW_PRE_RELEASE_VERSION="${CURRENT_VERSIONS[$PRE_RELEASE_KEY_NAME]%,*}"
              NEW_PRE_RELEASE_DATE="${CURRENT_VERSIONS[$PRE_RELEASE_KEY_NAME]#*,}"
            else
              NEW_PRE_RELEASE_VERSION=""
              NEW_PRE_RELEASE_DATE=""
            fi
          fi
        else
          # 使用当前版本
          if [ -n "${CURRENT_VERSIONS[$PRE_RELEASE_KEY_NAME]}" ]; then
            NEW_PRE_RELEASE_VERSION="${CURRENT_VERSIONS[$PRE_RELEASE_KEY_NAME]%,*}"
            NEW_PRE_RELEASE_DATE="${CURRENT_VERSIONS[$PRE_RELEASE_KEY_NAME]#*,}"
          fi
        fi
        
        # 更新版本数据
        declare -A NEW_VERSION_DATA
        [ -n "$NEW_STABLE_VERSION" ] && NEW_VERSION_DATA["$STABLE_KEY_NAME"]="$NEW_STABLE_VERSION,$NEW_STABLE_DATE"
        [ -n "$NEW_PRE_RELEASE_VERSION" ] && NEW_VERSION_DATA["$PRE_RELEASE_KEY_NAME"]="$NEW_PRE_RELEASE_VERSION,$NEW_PRE_RELEASE_DATE"
        
        # 上传版本文件
        SHA_VERSION=$(jq -r '.sha // empty' <<< "$VERSION_FILE")
        VERSION_CONTENT=$(jq -n '$ARGS.positional' --args "${NEW_VERSION_DATA[@]}")
        ENCODED_CONTENT=$(echo -n "$VERSION_CONTENT" | base64 -w0)
        
        curl -s -X PUT \
          -H "Authorization: token $TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg msg "更新版本号" \
            --arg content "$ENCODED_CONTENT" \
            --arg sha "$SHA_VERSION" \
            '{message: $msg, content: $content, sha: $sha}')" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt"
        
        # 上传APK文件
        upload_apk() {
          local key="$1"
          local version="$2"
          local target="apk/$key"
          
          local sha=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target" | jq -r '.sha // empty')
          
          curl -s -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg msg "更新APK: $key ($version)" \
              --arg content "$(base64 -w0 "$WORK_DIR/$key")" \
              --arg sha "$sha" \
              '{message: $msg, content: $content, sha: $sha}')" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target"
        }
        
        $STABLE_NEED_UPDATE && upload_apk "$STABLE_KEY_NAME" "$NEW_STABLE_VERSION"
        $PRE_RELEASE_NEED_UPDATE && upload_apk "$PRE_RELEASE_KEY_NAME" "$NEW_PRE_RELEASE_VERSION"
        
        echo "同步完成!"
        [ -n "$NEW_STABLE_VERSION" ] && echo "稳定版: $NEW_STABLE_VERSION ($NEW_STABLE_DATE)"
        [ -n "$NEW_PRE_RELEASE_VERSION" ] && echo "预发行版: $NEW_PRE_RELEASE_VERSION ($NEW_PRE_RELEASE_DATE)"
        exit 0

    - name: Release Repository Lock 🔓
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  cleanup_self:
    name: Cleanup Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "BV APK Sync from Source Repository"
          repository: ${{ github.repository }}