name: Ku9 APK Sync from LanZou Cloud

on:
  workflow_dispatch:

concurrency:
  group: sync-apk-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write

env:
  LANZOU_PHPSESSID: ${{ secrets.LANZOU_PHPSESSID }}
  LANZOU_YLOGIN: ${{ secrets.LANZOU_YLOGIN }}
  LANZOU_PHPDISK_INFO: ${{ secrets.LANZOU_PHPDISK_INFO }}
  LANZOU_51VCKE: ${{ secrets.LANZOU_51VCKE }}
  LANZOU_51VUFT: ${{ secrets.LANZOU_51VUFT }}
  LANZOU_UAG: ${{ secrets.LANZOU_UAG }}
  LANZOU_TFSTK: ${{ secrets.LANZOU_TFSTK }}
  LANZOU_TINS: ${{ secrets.LANZOU_TINS }}
  LANZOU_VTINS: ${{ secrets.LANZOU_VTINS }}

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Setup Git identity
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip aapt
        pip3 install requests beautifulsoup4
        
    - name: Create updated APK sync script
      run: |
        cat > lanzou_downloader.py << 'EOF'
        #!/usr/bin/env python3
        import requests
        from bs4 import BeautifulSoup
        import re
        import json
        import os
        import subprocess
        import time
        import logging
        from datetime import datetime, timedelta, timezone
        from urllib.parse import urlparse, unquote

        # 配置日志
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler()
            ]
        )
        logger = logging.getLogger(__name__)

        # 蓝奏云Cookie配置（使用GitHub Secrets注入）
        LANZOU_COOKIES = {
            "PHPSESSID": os.getenv('LANZOU_PHPSESSID'),
            "ylogin": os.getenv('LANZOU_YLOGIN'),
            "phpdisk_info": os.getenv('LANZOU_PHPDISK_INFO'),
            "__51cke__": "",
            "__51vcke__": os.getenv('LANZOU_51VCKE'),
            "__51vuft__": os.getenv('LANZOU_51VUFT'),
            "uag": os.getenv('LANZOU_UAG'),
            "tfstk": os.getenv('LANZOU_TFSTK'),
            "folder_id_c": "-1",
            "__tins__21412745": os.getenv('LANZOU_TINS'),
            "__51laig__": "10",
            "__vtins__": os.getenv('LANZOU_VTINS'),
        }

        # 蓝奏云文件配置
        FILE_CONFIG = {
            "ku9.apk": {
                "share_url": "https://wfy.lanzout.com/b0izqfjwb",
                "password": "123456"
            },
            "ku9-vlc.apk": {
                "share_url": "https://wfy.lanzout.com/b0izqfjwb",
                "password": "123456"
            }
        }

        def get_beijing_time():
            """获取北京时间"""
            utc_time = datetime.now(timezone.utc)
            beijing_time = utc_time + timedelta(hours=8)
            return beijing_time.strftime('%Y-%m-%d')

        def get_apk_version(apk_path):
            """使用aapt获取APK版本信息"""
            try:
                result = subprocess.run(
                    ['aapt', 'dump', 'badging', apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                output = result.stdout
                version_match = re.search(r"versionName='([^']+)'", output)
                if version_match:
                    return version_match.group(1)
                logger.error("无法从APK提取版本信息")
                return "unknown"
            except subprocess.CalledProcessError as e:
                logger.error(f"aapt命令执行失败: {e.stderr}")
                return "unknown"
            except FileNotFoundError:
                logger.error("aapt工具未找到，请确保已安装Android SDK工具")
                return "unknown"

        def extract_params(html):
            """从HTML中提取所有可能的参数"""
            params = {}
            
            # 1. 提取隐藏输入字段
            soup = BeautifulSoup(html, 'html.parser')
            for input_tag in soup.find_all('input', {'type': 'hidden'}):
                name = input_tag.get('name')
                value = input_tag.get('value', '')
                if name:
                    params[name] = value
            
            # 2. 提取JavaScript变量
            js_vars = [
                'sign', 't', 'k', 'websign', 'websignkey', 
                've', 'fid', 'uid', 'vip', 'file_id', 'action'
            ]
            for var in js_vars:
                match = re.search(rf'var\s+{var}\s*=\s*["\']?([^"\';]+)[^;]*;', html)
                if match:
                    params[var] = match.group(1).strip('"\'')
            
            # 3. 提取AJAX数据
            ajax_match = re.search(r'var ajaxdata\s*=\s*\'({.*?})\';', html)
            if ajax_match:
                try:
                    ajax_data = json.loads(ajax_match.group(1))
                    params.update(ajax_data)
                except json.JSONDecodeError:
                    logger.debug("无法解析AJAX数据")
            
            # 4. 提取全局变量
            global_match = re.search(r'<script>window\.(\w+)\s*=\s*"([^"]+)";</script>', html)
            if global_match:
                params[global_match.group(1)] = global_match.group(2)
            
            logger.debug(f"提取的参数: {params}")
            return params

        def debug_response(response):
            """记录响应信息用于调试"""
            logger.debug(f"响应状态码: {response.status_code}")
            logger.debug(f"响应头: {response.headers}")
            
            # 仅记录前500个字符的响应内容
            content = response.text[:500] + '...' if len(response.text) > 500 else response.text
            logger.debug(f"响应内容: {content}")

        def get_real_download_url(share_url, password):
            """获取蓝奏云文件的真实下载链接（调试版）"""
            session = requests.Session()
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.124 Safari/537.36",
                "Referer": share_url,
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
                "Cache-Control": "no-cache",
                "Pragma": "no-cache",
                "Connection": "keep-alive",
            }
            
            # 解析分享URL以获取基础域名
            parsed_url = urlparse(share_url)
            domain = parsed_url.netloc
            if not domain:
                logger.error("无法解析域名")
                return None
                
            # API URL
            api_url = f"https://{domain}/ajaxm.php"
            
            # 重试逻辑
            max_retries = 3
            for retry in range(max_retries):
                try:
                    # 1. 获取初始页面
                    logger.info(f"获取分享页面 ({retry+1}/{max_retries})")
                    res1 = session.get(share_url, headers=headers, cookies=LANZOU_COOKIES, timeout=20)
                    res1.raise_for_status()
                    
                    # 调试初始响应
                    logger.debug("初始页面响应:")
                    debug_response(res1)
                    
                    # 2. 提取所有可能的参数
                    params = extract_params(res1.text)
                    
                    # 3. 构造提交数据
                    post_data = {
                        "action": "downprocess",
                        "p": password,
                        "code": "",  # 可能需要的参数
                        "web": "0",  # 可能需要的参数
                    }
                    
                    # 添加提取的参数（只添加存在的参数）
                    for key in ["sign", "t", "k", "websign", "websignkey", "ve", "fid", "uid", "vip"]:
                        if key in params:
                            post_data[key] = params[key]
                    
                    logger.info(f"提交数据: { {k: v for k, v in post_data.items() if k not in ['p']} }...")
                    
                    # 4. 提交请求
                    post_headers = {
                        **headers,
                        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                        "X-Requested-With": "XMLHttpRequest",
                        "Origin": f"https://{domain}",
                    }
                    
                    res2 = session.post(
                        api_url,
                        data=post_data,
                        headers=post_headers,
                        cookies=LANZOU_COOKIES,
                        timeout=20
                    )
                    res2.raise_for_status()
                    
                    # 调试API响应
                    logger.debug("API响应:")
                    debug_response(res2)
                    
                    # 5. 解析响应
                    try:
                        # 尝试解析为JSON
                        json_data = res2.json()
                        logger.debug(f"解析的JSON: {json_data}")
                        
                        if json_data.get("zt") == 1:
                            # 获取下载URL
                            download_url = f"https://{json_data['dom']}/file/{json_data['url']}"
                            
                            # 处理特殊CDN链接
                            if "vip." in download_url:
                                download_url = download_url.replace("vip.", "developer.")
                            
                            logger.info(f"获取到下载URL: {download_url}")
                            return download_url
                        else:
                            error_msg = json_data.get('inf', '未知错误')
                            logger.error(f"API错误: {error_msg}")
                            return None
                            
                    except json.JSONDecodeError:
                        # 不是JSON响应，尝试从HTML提取直接下载链接
                        download_match = re.search(r'data: \{url: \'(https?://[^\']+)\'', res2.text)
                        if not download_match:
                            download_match = re.search(r'url: \'(https?://[^\']+)\'', res2.text)
                        
                        if download_match:
                            download_url = download_match.group(1)
                            logger.info(f"从HTML提取下载链接: {download_url}")
                            return download_url
                        else:
                            logger.error("响应不是有效的JSON，且无法从HTML提取下载链接")
                            return None
                        
                except requests.RequestException as e:
                    logger.error(f"请求失败: {e}")
                    if retry < max_retries - 1:
                        logger.info("等待3秒后重试...")
                        time.sleep(3)
                    
            return None

        def download_file(url, file_path):
            """下载文件"""
            try:
                headers = {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.124 Safari/537.36",
                    "Referer": "https://www.lanzoui.com/",
                    "Accept-Encoding": "gzip, deflate, br",
                    "Accept": "*/*",
                }
                
                with requests.get(url, stream=True, headers=headers, timeout=60) as r:
                    r.raise_for_status()
                    
                    # 检查文件大小
                    file_size = int(r.headers.get('Content-Length', 0))
                    if file_size < 100 * 1024:  # 小于100KB视为无效
                        logger.error(f"文件大小异常: {file_size} 字节")
                        return False
                    
                    # 下载文件
                    with open(file_path, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            if chunk:
                                f.write(chunk)
                                
                    return True
                    
            except requests.RequestException as e:
                logger.error(f"文件下载失败: {e}")
                return False

        def process_apk_file(file_name):
            """处理单个APK文件"""
            if file_name not in FILE_CONFIG:
                logger.error(f"找不到目标文件配置: {file_name}")
                return None
            
            config = FILE_CONFIG[file_name]
            share_url = config["share_url"]
            password = config["password"]
            target_path = f"apk/{file_name}"
            
            logger.info(f"开始处理: {file_name}")
            
            # 获取真实下载链接
            download_url = get_real_download_url(share_url, password)
            if not download_url:
                logger.error(f"无法获取 {file_name} 的下载链接")
                return None
            
            logger.info(f"获取到下载链接: {download_url}")
            
            # 下载文件
            temp_path = f"temp_{file_name}"
            if not download_file(download_url, temp_path):
                return None
            
            # 验证文件类型
            if not is_valid_apk(temp_path):
                logger.error(f"下载的文件不是有效的APK: {file_name}")
                os.remove(temp_path)
                return None
            
            # 获取版本信息
            version = get_apk_version(temp_path)
            date = get_beijing_time()
            
            # 移动文件到目标位置
            os.replace(temp_path, target_path)
            
            logger.info(f"成功下载: {file_name}, 版本: {version}, 日期: {date}")
            return {"version": version, "date": date}

        def is_valid_apk(file_path):
            """检查文件是否为有效的APK"""
            try:
                # 检查文件大小
                if os.path.getsize(file_path) < 10 * 1024:  # 小于10KB视为无效
                    return False
                    
                # 检查文件类型
                with open(file_path, 'rb') as f:
                    header = f.read(4)
                    # APK文件以PK开头（ZIP格式）
                    return header == b'PK\x03\x04'
            except Exception as e:
                logger.error(f"文件验证失败: {e}")
                return False

        def update_version_file(new_versions):
            """更新版本文件"""
            version_data = {}
            version_file = "version.txt"
            
            # 读取现有版本数据
            if os.path.exists(version_file):
                try:
                    with open(version_file, 'r') as f:
                        version_data = json.load(f)
                except (json.JSONDecodeError, Exception) as e:
                    logger.warning(f"版本文件格式错误或损坏，将创建新文件: {e}")
                    version_data = {}
            
            # 更新数据
            for file_name, data in new_versions.items():
                if data:  # 只有成功下载时才更新
                    version_data[file_name] = f"{data['version']},{data['date']}"
            
            # 写入文件
            with open(version_file, 'w') as f:
                json.dump(version_data, f, indent=2)
            
            logger.info("版本文件已更新")

        def main():
            logger.info("蓝奏云APK同步开始")
            start_time = time.time()
            
            # 确保apk目录存在
            os.makedirs("apk", exist_ok=True)
            
            # 处理所有文件
            new_versions = {}
            for file_name in FILE_CONFIG.keys():
                result = process_apk_file(file_name)
                new_versions[file_name] = result
            
            # 更新版本文件
            update_version_file(new_versions)
            
            # 统计结果
            success_count = sum(1 for v in new_versions.values() if v)
            elapsed = time.time() - start_time
            logger.info(f"同步完成! 成功: {success_count}/{len(FILE_CONFIG)}, 耗时: {elapsed:.2f}秒")
            
            # 如果有失败，返回错误状态
            if success_count < len(FILE_CONFIG):
                exit(1)

        if __name__ == "__main__":
            main()
        EOF
        chmod +x lanzou_downloader.py
        
    - name: List directory contents (debug)
      run: |
        echo "当前工作目录: $(pwd)"
        echo "文件列表:"
        ls -la
        
    - name: Run APK sync script
      run: python3 lanzou_downloader.py
        
    - name: Commit and push changes
      if: success()
      run: |
        if git diff --quiet -- apk version.txt; then
          echo "没有检测到更改，跳过提交"
        else
          echo "提交更改到Git仓库..."
          git add apk/* version.txt
          git commit -m "自动更新APK文件"
          
          # 重试推送机制
          MAX_RETRIES=3
          RETRY_DELAY=10
          for i in $(seq 1 $MAX_RETRIES); do
            echo "推送更改 (尝试 $i/$MAX_RETRIES)..."
            git pull --rebase origin $(git rev-parse --abbrev-ref HEAD)
            if git push origin $(git rev-parse --abbrev-ref HEAD); then
              echo "推送成功"
              break
            else
              echo "推送失败，等待重试..."
              sleep $RETRY_DELAY
            fi
            if [ $i -eq $MAX_RETRIES ]; then
              echo "错误: 推送失败，超过最大重试次数"
              exit 1
            fi
          done
        fi

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Ku9 APK Sync from LanZou Cloud"
          repository: ${{ github.repository }}
