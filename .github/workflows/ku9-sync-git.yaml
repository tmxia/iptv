name: Ku9 APK Sync from LanZou Cloud

on:
  schedule:
    - cron: '0 */12 * * *'  # 每12小时运行一次
  workflow_dispatch:

concurrency:
  group: sync-apk-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write

env:
  LANZOU_PHPSESSID: ${{ secrets.LANZOU_PHPSESSID }}
  LANZOU_YLOGIN: ${{ secrets.LANZOU_YLOGIN }}
  LANZOU_PHPDISK_INFO: ${{ secrets.LANZOU_PHPDISK_INFO }}
  LANZOU_51VCKE: ${{ secrets.LANZOU_51VCKE }}
  LANZOU_51VUFT: ${{ secrets.LANZOU_51VUFT }}
  LANZOU_UAG: ${{ secrets.LANZOU_UAG }}
  LANZOU_TFSTK: ${{ secrets.LANZOU_TFSTK }}
  LANZOU_TINS: ${{ secrets.LANZOU_TINS }}
  LANZOU_VTINS: ${{ secrets.LANZOU_VTINS }}

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Setup Git identity
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip aapt
        pip3 install requests beautifulsoup4
        
    - name: Create updated APK sync script
      run: |
        cat > lanzou_downloader.py << 'EOF'
        #!/usr/bin/env python3
        import requests
        from bs4 import BeautifulSoup
        import re
        import json
        import os
        import subprocess
        import time
        import logging
        from datetime import datetime, timedelta, timezone
        from urllib.parse import urlparse, unquote

        # 配置日志
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler()
            ]
        )
        logger = logging.getLogger(__name__)

        # 蓝奏云Cookie配置（使用GitHub Secrets注入）
        LANZOU_COOKIES = {
            "PHPSESSID": os.getenv('LANZOU_PHPSESSID'),
            "ylogin": os.getenv('LANZOU_YLOGIN'),
            "phpdisk_info": os.getenv('LANZOU_PHPDISK_INFO'),
            "__51cke__": "",
            "__51vcke__": os.getenv('LANZOU_51VCKE'),
            "__51vuft__": os.getenv('LANZOU_51VUFT'),
            "uag": os.getenv('LANZOU_UAG'),
            "tfstk": os.getenv('LANZOU_TFSTK'),
            "folder_id_c": "-1",
            "__tins__21412745": os.getenv('LANZOU_TINS'),
            "__51laig__": "10",
            "__vtins__": os.getenv('LANZOU_VTINS'),
        }

        # 蓝奏云文件配置
        FILE_CONFIG = {
            "ku9.apk": {
                "share_url": "https://wfy.lanzout.com/b0izqfjwb",
                "password": "123456"
            },
            "ku9-vlc.apk": {
                "share_url": "https://wfy.lanzout.com/b0izqfjwb",
                "password": "123456"
            }
        }

        def get_beijing_time():
            """获取北京时间"""
            utc_time = datetime.now(timezone.utc)
            beijing_time = utc_time + timedelta(hours=8)
            return beijing_time.strftime('%Y-%m-%d')

        def get_apk_version(apk_path):
            """使用aapt获取APK版本信息"""
            try:
                result = subprocess.run(
                    ['aapt', 'dump', 'badging', apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                output = result.stdout
                version_match = re.search(r"versionName='([^']+)'", output)
                if version_match:
                    return version_match.group(1)
                logger.error("无法从APK提取版本信息")
                return "unknown"
            except subprocess.CalledProcessError as e:
                logger.error(f"aapt命令执行失败: {e.stderr}")
                return "unknown"
            except FileNotFoundError:
                logger.error("aapt工具未找到，请确保已安装Android SDK工具")
                return "unknown"

        def extract_params(html):
            """从HTML中提取所有可能的参数"""
            params = {}
            # 尝试提取标准参数
            sign_match = re.search(r"sign\s*[:=]\s*['\"]?(\w+)['\"]?", html)
            websign_match = re.search(r"websign\s*[:=]\s*['\"]?(\w+)['\"]?", html)
            websignkey_match = re.search(r"websignkey\s*[:=]\s*['\"]?(\w+)['\"]?", html)
            
            if sign_match: params["sign"] = sign_match.group(1)
            if websign_match: params["websign"] = websign_match.group(1)
            if websignkey_match: params["websignkey"] = websignkey_match.group(1)
            
            # 尝试提取AJAX数据
            ajax_match = re.search(r"var ajaxdata\s*=\s*'({.*?})';", html)
            if ajax_match:
                try:
                    ajax_data = json.loads(ajax_match.group(1))
                    params.update(ajax_data)
                except json.JSONDecodeError:
                    logger.warning("无法解析AJAX数据")
            
            # 尝试提取隐藏输入字段
            soup = BeautifulSoup(html, 'html.parser')
            for input_tag in soup.find_all('input', {'type': 'hidden'}):
                name = input_tag.get('name')
                value = input_tag.get('value', '')
                if name:
                    params[name] = value
            
            return params

        def get_real_download_url(share_url, password):
            """获取蓝奏云文件的真实下载链接（加强版）"""
            session = requests.Session()
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36",
                "Referer": share_url,
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
                "Cache-Control": "no-cache",
                "Pragma": "no-cache",
            }
            
            # 解析分享URL以获取基础域名
            parsed_url = urlparse(share_url)
            domain = parsed_url.netloc
            if not domain:
                logger.error("无法解析域名")
                return None
                
            # 修正API URL
            api_url = f"https://{domain}/ajaxm.php"
            
            # 重试逻辑
            max_retries = 3
            for retry in range(max_retries):
                try:
                    # 1. 获取初始页面
                    logger.info(f"获取分享页面 ({retry+1}/{max_retries})")
                    res1 = session.get(share_url, headers=headers, cookies=LANZOU_COOKIES)
                    res1.raise_for_status()
                    
                    # 2. 提取所有可能的参数
                    params = extract_params(res1.text)
                    
                    # 3. 构造提交数据
                    post_data = {
                        "action": "downprocess",
                        "p": password,
                        "code": "",  # 可能需要的参数
                        "web": "0",  # 可能需要的参数
                    }
                    
                    # 添加提取的参数
                    for key in ["sign", "t", "k", "websign", "websignkey", "ve", "fid", "uid", "vip"]:
                        if key in params:
                            post_data[key] = params[key]
                    
                    logger.info(f"提交数据: { {k: v for k, v in post_data.items() if k not in ['p']} }...")
                    
                    # 4. 提交请求
                    res2 = session.post(
                        api_url,
                        data=post_data,
                        headers={
                            "Content-Type": "application/x-www-form-urlencoded",
                            "Referer": share_url,
                            "Origin": f"https://{domain}",
                            "X-Requested-With": "XMLHttpRequest",
                        },
                        cookies=LANZOU_COOKIES
                    )
                    res2.raise_for_status()
                    
                    try:
                        json_data = res2.json()
                        if json_data.get("zt") != 1:
                            logger.error(f"验证失败: {json_data.get('inf', '未知错误')}")
                            if "刷新" in json_data.get('inf', '') and retry < max_retries - 1:
                                logger.info("页面要求刷新，重试中...")
                                time.sleep(2)  # 等待2秒后重试
                                continue
                            return None
                            
                        # 获取下载URL
                        download_url = f"https://{json_data['dom']}/file/{json_data['url']}"
                        if "vip." in download_url:
                            download_url = download_url.replace("vip.", "developer.")
                            
                        logger.info(f"获取到下载URL: {download_url}")
                        
                        # 5. 获取最终下载链接
                        res3 = session.get(download_url, headers=headers, allow_redirects=False)
                        if res3.status_code == 302:
                            final_url = res3.headers['Location']
                            logger.info(f"解析到最终下载链接: {final_url}")
                            return final_url
                        else:
                            return download_url
                    
                    except json.JSONDecodeError:
                        logger.error("响应不是有效的JSON")
                        return None
                        
                except requests.RequestException as e:
                    logger.error(f"请求失败: {e}")
                    if retry < max_retries - 1:
                        logger.info("等待2秒后重试...")
                        time.sleep(2)
                    
            return None

        def download_file(url, file_path):
            """下载文件"""
            try:
                headers = {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36",
                    "Referer": "https://www.lanzoui.com/",
                    "Accept-Encoding": "gzip, deflate, br",
                }
                
                with requests.get(url, stream=True, headers=headers, timeout=30) as r:
                    r.raise_for_status()
                    
                    # 检查文件大小
                    file_size = int(r.headers.get('Content-Length', 0))
                    if file_size < 100 * 1024:  # 小于100KB视为无效
                        logger.error(f"文件大小异常: {file_size} 字节")
                        return False
                    
                    # 下载文件
                    with open(file_path, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            if chunk:
                                f.write(chunk)
                                
                    return True
                    
            except requests.RequestException as e:
                logger.error(f"文件下载失败: {e}")
                return False

        def process_apk_file(file_name):
            """处理单个APK文件"""
            if file_name not in FILE_CONFIG:
                logger.error(f"找不到目标文件配置: {file_name}")
                return None
            
            config = FILE_CONFIG[file_name]
            share_url = config["share_url"]
            password = config["password"]
            target_path = f"apk/{file_name}"
            
            logger.info(f"开始处理: {file_name}")
            
            # 获取真实下载链接
            download_url = get_real_download_url(share_url, password)
            if not download_url:
                logger.error(f"无法获取 {file_name} 的下载链接")
                return None
            
            logger.info(f"获取到下载链接: {download_url}")
            
            # 下载文件
            temp_path = f"temp_{file_name}"
            if not download_file(download_url, temp_path):
                return None
            
            # 验证文件类型
            if not is_valid_apk(temp_path):
                logger.error(f"下载的文件不是有效的APK: {file_name}")
                os.remove(temp_path)
                return None
            
            # 获取版本信息
            version = get_apk_version(temp_path)
            date = get_beijing_time()
            
            # 移动文件到目标位置
            os.replace(temp_path, target_path)
            
            logger.info(f"成功下载: {file_name}, 版本: {version}, 日期: {date}")
            return {"version": version, "date": date}

        def is_valid_apk(file_path):
            """检查文件是否为有效的APK"""
            try:
                # 检查文件大小
                if os.path.getsize(file_path) < 10 * 1024:  # 小于10KB视为无效
                    return False
                    
                # 检查文件类型
                with open(file_path, 'rb') as f:
                    header = f.read(4)
                    # APK文件以PK开头（ZIP格式）
                    return header == b'PK\x03\x04'
            except Exception as e:
                logger.error(f"文件验证失败: {e}")
                return False

        def update_version_file(new_versions):
            """更新版本文件"""
            version_data = {}
            version_file = "version.txt"
            
            # 读取现有版本数据
            if os.path.exists(version_file):
                try:
                    with open(version_file, 'r') as f:
                        version_data = json.load(f)
                except (json.JSONDecodeError, Exception) as e:
                    logger.warning(f"版本文件格式错误或损坏，将创建新文件: {e}")
                    version_data = {}
            
            # 更新数据
            for file_name, data in new_versions.items():
                if data:  # 只有成功下载时才更新
                    version_data[file_name] = f"{data['version']},{data['date']}"
            
            # 写入文件
            with open(version_file, 'w') as f:
                json.dump(version_data, f, indent=2)
            
            logger.info("版本文件已更新")

        def main():
            logger.info("蓝奏云APK同步开始")
            start_time = time.time()
            
            # 确保apk目录存在
            os.makedirs("apk", exist_ok=True)
            
            # 处理所有文件
            new_versions = {}
            for file_name in FILE_CONFIG.keys():
                result = process_apk_file(file_name)
                new_versions[file_name] = result
            
            # 更新版本文件
            update_version_file(new_versions)
            
            # 统计结果
            success_count = sum(1 for v in new_versions.values() if v)
            elapsed = time.time() - start_time
            logger.info(f"同步完成! 成功: {success_count}/{len(FILE_CONFIG)}, 耗时: {elapsed:.2f}秒")
            
            # 如果有失败，返回错误状态
            if success_count < len(FILE_CONFIG):
                exit(1)

        if __name__ == "__main__":
            main()
        EOF
        chmod +x lanzou_downloader.py
        
    - name: List directory contents (debug)
      run: |
        echo "当前工作目录: $(pwd)"
        echo "文件列表:"
        ls -la
        
    - name: Run APK sync script
      run: python3 lanzou_downloader.py
        
    - name: Commit and push changes
      if: success()
      run: |
        if git diff --quiet -- apk version.txt; then
          echo "没有检测到更改，跳过提交"
        else
          echo "提交更改到Git仓库..."
          git add apk/* version.txt
          git commit -m "自动更新APK文件"
          
          # 重试推送机制
          MAX_RETRIES=3
          RETRY_DELAY=10
          for i in $(seq 1 $MAX_RETRIES); do
            echo "推送更改 (尝试 $i/$MAX_RETRIES)..."
            git pull --rebase origin $(git rev-parse --abbrev-ref HEAD)
            if git push origin $(git rev-parse --abbrev-ref HEAD); then
              echo "推送成功"
              break
            else
              echo "推送失败，等待重试..."
              sleep $RETRY_DELAY
            fi
            if [ $i -eq $MAX_RETRIES ]; then
              echo "错误: 推送失败，超过最大重试次数"
              exit 1
            fi
          done
        fi

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Ku9 APK Sync from LanZou Cloud"
          repository: ${{ github.repository }}
