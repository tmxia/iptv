name: Ku9 APK Sync from LanZou Cloud

on:
  schedule:
    - cron: '0 */12 * * *'  # 每12小时运行一次
  workflow_dispatch:

concurrency:
  group: sync-apk-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write

env:
  LANZOU_PHPSESSID: ${{ secrets.LANZOU_PHPSESSID }}
  LANZOU_YLOGIN: ${{ secrets.LANZOU_YLOGIN }}
  LANZOU_PHPDISK_INFO: ${{ secrets.LANZOU_PHPDISK_INFO }}
  LANZOU_51VCKE: ${{ secrets.LANZOU_51VCKE }}
  LANZOU_51VUFT: ${{ secrets.LANZOU_51VUFT }}
  LANZOU_UAG: ${{ secrets.LANZOU_UAG }}
  LANZOU_TFSTK: ${{ secrets.LANZOU_TFSTK }}
  LANZOU_TINS: ${{ secrets.LANZOU_TINS }}
  LANZOU_VTINS: ${{ secrets.LANZOU_VTINS }}

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Setup Git identity
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip aapt
        pip3 install requests beautifulsoup4
        
    - name: Create APK sync script
      run: |
        cat > lanzou_downloader.py << 'EOF'
        #!/usr/bin/env python3
        import requests
        from bs4 import BeautifulSoup
        import re
        import json
        import os
        import subprocess
        import time
        import logging
        from datetime import datetime, timedelta, timezone

        # 配置日志
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler()
            ]
        )
        logger = logging.getLogger(__name__)

        # 蓝奏云Cookie配置（使用GitHub Secrets注入）
        LANZOU_COOKIES = {
            "PHPSESSID": os.getenv('LANZOU_PHPSESSID'),
            "ylogin": os.getenv('LANZOU_YLOGIN'),
            "phpdisk_info": os.getenv('LANZOU_PHPDISK_INFO'),
            "__51cke__": "",
            "__51vcke__": os.getenv('LANZOU_51VCKE'),
            "__51vuft__": os.getenv('LANZOU_51VUFT'),
            "uag": os.getenv('LANZOU_UAG'),
            "tfstk": os.getenv('LANZOU_TFSTK'),
            "folder_id_c": "-1",
            "__tins__21412745": os.getenv('LANZOU_TINS'),
            "__51laig__": "10",
            "__vtins__": os.getenv('LANZOU_VTINS'),
        }

        # 蓝奏云文件配置
        FILE_CONFIG = {
            "ku9.apk": {
                "share_url": "https://wfy.lanzout.com/b0izqfjwb",
                "password": "123456"
            },
            "ku9-vlc.apk": {
                "share_url": "https://wfy.lanzout.com/b0izqfjwb",
                "password": "123456"
            }
        }

        def get_beijing_time():
            """获取北京时间"""
            utc_time = datetime.now(timezone.utc)
            beijing_time = utc_time + timedelta(hours=8)
            return beijing_time.strftime('%Y-%m-%d')

        def get_apk_version(apk_path):
            """使用aapt获取APK版本信息"""
            try:
                result = subprocess.run(
                    ['aapt', 'dump', 'badging', apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                output = result.stdout
                version_match = re.search(r"versionName='([^']+)'", output)
                if version_match:
                    return version_match.group(1)
                logger.error("无法从APK提取版本信息")
                return "unknown"
            except subprocess.CalledProcessError as e:
                logger.error(f"aapt命令执行失败: {e.stderr}")
                return "unknown"
            except FileNotFoundError:
                logger.error("aapt工具未找到，请确保已安装Android SDK工具")
                return "unknown"

        def get_real_download_url(share_url, file_name, password):
            """获取蓝奏云文件的真实下载链接"""
            session = requests.Session()
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36",
                "Referer": share_url
            }
            
            # 1. 获取初始页面
            try:
                res1 = session.get(share_url, headers=headers, cookies=LANZOU_COOKIES)
                res1.raise_for_status()
            except requests.RequestException as e:
                logger.error(f"获取分享页面失败: {e}")
                return None
            
            # 2. 提取iframe链接
            soup = BeautifulSoup(res1.text, 'html.parser')
            iframe = soup.find('iframe', id='iframe')
            if not iframe:
                logger.error("未找到iframe元素，页面结构可能已改变")
                return None
            
            iframe_src = iframe.get('src')
            if not iframe_src:
                logger.error("iframe缺少src属性")
                return None
            
            # 3. 访问iframe页面
            try:
                iframe_url = f"https://www.lanzoui.com{iframe_src}"
                res2 = session.get(iframe_url, headers=headers, cookies=LANZOU_COOKIES)
                res2.raise_for_status()
            except requests.RequestException as e:
                logger.error(f"访问iframe页面失败: {e}")
                return None
            
            # 4. 提取ajaxdata
            ajax_data_match = re.search(r'var ajaxdata = \'({.*?})\';', res2.text)
            if not ajax_data_match:
                logger.error("未找到ajaxdata，页面结构可能已改变")
                return None
            
            try:
                ajax_data = json.loads(ajax_data_match.group(1))
            except json.JSONDecodeError:
                logger.error("解析ajaxdata失败")
                return None
            
            # 5. 提交下载请求
            post_url = "https://www.lanzoui.com/ajaxm.php"
            data = {
                "action": "downprocess",
                "sign": ajax_data["sign"],
                "p": password,
                "ve": ajax_data["ve"]
            }
            
            try:
                res3 = session.post(post_url, data=data, headers=headers, cookies=LANZOU_COOKIES)
                res3.raise_for_status()
                response_data = res3.json()
                
                if response_data.get("zt") != 1:
                    logger.error(f"下载请求失败: {response_data.get('inf', '未知错误')}")
                    return None
                    
                direct_url = f"{response_data['dom']}/file/{response_data['url']}"
            except (requests.RequestException, json.JSONDecodeError) as e:
                logger.error(f"获取下载链接失败: {e}")
                return None
            
            # 6. 获取最终下载链接
            try:
                res4 = session.head(direct_url, allow_redirects=False)
                if res4.status_code == 302:
                    return res4.headers['Location']
                logger.error(f"未获取到重定向链接，状态码: {res4.status_code}")
                return None
            except requests.RequestException as e:
                logger.error(f"获取最终下载链接失败: {e}")
                return None

        def download_file(url, file_path):
            """下载文件"""
            try:
                with requests.get(url, stream=True) as r:
                    r.raise_for_status()
                    with open(file_path, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            f.write(chunk)
                return True
            except requests.RequestException as e:
                logger.error(f"文件下载失败: {e}")
                return False

        def process_apk_file(file_name):
            """处理单个APK文件"""
            if file_name not in FILE_CONFIG:
                logger.error(f"找不到目标文件配置: {file_name}")
                return None
            
            config = FILE_CONFIG[file_name]
            share_url = config["share_url"]
            password = config["password"]
            target_path = f"apk/{file_name}"
            
            logger.info(f"开始处理: {file_name}")
            
            # 获取真实下载链接
            download_url = get_real_download_url(share_url, file_name, password)
            if not download_url:
                logger.error(f"无法获取 {file_name} 的下载链接")
                return None
            
            logger.info(f"获取到下载链接: {download_url}")
            
            # 下载文件
            temp_path = f"temp_{file_name}"
            if not download_file(download_url, temp_path):
                return None
            
            # 验证文件类型
            if not is_valid_apk(temp_path):
                logger.error(f"下载的文件不是有效的APK: {file_name}")
                os.remove(temp_path)
                return None
            
            # 获取版本信息
            version = get_apk_version(temp_path)
            date = get_beijing_time()
            
            # 移动文件到目标位置
            os.replace(temp_path, target_path)
            
            logger.info(f"成功下载: {file_name}, 版本: {version}, 日期: {date}")
            return {"version": version, "date": date}

        def is_valid_apk(file_path):
            """检查文件是否为有效的APK"""
            try:
                # 检查文件大小
                if os.path.getsize(file_path) < 1024:  # 小于1KB视为无效
                    return False
                    
                # 检查文件类型
                with open(file_path, 'rb') as f:
                    header = f.read(4)
                    # APK文件以PK开头（ZIP格式）
                    if header != b'PK\x03\x04':
                        return False
                return True
            except Exception:
                return False

        def update_version_file(new_versions):
            """更新版本文件"""
            version_data = {}
            version_file = "version.txt"
            
            # 读取现有版本数据
            if os.path.exists(version_file):
                try:
                    with open(version_file, 'r') as f:
                        version_data = json.load(f)
                except json.JSONDecodeError:
                    logger.warning("版本文件格式错误，将创建新文件")
            
            # 更新数据
            for file_name, data in new_versions.items():
                if data:  # 只有成功下载时才更新
                    version_data[file_name] = f"{data['version']},{data['date']}"
            
            # 写入文件
            with open(version_file, 'w') as f:
                json.dump(version_data, f, indent=2)
            
            logger.info("版本文件已更新")

        def main():
            logger.info("蓝奏云APK同步开始")
            start_time = time.time()
            
            # 确保apk目录存在
            os.makedirs("apk", exist_ok=True)
            
            # 处理所有文件
            new_versions = {}
            for file_name in FILE_CONFIG.keys():
                result = process_apk_file(file_name)
                new_versions[file_name] = result
            
            # 更新版本文件
            update_version_file(new_versions)
            
            # 统计结果
            success_count = sum(1 for v in new_versions.values() if v)
            elapsed = time.time() - start_time
            logger.info(f"同步完成! 成功: {success_count}/{len(FILE_CONFIG)}, 耗时: {elapsed:.2f}秒")
            
            # 如果有失败，返回错误状态
            if success_count < len(FILE_CONFIG):
                exit(1)

        if __name__ == "__main__":
            main()
        EOF
        chmod +x lanzou_downloader.py
        
    - name: List directory contents (debug)
      run: |
        echo "当前工作目录: $(pwd)"
        echo "文件列表:"
        ls -la
        
    - name: Run APK sync script
      run: python3 lanzou_downloader.py
        
    - name: Commit and push changes
      if: success()
      run: |
        if git diff --quiet -- apk version.txt; then
          echo "没有检测到更改，跳过提交"
        else
          echo "提交更改到Git仓库..."
          git add apk/* version.txt
          git commit -m "自动更新APK文件"
          
          # 重试推送机制
          MAX_RETRIES=3
          RETRY_DELAY=10
          for i in $(seq 1 $MAX_RETRIES); do
            echo "推送更改 (尝试 $i/$MAX_RETRIES)..."
            git pull --rebase origin $(git rev-parse --abbrev-ref HEAD)
            if git push origin $(git rev-parse --abbrev-ref HEAD); then
              echo "推送成功"
              break
            else
              echo "推送失败，等待重试..."
              sleep $RETRY_DELAY
            fi
            if [ $i -eq $MAX_RETRIES ]; then
              echo "错误: 推送失败，超过最大重试次数"
              exit 1
            fi
          done
        fi

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Ku9 APK Sync from LanZou Cloud"
          repository: ${{ github.repository }}
