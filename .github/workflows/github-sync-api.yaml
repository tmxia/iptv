name: GitHub APK Download and Sync

on:
  schedule:
    - cron: '0 */12 * * *'  # 每12小时运行一次
  workflow_dispatch:        # 允许手动触发

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout current repository
      uses: actions/checkout@v5
      with:
        fetch-depth: 1

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl zip unzip
        
    - name: Download and process GitHub APK
      env:
        TARGET_REPO: "${{ github.repository }}"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
        APK_NAME: "github.apk"
        ZIP_NAME: "github.zip"
        VERSION_KEY: "github.zip"
        # 首选渠道
        APKMIRROR_BASE_URL: "https://www.apkmirror.com"
        APKMIRROR_GITHUB_PAGE: "https://www.apkmirror.com/apk/github/github-2/"
        # 备用渠道
        APKPURE_URL: "https://d.apkpure.net/b/XAPK/com.github.android?version=latest"
      run: |
        # 创建临时工作目录
        WORK_DIR=$(mktemp -d)
        echo "创建临时目录: $WORK_DIR"
        trap 'rm -rf "$WORK_DIR"; echo "清理临时目录..."' EXIT

        # 初始化变量
        VERSION=""
        SOURCE=""
        DOWNLOAD_SUCCESS=false
        
        echo "=== 第1步：尝试从首选渠道 (APKMirror) 下载 ==="
        
        # 1. 获取 APKMirror 上 GitHub 应用的版本列表页面
        echo "正在解析 APKMirror 版本列表页面..."
        LIST_PAGE_HTML=$(curl -sL \
          -H "User-Agent: Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36" \
          -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8" \
          -H "Accept-Language: en-US,en;q=0.9" \
          -H "Connection: keep-alive" \
          -H "Upgrade-Insecure-Requests: 1" \
          -H "Sec-Fetch-Dest: document" \
          -H "Sec-Fetch-Mode: navigate" \
          -H "Sec-Fetch-Site: none" \
          -H "Sec-Fetch-User: ?1" \
          -H "Cache-Control: max-age=0" \
          "$APKMIRROR_GITHUB_PAGE")
        
        # 2. 查找最新的版本详情页链接
        echo "正在查找最新版本详情页链接..."
        VERSION_PAGE_REL_PATH=$(echo "$LIST_PAGE_HTML" | grep -oP 'href="(/apk/github/github-2/github-\d+-\d+-\d+-[^"/]*/)"' | head -1 | cut -d'"' -f2)
        
        if [ -n "$VERSION_PAGE_REL_PATH" ]; then
          VERSION_PAGE_URL="${APKMIRROR_BASE_URL}${VERSION_PAGE_REL_PATH}"
          echo "发现版本详情页: $VERSION_PAGE_URL"
          
          # 3. 从详情页URL中提取版本号
          if [[ "$VERSION_PAGE_REL_PATH" =~ github-(\d+)-(\d+)-(\d+) ]]; then
            VERSION="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
            echo "从URL解析的版本号: $VERSION"
          fi
          
          # 4. 获取版本详情页内容
          echo "获取版本详情页内容..."
          VERSION_PAGE_HTML=$(curl -sL \
            -H "User-Agent: Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36" \
            -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8" \
            -H "Accept-Language: en-US,en;q=0.9" \
            -H "Connection: keep-alive" \
            -H "Upgrade-Insecure-Requests: 1" \
            -H "Sec-Fetch-Dest: document" \
            -H "Sec-Fetch-Mode: navigate" \
            -H "Sec-Fetch-Site: same-origin" \
            -H "Cache-Control: max-age=0" \
            "$VERSION_PAGE_URL")
          
          # 5. 改进的变体页面链接查找逻辑
          echo "正在查找变体(Variant)下载子页面链接..."
          
          # 方法1: 尝试从页面底部"All Releases"部分查找（这是最可能的位置）
          VARIANT_PAGE_REL_PATH=$(echo "$VERSION_PAGE_HTML" | grep -oP 'href="(/apk/github/github-2/github-\d+-\d+-\d+-[^"/]*/download/)"' | head -1 | cut -d'"' -f2)
          
          # 方法2: 如果方法1失败，尝试更宽松的匹配
          if [ -z "$VARIANT_PAGE_REL_PATH" ]; then
            VARIANT_PAGE_REL_PATH=$(echo "$VERSION_PAGE_HTML" | grep -i 'download' | grep -oP 'href="(/apk/github/github-2/[^"]*download[^"]*/)"' | head -1 | cut -d'"' -f2)
          fi
          
          # 方法3: 如果仍然找不到，尝试从页面中提取变体表格中的链接
          if [ -z "$VARIANT_PAGE_REL_PATH" ]; then
            # 查找包含变体信息的表格部分
            VARIANT_SECTION=$(echo "$VERSION_PAGE_HTML" | grep -oP '<div[^>]*variants-table[^>]*>.*?</div>' | head -1)
            if [ -n "$VARIANT_SECTION" ]; then
              VARIANT_PAGE_REL_PATH=$(echo "$VARIANT_SECTION" | grep -oP 'href="([^"]*download[^"]*)"' | head -1 | cut -d'"' -f2)
            fi
          fi
          
          if [ -n "$VARIANT_PAGE_REL_PATH" ]; then
            # 确保链接是完整的
            if [[ ! "$VARIANT_PAGE_REL_PATH" =~ ^https?:// ]]; then
              if [[ "$VARIANT_PAGE_REL_PATH" =~ ^/ ]]; then
                VARIANT_PAGE_URL="${APKMIRROR_BASE_URL}${VARIANT_PAGE_REL_PATH}"
              else
                # 相对路径，需要基于当前页面构建
                BASE_PATH=$(dirname "$VERSION_PAGE_URL")
                VARIANT_PAGE_URL="${BASE_PATH}/${VARIANT_PAGE_REL_PATH}"
              fi
            else
              VARIANT_PAGE_URL="$VARIANT_PAGE_REL_PATH"
            fi
            
            echo "发现变体下载子页面: $VARIANT_PAGE_URL"
            
            # 6. 获取变体子页面内容
            echo "获取变体子页面内容..."
            VARIANT_PAGE_HTML=$(curl -sL \
              -H "User-Agent: Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36" \
              -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8" \
              -H "Accept-Language: en-US,en;q=0.9" \
              -H "Connection: keep-alive" \
              -H "Upgrade-Insecure-Requests: 1" \
              -H "Sec-Fetch-Dest: document" \
              -H "Sec-Fetch-Mode: navigate" \
              -H "Sec-Fetch-Site: same-origin" \
              -H "Cache-Control: max-age=0" \
              "$VARIANT_PAGE_URL")
            
            # 7. 查找最终的APK下载链接
            echo "正在查找最终的APK下载链接..."
            
            # 方法1: 查找包含download.php的链接（新的格式）
            DOWNLOAD_REL_PATH=$(echo "$VARIANT_PAGE_HTML" | grep -oP 'href="(/wp-content/themes/APKMirror/download\.php\?id=[^"]*)"' | head -1 | cut -d'"' -f2)
            
            # 方法2: 如果方法1失败，尝试匹配id为download-link的链接
            if [ -z "$DOWNLOAD_REL_PATH" ]; then
              DOWNLOAD_REL_PATH=$(echo "$VARIANT_PAGE_HTML" | grep -oP '<a [^>]*id="download-link"[^>]*href="([^"]*)"' | head -1 | sed -n 's/.*href="\([^"]*\)".*/\1/p')
            fi
            
            # 方法3: 如果方法2失败，查找包含download.php的任何链接
            if [ -z "$DOWNLOAD_REL_PATH" ]; then
              DOWNLOAD_REL_PATH=$(echo "$VARIANT_PAGE_HTML" | grep -oP 'href="[^"]*download\.php[^"]*"' | head -1 | cut -d'"' -f2)
            fi
            
            # 方法4: 查找任何可能包含.apk的链接
            if [ -z "$DOWNLOAD_REL_PATH" ]; then
              DOWNLOAD_REL_PATH=$(echo "$VARIANT_PAGE_HTML" | grep -oP 'href="(https?://[^"]*\.apk(\?[^"]*)?)"' | head -1 | cut -d'"' -f2)
            fi
            
            # 方法5: 查找任何可能包含.apk的链接（不带https前缀的）
            if [ -z "$DOWNLOAD_REL_PATH" ]; then
              DOWNLOAD_REL_PATH=$(echo "$VARIANT_PAGE_HTML" | grep -oP 'href="([^"]*\.apk)"' | head -1 | cut -d'"' -f2)
            fi
            
            # 添加调试信息
            if [ -z "$DOWNLOAD_REL_PATH" ]; then
                echo "调试信息 - 页面内容中匹配到的链接："
                echo "$VARIANT_PAGE_HTML" | grep -o 'href="[^"]*"' | head -20
                echo "=========="
            fi
            
            if [ -n "$DOWNLOAD_REL_PATH" ]; then
              if [[ ! "$DOWNLOAD_REL_PATH" =~ ^https?:// ]]; then
                DOWNLOAD_URL="${APKMIRROR_BASE_URL}${DOWNLOAD_REL_PATH}"
              else
                DOWNLOAD_URL="$DOWNLOAD_REL_PATH"
              fi
              
              echo "构建的最终下载链接: $DOWNLOAD_URL"
              
              # 8. 尝试下载文件
              echo "正在从 APKMirror 下载 APK..."
              if curl -L -o "$WORK_DIR/$APK_NAME" \
                -H "User-Agent: Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36" \
                "$DOWNLOAD_URL"; then
                if [ -s "$WORK_DIR/$APK_NAME" ]; then
                  DOWNLOAD_SUCCESS=true
                  SOURCE="APKMirror"
                  APK_SIZE=$(stat -c%s "$WORK_DIR/$APK_NAME")
                  echo "✓ 成功从 APKMirror 下载 APK 文件 (大小: $((APK_SIZE/1024/1024)) MB)。"
                  
                  # 验证文件类型
                  FILE_TYPE=$(file -b --mime-type "$WORK_DIR/$APK_NAME")
                  echo "文件类型: $FILE_TYPE"
                  
                  if [[ "$FILE_TYPE" != "application/vnd.android.package-archive" ]] && [[ "$FILE_TYPE" != "application/zip" ]]; then
                    echo "警告: 下载的文件可能不是有效的APK文件，尝试备用渠道。"
                    DOWNLOAD_SUCCESS=false
                  fi
                else
                  echo "下载的文件为空，尝试备用渠道。"
                fi
              else
                echo "APKMirror 下载失败，尝试备用渠道。"
              fi
            else
              echo "未找到最终的APK下载链接，尝试备用渠道。"
            fi
          else
            echo "未找到变体下载子页面链接，尝试备用渠道。"
            
            # 调试：输出页面片段帮助诊断
            echo "页面内容片段（包含download关键词）:"
            echo "$VERSION_PAGE_HTML" | grep -i 'download' | head -5
          fi
        else
          echo "无法解析APKMirror页面上的版本链接，尝试备用渠道。"
        fi
        
        # 9. 如果 APKMirror 失败，回退到 APKPure
        if [ "$DOWNLOAD_SUCCESS" = false ]; then
          echo -e "\n=== 第2步：首选渠道失败，启用备用渠道 (APKPure) ==="
          SOURCE="APKPure"
          
          echo "正在从 APKPure 下载..."
          curl -L -o "$WORK_DIR/original.xapk" "$APKPURE_URL"
          
          if [ ! -s "$WORK_DIR/original.xapk" ]; then
            echo "错误: APKPure 下载也失败，请检查网络或链接有效性"
            exit 1
          fi
          
          # 从响应头获取原始文件名并提取版本号
          ORIG_FILENAME=$(curl -sLI "$APKPURE_URL" | grep -i 'content-disposition' | grep -o 'filename="[^"]*"' | cut -d'"' -f2 || echo "")
          echo "原始文件名: $ORIG_FILENAME"
          
          if [[ "$ORIG_FILENAME" =~ _([0-9]+\.[0-9]+\.[0-9]+)_ ]]; then
            VERSION="${BASH_REMATCH[1]}"
          elif [[ "$ORIG_FILENAME" =~ ([0-9]+\.[0-9]+\.[0-9]+) ]]; then
            VERSION="${BASH_REMATCH[1]}"
          else
            VERSION=$(date +%Y%m%d%H%M)
            echo "无法从文件名提取版本号，使用时间戳: $VERSION"
          fi
          
          # 重命名文件
          mv "$WORK_DIR/original.xapk" "$WORK_DIR/$APK_NAME"
          echo "从 $SOURCE 获取的版本号: $VERSION"
          DOWNLOAD_SUCCESS=true
        fi
        
        if [ "$DOWNLOAD_SUCCESS" = false ]; then
          echo "错误: 所有下载渠道均失败"
          exit 1
        fi
        
        # 10. 获取当前日期（北京时间）
        CURRENT_DATE=$(TZ=Asia/Shanghai date +"%Y-%m-%d")
        echo -e "\n=== 第3步：准备上传 ==="
        echo "来源: $SOURCE"
        echo "版本号: $VERSION"
        echo "日期: $CURRENT_DATE"
        
        # 11. 将APK压缩为ZIP文件
        echo "将APK文件压缩为ZIP..."
        zip -j "$WORK_DIR/$ZIP_NAME" "$WORK_DIR/$APK_NAME"
        if [ ! -f "$WORK_DIR/$ZIP_NAME" ]; then
          echo "错误: ZIP文件创建失败"
          exit 1
        fi
        ZIP_SIZE=$(stat -c%s "$WORK_DIR/$ZIP_NAME")
        echo "已创建ZIP文件: $ZIP_NAME (大小: $((ZIP_SIZE/1024/1024)) MB)"

        # 12. 获取目标仓库当前版本
        echo "检查目标仓库当前版本..."
        TARGET_VERSION_JSON=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
        
        CURRENT_VALUE=""
        CURRENT_CONTENT=""
        if [ "$(echo "$TARGET_VERSION_JSON" | jq -r '.message')" != "Not Found" ]; then
          VERSION_CONTENT=$(echo "$TARGET_VERSION_JSON" | jq -r '.content' | base64 -d)
          CURRENT_CONTENT="$VERSION_CONTENT"
          CURRENT_VALUE=$(echo "$VERSION_CONTENT" | jq -r ".\"$VERSION_KEY\"")
          if [ "$CURRENT_VALUE" = "null" ]; then
            CURRENT_VALUE=""
          fi
        fi
        
        # 提取当前版本号（如果存在）
        CURRENT_VERSION=""
        CURRENT_DATE_OLD=""
        if [ -n "$CURRENT_VALUE" ] && [[ "$CURRENT_VALUE" == *,* ]]; then
          CURRENT_VERSION=$(echo "$CURRENT_VALUE" | cut -d, -f1)
          CURRENT_DATE_OLD=$(echo "$CURRENT_VALUE" | cut -d, -f2)
        else
          CURRENT_VERSION="$CURRENT_VALUE"
        fi
        
        # 移除当前版本号可能存在的"v"前缀（用于比较）
        CURRENT_VERSION_NO_V=${CURRENT_VERSION#v}
        
        echo "当前仓库版本: $CURRENT_VERSION (日期: $CURRENT_DATE_OLD)"
        echo "本次获取版本: $VERSION (日期: $CURRENT_DATE)"
        
        # 创建新版本值（在版本号前添加v）
        NEW_VALUE="v$VERSION,$CURRENT_DATE"

        # 13. 检查是否需要更新
        NEED_UPDATE=false
        
        # 规则1: 版本不同时需要更新
        if [ "$VERSION" != "$CURRENT_VERSION_NO_V" ]; then
          echo "发现新版本，需要更新"
          NEED_UPDATE=true
        else
          # 规则2: 版本相同但文件不存在时需要更新
          echo "版本相同，检查ZIP文件是否存在..."
          ZIP_EXIST_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: token $TOKEN" \
              "https://api.github.com/repos/$TARGET_REPO/contents/apk/$ZIP_NAME")
          
          if [ "$ZIP_EXIST_RESPONSE" -ne 200 ]; then
            echo "ZIP文件不存在 (HTTP $ZIP_EXIST_RESPONSE)，需要上传"
            NEED_UPDATE=true
          else
            echo "版本相同且ZIP文件已存在，无需更新"
          fi
        fi

        if [ "$NEED_UPDATE" = false ]; then
          echo "无需更新，退出流程"
          exit 0
        fi

        # 14. 更新版本文件
        echo "更新版本文件..."
        NEW_VERSION_CONTENT="{}"
        if [ -n "$CURRENT_CONTENT" ]; then
          # 更新特定键值，保留其他内容
          NEW_VERSION_CONTENT=$(echo "$CURRENT_CONTENT" | jq --arg key "$VERSION_KEY" --arg value "$NEW_VALUE" '.[$key] = $value')
        else
          # 如果无版本文件，创建新JSON
          NEW_VERSION_CONTENT=$(jq -n --arg key "$VERSION_KEY" --arg value "$NEW_VALUE" '{($key): $value}')
        fi

        echo "新版本文件内容:"
        echo "$NEW_VERSION_CONTENT"

        # 获取版本文件的SHA（用于更新）
        VERSION_JSON=$(curl -s -H "Authorization: token $TOKEN" \
                        "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")

        SHA_VERSION=""
        if [ "$(echo "$VERSION_JSON" | jq -r '.message')" != "Not Found" ]; then
          SHA_VERSION=$(echo "$VERSION_JSON" | jq -r '.sha')
        fi

        # Base64编码版本文件
        VERSION_BASE64=$(echo -n "$NEW_VERSION_CONTENT" | base64 -w0)

        # 创建JSON请求
        JSON_VERSION=$(jq -n \
            --arg msg "更新GitHub APK (来源: $SOURCE): v$VERSION ($CURRENT_DATE)" \
            --arg content "$VERSION_BASE64" \
            --arg sha "$SHA_VERSION" \
            '{message: $msg, content: $content, sha: $sha}')

        # 上传版本文件
        echo "上传版本文件..."
        VERSION_RESPONSE=$(curl -s \
                  -X PUT \
                  -H "Authorization: token $TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "$JSON_VERSION" \
                  "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")

        # 检查错误
        ERROR_MESSAGE_VERSION=$(echo "$VERSION_RESPONSE" | jq -r '.message')
        if [ "$ERROR_MESSAGE_VERSION" != "null" ]; then
          echo "错误: 版本文件上传失败 - $ERROR_MESSAGE_VERSION"
          exit 1
        fi

        # 15. 上传ZIP文件
        echo "上传ZIP文件..."
        ZIP_JSON=$(curl -s -H "Authorization: token $TOKEN" \
                    "https://api.github.com/repos/$TARGET_REPO/contents/apk/$ZIP_NAME")
        
        SHA_ZIP=""
        if [ "$(echo "$ZIP_JSON" | jq -r '.message')" != "Not Found" ]; then
          SHA_ZIP=$(echo "$ZIP_JSON" | jq -r '.sha')
        fi

        # 创建JSON请求文件（处理大文件）
        JSON_FILE="$WORK_DIR/request.json"
        {
          echo '{'
          echo "  \"message\": \"更新GitHub APK (来源: $SOURCE): v$VERSION ($CURRENT_DATE)\","
          echo -n '  "content": "'
          base64 -w0 "$WORK_DIR/$ZIP_NAME" | tr -d '\n'
          echo '",'
          echo "  \"sha\": \"$SHA_ZIP\""
          echo '}'
        } > "$JSON_FILE"

        # 上传ZIP文件
        ZIP_RESPONSE=$(curl -s \
                  -X PUT \
                  -H "Authorization: token $TOKEN" \
                  -H "Content-Type: application/json" \
                  --data-binary "@$JSON_FILE" \
                  "https://api.github.com/repos/$TARGET_REPO/contents/apk/$ZIP_NAME")

        # 检查错误
        ERROR_MESSAGE_ZIP=$(echo "$ZIP_RESPONSE" | jq -r '.message')
        if [ "$ERROR_MESSAGE_ZIP" != "null" ]; then
          echo "错误: ZIP文件上传失败 - $ERROR_MESSAGE_ZIP"
          exit 1
        fi

        echo "同步完成! 新版本: v$VERSION, 日期: $CURRENT_DATE, 来源: $SOURCE"

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2.0.6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "GitHub APK Download and Sync"
          repository: ${{ github.repository }}