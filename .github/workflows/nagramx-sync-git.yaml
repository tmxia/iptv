name: NagramX Sync from Source Repository

on:
  schedule:
    - cron: '0 */24 * * *'  # ÊØè24Â∞èÊó∂ËøêË°å‰∏ÄÊ¨°
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout current repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        ref: main  # ÊòéÁ°ÆÊåáÂÆöÂàÜÊîØ

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl
        
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git config pull.rebase true  # ÈÖçÁΩÆrebaseÁ≠ñÁï•
        # ÊèêÂâçËÆæÁΩÆÂ∏¶ËÆ§ËØÅÁöÑËøúÁ®ãURL
        git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
        
    # Âú®ÂºÄÂßãÂêåÊ≠•ÂâçËé∑Âèñ‰ªìÂ∫ìÈîÅ
    - name: Acquire Repository Lock üîí
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20ÂàÜÈíüË∂ÖÊó∂

    - name: Run sync script
      env:
        SOURCE_REPO: "risin42/NagramX"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}  # ‰ΩøÁî®ËÆ§ËØÅ‰ª§Áâå
        APK_PATTERN: "arm64-v8a.apk"
        STABLE_TARGET_NAME: "nagramx.apk"  # ‰øÆÊ≠£‰∏∫Êõ¥ÂáÜÁ°ÆÁöÑÂèòÈáèÂêç
      run: |
        # ÁõÆÊ†áÊñá‰ª∂Ë∑ØÂæÑ
        STABLE_TARGET_PATH="apk/$STABLE_TARGET_NAME"
        
        # ÂàõÂª∫‰∏¥Êó∂Â∑•‰ΩúÁõÆÂΩï
        WORK_DIR=$(mktemp -d)
        echo "ÂàõÂª∫‰∏¥Êó∂ÁõÆÂΩï: $WORK_DIR"
        trap 'rm -rf "$WORK_DIR"; echo "Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï..."' EXIT

        # Ëé∑ÂèñÊâÄÊúâÂèëÂ∏ÉÁâàÔºà‰ΩøÁî®ËÆ§ËØÅ‰ª§ÁâåÔºâ
        echo "Ëé∑ÂèñÁ®≥ÂÆöÁâàÊú¨‰ø°ÊÅØ..."
        RELEASES_JSON=$(curl -sL -H "Authorization: Bearer $TOKEN" "https://api.github.com/repos/$SOURCE_REPO/releases")
        if [ $? -ne 0 ]; then
          echo "ÈîôËØØ: Êó†Ê≥ïËé∑ÂèñÂèëÂ∏É‰ø°ÊÅØ"
          exit 1
        fi

        # ÊèêÂèñÊúÄÊñ∞Á®≥ÂÆöÁâàÔºàËøáÊª§ÊéâÈ¢ÑÂèëÂ∏ÉÁâàÔºâ
        LATEST_STABLE_RELEASE=$(echo "$RELEASES_JSON" | jq -r 'map(select(.prerelease == false)) | sort_by(.published_at) | reverse | .[0]')
        if [ -z "$LATEST_STABLE_RELEASE" ] || [ "$LATEST_STABLE_RELEASE" = "null" ]; then
          echo "ÈîôËØØ: Êú™ÊâæÂà∞Á®≥ÂÆöÁâàÊú¨"
          exit 1
        fi
        
        # ÊèêÂèñÂèëÂ∏ÉÊó•ÊúüÂπ∂ËΩ¨Êç¢‰∏∫Âåó‰∫¨Êó∂Èó¥ (YYYY-MM-DD)
        STABLE_PUBLISHED_AT=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.published_at')
        RELEASE_DATE=$(TZ=UTC date -d "$STABLE_PUBLISHED_AT" +'%Y-%m-%d')
        
        # ‰ªéÂèëÂ∏ÉÊ†áÈ¢ò‰∏≠ÊèêÂèñÂÆåÊï¥ÁâàÊú¨Âè∑Âπ∂Ê∑ªÂä† 'v' ÂâçÁºÄ
        RAW_VERSION=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.name' | grep -oP '(\d+\.)+\d+' | head -1)
        if [ -z "$RAW_VERSION" ]; then
          # Â¶ÇÊûúÊó†Ê≥ï‰ªéÊ†áÈ¢òÊèêÂèñÔºåÂàô‰ΩøÁî®Ê†áÁ≠æÂêç‰Ωú‰∏∫Â§áÈÄâ
          RAW_VERSION=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.tag_name')
        fi
        
        # Á°Æ‰øùÁâàÊú¨Âè∑‰ª• 'v' ÂºÄÂ§¥
        if [[ ! "$RAW_VERSION" =~ ^v ]]; then
          STABLE_VERSION="v$RAW_VERSION"
        else
          STABLE_VERSION="$RAW_VERSION"
        fi
        
        echo "Ê∫ê‰ªìÂ∫ìÊúÄÊñ∞Á®≥ÂÆöÁâà: $STABLE_VERSION (ÂèëÂ∏É‰∫é: $RELEASE_DATE)"

        # Ê£ÄÊü•Êú¨Âú∞ÁâàÊú¨Êñá‰ª∂
        if [ ! -f "version.txt" ]; then
          echo "{}" > version.txt
        fi
        
        # ËØªÂèñÂΩìÂâçÁâàÊú¨‰ø°ÊÅØ
        CURRENT_VERSION_JSON=$(cat version.txt)
        
        # Ëß£ÊûêÂΩìÂâçÁ®≥ÂÆöÁâàÂíåÊó•Êúü
        CURRENT_STABLE_FULL=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$STABLE_TARGET_NAME\"")
        
        # ÂàÜÁ¶ªÁâàÊú¨ÂíåÊó•Êúü
        CURRENT_STABLE_VERSION=""
        CURRENT_STABLE_DATE=""
        if [ "$CURRENT_STABLE_FULL" != "null" ] && [[ "$CURRENT_STABLE_FULL" == *,* ]]; then
          CURRENT_STABLE_VERSION=$(echo "$CURRENT_STABLE_FULL" | cut -d, -f1)
          CURRENT_STABLE_DATE=$(echo "$CURRENT_STABLE_FULL" | cut -d, -f2)
        fi
        
        echo "ÂΩìÂâçÁ®≥ÂÆöÁâà: ${CURRENT_STABLE_VERSION:-Êó†} (Êó•Êúü: ${CURRENT_STABLE_DATE:-Êó†})"

        # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞
        need_update=false
        
        # Ê£ÄÊü•Á®≥ÂÆöÁâàÁâàÊú¨ÂíåÊñá‰ª∂
        if [ "$STABLE_VERSION" != "$CURRENT_STABLE_VERSION" ] || [ ! -f "$STABLE_TARGET_PATH" ]; then
          echo "Á®≥ÂÆöÁâàÈúÄË¶ÅÊõ¥Êñ∞: ÁâàÊú¨‰∏çÂåπÈÖçÊàñÊñá‰ª∂‰∏çÂ≠òÂú®"
          need_update=true
        fi
        
        if [ "$need_update" = false ]; then
          echo "ÁâàÊú¨Áõ∏Âêå‰∏îÊñá‰ª∂Â≠òÂú®ÔºåÊó†ÈúÄÊõ¥Êñ∞"
          # ÁªßÁª≠ÊâßË°åÂêéÁª≠Ê≠•È™§ÔºàÊµãËØïÁâàÂêåÊ≠•Ôºâ
        else
          # ‰∏ãËΩΩÊñ∞ÁâàÊú¨Êñá‰ª∂
          echo "‰∏ãËΩΩÊñ∞ÁâàÊú¨Êñá‰ª∂..."
          
          # Êü•ÊâæÁ®≥ÂÆöÁâàAPKÊñá‰ª∂
          apk_download_url=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.assets[] | select(.name | contains("'$APK_PATTERN'")) | .browser_download_url' | head -1)
          if [ -z "$apk_download_url" ]; then
            echo "ÈîôËØØ: Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÁ®≥ÂÆöÁâàAPKÊñá‰ª∂"
            exit 1
          fi
          
          # Á°Æ‰øùapkÁõÆÂΩïÂ≠òÂú®
          mkdir -p apk
          
          # ‰∏ãËΩΩÁ®≥ÂÆöÁâàAPK
          apk_source_name=$(basename "$apk_download_url")
          echo "‰∏ãËΩΩÁ®≥ÂÆöÁâàAPK: $apk_source_name"
          curl -sL "$apk_download_url" -o "$WORK_DIR/$apk_source_name"
          if [ ! -f "$WORK_DIR/$apk_source_name" ]; then
            echo "ÈîôËØØ: Á®≥ÂÆöÁâàAPK‰∏ãËΩΩÂ§±Ë¥•"
            exit 1
          fi
          
          # ÈáçÂëΩÂêçÂπ∂ÁßªÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
          mv "$WORK_DIR/$apk_source_name" "$STABLE_TARGET_PATH"
          echo "Êñá‰ª∂Â∑≤‰øùÂ≠òÂà∞: $STABLE_TARGET_PATH"

          # Êõ¥Êñ∞ÁâàÊú¨Êñá‰ª∂Ôºà‰øùÁïôÂÖ∂‰ªñÈîÆÂÄºÔºåÊ∑ªÂä†Êó•ÊúüÔºâ
          UPDATED_VERSION_JSON=$(echo "$CURRENT_VERSION_JSON" | jq \
            --arg stable_key "$STABLE_TARGET_NAME" \
            --arg stable_value "$STABLE_VERSION,$RELEASE_DATE" \
            '.[$stable_key] = $stable_value')
            
          echo "$UPDATED_VERSION_JSON" > version.txt
        fi

    - name: Set up Python for Beta Sync
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install Python dependencies for Beta Sync
      run: |
        pip install telethon pytz

    - name: Sync Beta from Telegram
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "NagramX"
        BETA_TARGET_NAME: "nagramx-beta.apk"
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import re
        import time
        import logging
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # ÈÖçÁΩÆÂèÇÊï∞
        BETA_TARGET_NAME = os.environ.get("BETA_TARGET_NAME", "nagramx-beta.apk")
        APK_DIR = "apk"
        WORK_DIR = os.path.join(os.getcwd(), "temp_beta_apk")
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # ÈÖçÁΩÆÊó•Âøó
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def parse_beta_version(filename):
            """‰ªéÊñá‰ª∂ÂêçËß£ÊûêÊµãËØïÁâàÁâàÊú¨Âè∑ÔºàÂè™ÊèêÂèñ‰∏ªÁâàÊú¨Âè∑Ôºâ"""
            # ÂåπÈÖçÊ®°ÂºèÔºöNagramX-vX.X.X
            pattern = r'NagramX-v(\d+\.\d+\.\d+)'
            match = re.search(pattern, filename)
            if match:
                return f"v{match.group(1)}"
            return None
        
        async def get_latest_beta_apk(client, channel_name):
            """Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊµãËØïÁâàAPKÊñá‰ª∂"""
            try:
                log.info(f"ËøûÊé•TelegramÈ¢ëÈÅì: {channel_name}")
                entity = await client.get_entity(channel_name)
                
                latest_apk = None
                
                # Ëé∑ÂèñÊúÄÊñ∞ÁöÑ20Êù°Ê∂àÊÅØ
                async for message in client.iter_messages(entity, limit=20):
                    if message.media and hasattr(message.media, "document"):
                        for attr in message.media.document.attributes:
                            if isinstance(attr, DocumentAttributeFilename):
                                filename = attr.file_name
                                if filename.endswith("-arm64-v8a.apk") and "NagramX-v" in filename:
                                    version = parse_beta_version(filename)
                                    if not version:
                                        continue
                                    if not latest_apk or message.date > latest_apk['message'].date:
                                        latest_apk = {
                                            "message": message,
                                            "filename": filename,
                                            "version": version
                                        }
                return latest_apk
            except Exception as e:
                log.error(f"Ëé∑ÂèñÊ∂àÊÅØÂ§±Ë¥•: {str(e)}")
                return None
        
        async def download_apk(client, message, filename):
            """‰∏ãËΩΩAPKÊñá‰ª∂Âà∞‰∏¥Êó∂ÁõÆÂΩï"""
            download_path = os.path.join(WORK_DIR, filename)
            log.info(f"‰∏ãËΩΩAPK: {filename}")
            await client.download_media(message, file=download_path)
            return download_path
        
        def get_current_versions():
            """Ëé∑ÂèñÂΩìÂâçÁâàÊú¨‰ø°ÊÅØ"""
            version_path = os.path.join(os.getcwd(), "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f)
                except:
                    return {}
            return {}
        
        async def main():
            # È™åËØÅÁéØÂ¢ÉÂèòÈáè
            required_env = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            missing = [var for var in required_env if not os.environ.get(var)]
            if missing:
                log.error(f"Áº∫Â∞ëÁéØÂ¢ÉÂèòÈáè: {', '.join(missing)}")
                return 1
            
            # ËøûÊé•Telegram
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                await client.start()
                channel_name = os.environ.get('TELEGRAM_CHANNEL', 'NagramX')
                
                # Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊµãËØïÁâàAPK
                beta_apk = await get_latest_beta_apk(client, channel_name)
                if not beta_apk:
                    log.info("Êú™ÊâæÂà∞ÊµãËØïÁâàAPK")
                    return 0
                
                log.info(f"ÊâæÂà∞ÊµãËØïÁâà: {beta_apk['filename']}, ÁâàÊú¨: {beta_apk['version']}")
                
                # ËΩ¨Êç¢Êó•Êúü‰∏∫Âåó‰∫¨Êó∂Èó¥
                utc8 = pytz.timezone('Asia/Shanghai')
                release_date = beta_apk['message'].date.astimezone(utc8)
                date_str = release_date.strftime('%Y-%m-%d')
                
                # Ê£ÄÊü•ÁõÆÊ†áË∑ØÂæÑ
                target_path = os.path.join(APK_DIR, BETA_TARGET_NAME)
                current_versions = get_current_versions()
                current_beta = current_versions.get(BETA_TARGET_NAME, "")
                current_beta_ver = current_beta.split(',')[0] if current_beta else ""
                
                # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞
                if current_beta_ver == beta_apk['version'] and os.path.exists(target_path):
                    log.info(f"ÊµãËØïÁâàÂ∑≤ÊòØÊúÄÊñ∞ÁâàÊú¨: {beta_apk['version']}")
                    return 0
                
                # ‰∏ãËΩΩAPK
                apk_path = await download_apk(client, beta_apk['message'], beta_apk['filename'])
                if not os.path.exists(apk_path):
                    log.error("‰∏ãËΩΩÂ§±Ë¥•")
                    return 1
                
                # Á°Æ‰øùÁõÆÂΩïÂ≠òÂú®Âπ∂ÁßªÂä®Êñá‰ª∂
                os.makedirs(APK_DIR, exist_ok=True)
                os.rename(apk_path, target_path)
                log.info(f"Êñá‰ª∂‰øùÂ≠òÂà∞: {target_path}")
                
                # Êõ¥Êñ∞ÁâàÊú¨Êñá‰ª∂
                current_versions[BETA_TARGET_NAME] = f"{beta_apk['version']},{date_str}"
                with open("version.txt", "w") as f:
                    json.dump(current_versions, f, indent=2)
                log.info("ÁâàÊú¨Êñá‰ª∂Â∑≤Êõ¥Êñ∞")
                return 0
                
            except Exception as e:
                log.error(f"Â§ÑÁêÜÂá∫Èîô: {str(e)}")
                return 1
            finally:
                await client.disconnect()
        
        if __name__ == "__main__":
            import asyncio
            sys.exit(asyncio.run(main()))
        EOF

    # ========== Êèê‰∫§ÂâçÂ§ÑÁêÜÊú™Êèê‰∫§ÁöÑÊõ¥Êîπ ==========
    - name: Stage changes before pull
      run: |
        # Ê∑ªÂä†ÊâÄÊúâÊõ¥ÊîπÂà∞ÊöÇÂ≠òÂå∫
        git add -A
        echo "Â∑≤ÊöÇÂ≠òÊâÄÊúâÊõ¥Êîπ"

    - name: Reset uncommitted changes
      run: |
        # ÈáçÁΩÆÊâÄÊúâÊú™Êèê‰∫§ÁöÑÊõ¥ÊîπÔºà‰øùÁïôÂ∑•‰ΩúÂå∫Ôºâ
        git reset --soft HEAD
        echo "Â∑≤ÈáçÁΩÆÊöÇÂ≠òÂå∫Êõ¥Êîπ"

    - name: Pull latest changes before commit
      run: |
        echo "ÊãâÂèñËøúÁ®ãÊúÄÊñ∞Êõ¥Êîπ..."
        git pull --rebase origin main
        echo "Â∑≤ÂêåÊ≠•ËøúÁ®ãÊúÄÊñ∞Êõ¥Êîπ"

    - name: Restore changes after pull
      run: |
        # ÊÅ¢Â§çÂ∑•‰ΩúÂå∫Êõ¥Êîπ
        git checkout -- .
        echo "Â∑≤ÊÅ¢Â§çÂ∑•‰ΩúÂå∫Êõ¥Êîπ"
        
        # ÈáçÊñ∞Ê∑ªÂä†ÈúÄË¶ÅÊèê‰∫§ÁöÑÊñá‰ª∂
        git add apk/ version.txt
        echo "ÈáçÊñ∞Ê∑ªÂä†APKÂíåÁâàÊú¨Êñá‰ª∂"

    - name: Commit and Push Changes
      run: |
        # Ê£ÄÊü•ÊòØÂê¶ÊúâÊñá‰ª∂ÂèòÊõ¥
        if git diff-index --quiet HEAD --; then
          echo "Ê≤°ÊúâÈúÄË¶ÅÊèê‰∫§ÁöÑÊõ¥Êîπ"
          exit 0
        fi

        # Ê∑ªÂä†ÂèòÊõ¥Âπ∂Êèê‰∫§
        git add apk/ version.txt
        git commit -m "ÂêåÊ≠•NagramXÊõ¥Êñ∞ [${{ github.run_id }}]"
        
        # ÂÆâÂÖ®Âº∫Âà∂Êé®ÈÄÅÔºà‰ªÖÂú®ËøúÁ®ãÊ≤°ÊúâÊñ∞Êèê‰∫§Êó∂Ë¶ÜÁõñÔºâ
        echo "Êé®ÈÄÅÊõ¥Êîπ..."
        git push --force-with-lease origin HEAD:${{ github.ref }}
        echo "Êé®ÈÄÅÊàêÂäü"
        
    # Ê∑ªÂä†Ëß£ÈîÅÊ≠•È™§ - Á°Æ‰øùÊó†ËÆ∫ÊàêÂäüÂ§±Ë¥•ÈÉΩÈáäÊîæÈîÅ
    - name: Release Repository Lock üîì
      if: always()  # Êó†ËÆ∫ÂâçÈù¢Ê≠•È™§ÊàêÂäü‰∏éÂê¶ÈÉΩÊâßË°å
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true  # Âç≥‰ΩøËß£ÈîÅÂ§±Ë¥•‰πü‰∏ç‰∏≠Êñ≠Â∑•‰ΩúÊµÅ
        action: unlock  # ÊåáÂÆöËß£ÈîÅÊìç‰Ωú
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Ê∏ÖÁêÜÊóßÁöÑÂ∑•‰ΩúÊµÅËøêË°åËÆ∞ÂΩï
  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "NagramX Sync from Source Repository"
          repository: ${{ github.repository }}