name: NagramX Sync from Source Repository

on:
  schedule:
    - cron: '0 */24 * * *'  # æ¯24å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout current repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
        ref: main  # æ˜ç¡®æŒ‡å®šåˆ†æ”¯

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl
        
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git config pull.rebase true  # é…ç½®rebaseç­–ç•¥
        # æå‰è®¾ç½®å¸¦è®¤è¯çš„è¿œç¨‹URL
        git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
        
    # åœ¨å¼€å§‹åŒæ­¥å‰è·å–ä»“åº“é”
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20åˆ†é’Ÿè¶…æ—¶

    - name: Run sync script
      env:
        SOURCE_REPO: "risin42/NagramX"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}  # ä½¿ç”¨è®¤è¯ä»¤ç‰Œ
        APK_PATTERN: "arm64-v8a.apk"
        STABLE_TARGET_NAME: "nagramx.apk"  # ä¿®æ­£ä¸ºæ›´å‡†ç¡®çš„å˜é‡å
      run: |
        # ç›®æ ‡æ–‡ä»¶è·¯å¾„
        STABLE_TARGET_PATH="apk/$STABLE_TARGET_NAME"
        
        # åˆ›å»ºä¸´æ—¶å·¥ä½œç›®å½•
        WORK_DIR=$(mktemp -d)
        echo "åˆ›å»ºä¸´æ—¶ç›®å½•: $WORK_DIR"
        trap 'rm -rf "$WORK_DIR"; echo "æ¸…ç†ä¸´æ—¶ç›®å½•..."' EXIT

        # è·å–æ‰€æœ‰å‘å¸ƒç‰ˆï¼ˆä½¿ç”¨è®¤è¯ä»¤ç‰Œï¼‰
        echo "è·å–ç¨³å®šç‰ˆæœ¬ä¿¡æ¯..."
        RELEASES_JSON=$(curl -sL -H "Authorization: Bearer $TOKEN" "https://api.github.com/repos/$SOURCE_REPO/releases")
        if [ $? -ne 0 ]; then
          echo "é”™è¯¯: æ— æ³•è·å–å‘å¸ƒä¿¡æ¯"
          exit 1
        fi

        # æå–æœ€æ–°ç¨³å®šç‰ˆï¼ˆè¿‡æ»¤æ‰é¢„å‘å¸ƒç‰ˆï¼‰
        LATEST_STABLE_RELEASE=$(echo "$RELEASES_JSON" | jq -r 'map(select(.prerelease == false)) | sort_by(.published_at) | reverse | .[0]')
        if [ -z "$LATEST_STABLE_RELEASE" ] || [ "$LATEST_STABLE_RELEASE" = "null" ]; then
          echo "é”™è¯¯: æœªæ‰¾åˆ°ç¨³å®šç‰ˆæœ¬"
          exit 1
        fi
        
        # æå–å‘å¸ƒæ—¥æœŸå¹¶è½¬æ¢ä¸ºåŒ—äº¬æ—¶é—´ (YYYY-MM-DD)
        STABLE_PUBLISHED_AT=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.published_at')
        RELEASE_DATE=$(TZ=UTC date -d "$STABLE_PUBLISHED_AT" +'%Y-%m-%d')
        
        # ä»å‘å¸ƒæ ‡é¢˜ä¸­æå–å®Œæ•´ç‰ˆæœ¬å·å¹¶æ·»åŠ  'v' å‰ç¼€
        RAW_VERSION=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.name' | grep -oP '(\d+\.)+\d+' | head -1)
        if [ -z "$RAW_VERSION" ]; then
          # å¦‚æœæ— æ³•ä»æ ‡é¢˜æå–ï¼Œåˆ™ä½¿ç”¨æ ‡ç­¾åä½œä¸ºå¤‡é€‰
          RAW_VERSION=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.tag_name')
        fi
        
        # ç¡®ä¿ç‰ˆæœ¬å·ä»¥ 'v' å¼€å¤´
        if [[ ! "$RAW_VERSION" =~ ^v ]]; then
          STABLE_VERSION="v$RAW_VERSION"
        else
          STABLE_VERSION="$RAW_VERSION"
        fi
        
        echo "æºä»“åº“æœ€æ–°ç¨³å®šç‰ˆ: $STABLE_VERSION (å‘å¸ƒäº: $RELEASE_DATE)"

        # æ£€æŸ¥æœ¬åœ°ç‰ˆæœ¬æ–‡ä»¶
        if [ ! -f "version.txt" ]; then
          echo "{}" > version.txt
        fi
        
        # è¯»å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
        CURRENT_VERSION_JSON=$(cat version.txt)
        
        # è§£æå½“å‰ç¨³å®šç‰ˆå’Œæ—¥æœŸ
        CURRENT_STABLE_FULL=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$STABLE_TARGET_NAME\"")
        
        # åˆ†ç¦»ç‰ˆæœ¬å’Œæ—¥æœŸ
        CURRENT_STABLE_VERSION=""
        CURRENT_STABLE_DATE=""
        if [ "$CURRENT_STABLE_FULL" != "null" ] && [[ "$CURRENT_STABLE_FULL" == *,* ]]; then
          CURRENT_STABLE_VERSION=$(echo "$CURRENT_STABLE_FULL" | cut -d, -f1)
          CURRENT_STABLE_DATE=$(echo "$CURRENT_STABLE_FULL" | cut -d, -f2)
        fi
        
        echo "å½“å‰ç¨³å®šç‰ˆ: ${CURRENT_STABLE_VERSION:-æ— } (æ—¥æœŸ: ${CURRENT_STABLE_DATE:-æ— })"

        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
        need_update=false
        
        # æ£€æŸ¥ç¨³å®šç‰ˆç‰ˆæœ¬å’Œæ–‡ä»¶
        if [ "$STABLE_VERSION" != "$CURRENT_STABLE_VERSION" ] || [ ! -f "$STABLE_TARGET_PATH" ]; then
          echo "ç¨³å®šç‰ˆéœ€è¦æ›´æ–°: ç‰ˆæœ¬ä¸åŒ¹é…æˆ–æ–‡ä»¶ä¸å­˜åœ¨"
          need_update=true
        fi
        
        if [ "$need_update" = false ]; then
          echo "ç‰ˆæœ¬ç›¸åŒä¸”æ–‡ä»¶å­˜åœ¨ï¼Œæ— éœ€æ›´æ–°"
          # ç»§ç»­æ‰§è¡Œåç»­æ­¥éª¤ï¼ˆæµ‹è¯•ç‰ˆåŒæ­¥ï¼‰
        else
          # ä¸‹è½½æ–°ç‰ˆæœ¬æ–‡ä»¶
          echo "ä¸‹è½½æ–°ç‰ˆæœ¬æ–‡ä»¶..."
          
          # æŸ¥æ‰¾ç¨³å®šç‰ˆAPKæ–‡ä»¶
          apk_download_url=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.assets[] | select(.name | contains("'$APK_PATTERN'")) | .browser_download_url' | head -1)
          if [ -z "$apk_download_url" ]; then
            echo "é”™è¯¯: æœªæ‰¾åˆ°åŒ¹é…çš„ç¨³å®šç‰ˆAPKæ–‡ä»¶"
            exit 1
          fi
          
          # ç¡®ä¿apkç›®å½•å­˜åœ¨
          mkdir -p apk
          
          # ä¸‹è½½ç¨³å®šç‰ˆAPK
          apk_source_name=$(basename "$apk_download_url")
          echo "ä¸‹è½½ç¨³å®šç‰ˆAPK: $apk_source_name"
          curl -sL "$apk_download_url" -o "$WORK_DIR/$apk_source_name"
          if [ ! -f "$WORK_DIR/$apk_source_name" ]; then
            echo "é”™è¯¯: ç¨³å®šç‰ˆAPKä¸‹è½½å¤±è´¥"
            exit 1
          fi
          
          # é‡å‘½åå¹¶ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
          mv "$WORK_DIR/$apk_source_name" "$STABLE_TARGET_PATH"
          echo "æ–‡ä»¶å·²ä¿å­˜åˆ°: $STABLE_TARGET_PATH"

          # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶ï¼ˆä¿ç•™å…¶ä»–é”®å€¼ï¼Œæ·»åŠ æ—¥æœŸï¼‰
          UPDATED_VERSION_JSON=$(echo "$CURRENT_VERSION_JSON" | jq \
            --arg stable_key "$STABLE_TARGET_NAME" \
            --arg stable_value "$STABLE_VERSION,$RELEASE_DATE" \
            '.[$stable_key] = $stable_value')
            
          echo "$UPDATED_VERSION_JSON" > version.txt
        fi

    - name: Set up Python for Beta Sync
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install Python dependencies for Beta Sync
      run: |
        pip install telethon pytz

    - name: Sync Beta from Telegram
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "NagramX"
        BETA_TARGET_NAME: "nagramx-beta.apk"
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import re
        import time
        import logging
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        BETA_TARGET_NAME = os.environ.get("BETA_TARGET_NAME", "nagramx-beta.apk")
        APK_DIR = "apk"
        WORK_DIR = os.path.join(os.getcwd(), "temp_beta_apk")
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def parse_beta_version(filename):
            """ä»æ–‡ä»¶åè§£ææµ‹è¯•ç‰ˆç‰ˆæœ¬å·ï¼ˆåªæå–ä¸»ç‰ˆæœ¬å·ï¼‰"""
            # åŒ¹é…æ¨¡å¼ï¼šNagramX-vX.X.X
            pattern = r'NagramX-v(\d+\.\d+\.\d+)'
            match = re.search(pattern, filename)
            if match:
                return f"v{match.group(1)}"
            return None
        
        async def get_latest_beta_apk(client, channel_name):
            """è·å–æœ€æ–°çš„æµ‹è¯•ç‰ˆAPKæ–‡ä»¶"""
            try:
                log.info(f"è¿æ¥Telegramé¢‘é“: {channel_name}")
                entity = await client.get_entity(channel_name)
                
                latest_apk = None
                
                # è·å–æœ€æ–°çš„20æ¡æ¶ˆæ¯
                async for message in client.iter_messages(entity, limit=20):
                    if message.media and hasattr(message.media, "document"):
                        for attr in message.media.document.attributes:
                            if isinstance(attr, DocumentAttributeFilename):
                                filename = attr.file_name
                                if filename.endswith("-arm64-v8a.apk") and "NagramX-v" in filename:
                                    version = parse_beta_version(filename)
                                    if not version:
                                        continue
                                    if not latest_apk or message.date > latest_apk['message'].date:
                                        latest_apk = {
                                            "message": message,
                                            "filename": filename,
                                            "version": version
                                        }
                return latest_apk
            except Exception as e:
                log.error(f"è·å–æ¶ˆæ¯å¤±è´¥: {str(e)}")
                return None
        
        async def download_apk(client, message, filename):
            """ä¸‹è½½APKæ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•"""
            download_path = os.path.join(WORK_DIR, filename)
            log.info(f"ä¸‹è½½APK: {filename}")
            await client.download_media(message, file=download_path)
            return download_path
        
        def get_current_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯"""
            version_path = os.path.join(os.getcwd(), "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f)
                except:
                    return {}
            return {}
        
        async def main():
            # éªŒè¯ç¯å¢ƒå˜é‡
            required_env = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            missing = [var for var in required_env if not os.environ.get(var)]
            if missing:
                log.error(f"ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            # è¿æ¥Telegram
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                await client.start()
                channel_name = os.environ.get('TELEGRAM_CHANNEL', 'NagramX')
                
                # è·å–æœ€æ–°çš„æµ‹è¯•ç‰ˆAPK
                beta_apk = await get_latest_beta_apk(client, channel_name)
                if not beta_apk:
                    log.info("æœªæ‰¾åˆ°æµ‹è¯•ç‰ˆAPK")
                    return 0
                
                log.info(f"æ‰¾åˆ°æµ‹è¯•ç‰ˆ: {beta_apk['filename']}, ç‰ˆæœ¬: {beta_apk['version']}")
                
                # è½¬æ¢æ—¥æœŸä¸ºåŒ—äº¬æ—¶é—´
                utc8 = pytz.timezone('Asia/Shanghai')
                release_date = beta_apk['message'].date.astimezone(utc8)
                date_str = release_date.strftime('%Y-%m-%d')
                
                # æ£€æŸ¥ç›®æ ‡è·¯å¾„
                target_path = os.path.join(APK_DIR, BETA_TARGET_NAME)
                current_versions = get_current_versions()
                current_beta = current_versions.get(BETA_TARGET_NAME, "")
                current_beta_ver = current_beta.split(',')[0] if current_beta else ""
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                if current_beta_ver == beta_apk['version'] and os.path.exists(target_path):
                    log.info(f"æµ‹è¯•ç‰ˆå·²æ˜¯æœ€æ–°ç‰ˆæœ¬: {beta_apk['version']}")
                    return 0
                
                # ä¸‹è½½APK
                apk_path = await download_apk(client, beta_apk['message'], beta_apk['filename'])
                if not os.path.exists(apk_path):
                    log.error("ä¸‹è½½å¤±è´¥")
                    return 1
                
                # ç¡®ä¿ç›®å½•å­˜åœ¨å¹¶ç§»åŠ¨æ–‡ä»¶
                os.makedirs(APK_DIR, exist_ok=True)
                os.rename(apk_path, target_path)
                log.info(f"æ–‡ä»¶ä¿å­˜åˆ°: {target_path}")
                
                # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                current_versions[BETA_TARGET_NAME] = f"{beta_apk['version']},{date_str}"
                with open("version.txt", "w") as f:
                    json.dump(current_versions, f, indent=2)
                log.info("ç‰ˆæœ¬æ–‡ä»¶å·²æ›´æ–°")
                return 0
                
            except Exception as e:
                log.error(f"å¤„ç†å‡ºé”™: {str(e)}")
                return 1
            finally:
                await client.disconnect()
        
        if __name__ == "__main__":
            import asyncio
            sys.exit(asyncio.run(main()))
        EOF

    # ========== æäº¤å‰å¤„ç†æœªæäº¤çš„æ›´æ”¹ ==========
    - name: Stage changes before pull
      run: |
        # æ·»åŠ æ‰€æœ‰æ›´æ”¹åˆ°æš‚å­˜åŒº
        git add -A
        echo "å·²æš‚å­˜æ‰€æœ‰æ›´æ”¹"

    - name: Reset uncommitted changes
      run: |
        # é‡ç½®æ‰€æœ‰æœªæäº¤çš„æ›´æ”¹ï¼ˆä¿ç•™å·¥ä½œåŒºï¼‰
        git reset --soft HEAD
        echo "å·²é‡ç½®æš‚å­˜åŒºæ›´æ”¹"

    - name: Pull latest changes before commit
      run: |
        echo "æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹..."
        git pull --rebase origin main
        echo "å·²åŒæ­¥è¿œç¨‹æœ€æ–°æ›´æ”¹"

    - name: Restore changes after pull
      run: |
        # æ¢å¤å·¥ä½œåŒºæ›´æ”¹
        git checkout -- .
        echo "å·²æ¢å¤å·¥ä½œåŒºæ›´æ”¹"
        
        # é‡æ–°æ·»åŠ éœ€è¦æäº¤çš„æ–‡ä»¶
        git add apk/ version.txt
        echo "é‡æ–°æ·»åŠ APKå’Œç‰ˆæœ¬æ–‡ä»¶"

    - name: Commit and Push Changes
      run: |
        # æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶å˜æ›´
        if git diff-index --quiet HEAD --; then
          echo "æ²¡æœ‰éœ€è¦æäº¤çš„æ›´æ”¹"
          exit 0
        fi

        # æ·»åŠ å˜æ›´å¹¶æäº¤
        git add apk/ version.txt
        git commit -m "åŒæ­¥NagramXæ›´æ–° [${{ github.run_id }}]"
        
        # å®‰å…¨å¼ºåˆ¶æ¨é€ï¼ˆä»…åœ¨è¿œç¨‹æ²¡æœ‰æ–°æäº¤æ—¶è¦†ç›–ï¼‰
        echo "æ¨é€æ›´æ”¹..."
        git push --force-with-lease origin HEAD:${{ github.ref }}
        echo "æ¨é€æˆåŠŸ"
        
    # æ·»åŠ è§£é”æ­¥éª¤ - ç¡®ä¿æ— è®ºæˆåŠŸå¤±è´¥éƒ½é‡Šæ”¾é”
    - name: Release Repository Lock ğŸ”“
      if: always()  # æ— è®ºå‰é¢æ­¥éª¤æˆåŠŸä¸å¦éƒ½æ‰§è¡Œ
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true  # å³ä½¿è§£é”å¤±è´¥ä¹Ÿä¸ä¸­æ–­å·¥ä½œæµ
        action: unlock  # æŒ‡å®šè§£é”æ“ä½œ
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # æ¸…ç†æ—§çš„å·¥ä½œæµè¿è¡Œè®°å½•
  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "NagramX Sync from Source Repository"
          repository: ${{ github.repository }}