name: OK APK Sync from TELEGRAM

on:
  schedule:
    - cron: '0 */3 * * *'  # 每3小时运行一次
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: pip install telethon tqdm requests

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL || 'tvb_ys' }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        from datetime import datetime
        from telethon import TelegramClient, events
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        from tqdm import tqdm

        # 配置参数
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        
        # 环境变量
        WORK_DIR = os.path.join(os.getcwd(), "temp_apks")
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        def log(message):
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {message}")
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "pull", "origin", "main"], cwd=GIT_DIR, check=True)
                log("Git配置完成")
                return True
            except Exception as e:
                log(f"Git设置失败: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # 只添加apk目录和版本文件
                subprocess.run(["git", "add", APK_DIR, "version.txt"], cwd=GIT_DIR, check=True)
                
                # 检查是否有更改
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log("没有更改需要提交")
                    return True
                
                # 提交并推送
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                result = subprocess.run(
                    ["git", "push", repo_url, "HEAD:main"],
                    cwd=GIT_DIR,
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    log("推送成功")
                    return True
                else:
                    log(f"推送失败: {result.stderr.strip()}")
                    return False
            except Exception as e:
                log(f"Git操作失败: {str(e)}")
                return False
        
        def get_current_versions():
            version_path = os.path.join(GIT_DIR, "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f)
                except:
                    log("版本文件格式错误，重新初始化")
            return {}
        
        def update_versions(versions):
            version_path = os.path.join(GIT_DIR, "version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        async def download_apk(client, message, filename):
            date_str = message.date.strftime("%Y%m%d")
            version = f"{filename.split('.')[0]}-{date_str}"
            download_path = os.path.join(WORK_DIR, filename)
            
            # 使用tqdm实现单行进度条
            with tqdm(
                total=message.document.size,
                unit='B',
                unit_scale=True,
                desc=f"下载 {filename}",
                bar_format='{l_bar}{bar}| {n_fmt}/{total_fmt}',
                ascii=True,
                ncols=80
            ) as pbar:
                last = 0
                def callback(current, total):
                    nonlocal last
                    pbar.update(current - last)
                    last = current
                
                await client.download_media(message, file=download_path, progress_callback=callback)
            
            return {"path": download_path, "version": version}
        
        async def find_new_apks(client):
            log("连接Telegram...")
            await client.connect()
            if not await client.is_user_authorized():
                log("错误: Telegram会话无效")
                return None
            
            channel = os.environ.get('TELEGRAM_CHANNEL', 'tvb_ys')
            log(f"扫描频道: {channel}")
            entity = await client.get_entity(channel)
            
            latest_msgs = {}
            async for msg in client.iter_messages(entity, limit=50):
                if msg.media and hasattr(msg.media, "document"):
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            if filename in APK_FILES:
                                if filename not in latest_msgs or msg.id > latest_msgs[filename].id:
                                    latest_msgs[filename] = msg
            
            current_versions = get_current_versions()
            updates = {}
            
            for filename, msg in latest_msgs.items():
                date_str = msg.date.strftime("%Y%m%d")
                version = f"{filename.split('.')[0]}-{date_str}"
                current = current_versions.get(filename, "")
                
                if version != current:
                    log(f"发现新版本: {filename} ({current} → {version})")
                    apk_data = await download_apk(client, msg, filename)
                    if apk_data:
                        updates[filename] = apk_data
                else:
                    log(f"{filename} 已是最新版本: {current}")
            
            return updates if updates else None
        
        def main():
            log("="*50)
            log("APK 同步工具启动")
            log("="*50)
            
            # 验证环境变量
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log(f"错误: 缺少环境变量: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                with client:
                    new_apks = client.loop.run_until_complete(find_new_apks(client))
            except Exception as e:
                log(f"Telegram错误: {str(e)}")
                return 3
            
            if not new_apks:
                log("没有需要更新的APK文件")
                return 0
            
            # 处理新文件
            current_versions = get_current_versions()
            updated = {}
            target_dir = os.path.join(GIT_DIR, APK_DIR)
            os.makedirs(target_dir, exist_ok=True)
            
            for filename, data in new_apks.items():
                target_path = os.path.join(target_dir, filename)
                shutil.copy2(data["path"], target_path)
                current_versions[filename] = data["version"]
                updated[filename] = data["version"]
                log(f"已更新: {filename} (版本: {data['version']})")
            
            # 更新版本文件
            update_versions(current_versions)
            
            # 提交更改
            commit_msg = f"更新APK: {', '.join([f'{k}={v}' for k, v in updated.items()])}"
            if commit_and_push(commit_msg):
                log(f"同步成功! 更新了 {len(updated)} 个文件")
            else:
                log("提交失败")
                return 4
            
            # 清理临时目录
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log("临时目录已清理")
            
            log("="*50)
            log("同步任务完成")
            log("="*50)
            return 0
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Cleanup
      run: echo "APK同步任务完成"

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK APK Sync from TELEGRAM"
          repository: ${{ github.repository }}