name: TV NEW APK Sync from TELEGRAM

# ä½¿ç”¨åŸç”Ÿå¹¶å‘æ§åˆ¶ï¼ˆé€šè¿‡concurrencyé…ç½®å®ç°ï¼‰
concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */24 * * *'  # æ¯24å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    # åŸºäºç¼“å­˜çš„é”æœºåˆ¶ï¼ˆé€šè¿‡turnstyleå®ç°ï¼‰
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20åˆ†é’Ÿè¶…æ—¶
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
        pip install telethon pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•° - åªä¿ç•™tv-new.apk
        APK_TARGETS = {
            "tv-new.apk": "all-sdk21-original"
        }
        APK_DIR = "apk"
        TELEGRAM_CHANNEL = "YYKM_release"  # ç¡¬ç¼–ç é¢‘é“åç§°
        MESSAGE_LIMIT = 50  # æ‰«æçš„æœ€è¿‘æ¶ˆæ¯æ•°é‡
        VERSION_FILE = "version.txt"
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = os.path.join(os.getcwd(), "temp_apks")
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def setup_git():
            """é…ç½®Gitç¯å¢ƒå¹¶åŒæ­¥æœ€æ–°ä»£ç """
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹ï¼ˆé˜²æ­¢å†²çªï¼‰
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            """æäº¤å¹¶æ¨é€æ›´æ”¹ï¼ˆä½¿ç”¨æ ‡å‡†Gitæµç¨‹ï¼‰"""
            try:
                # ä»…æ·»åŠ apkç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain", "--", APK_DIR, VERSION_FILE], 
                                      cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # é‡è¯•æœºåˆ¶ï¼ˆæœ€å¤š3æ¬¡ï¼‰
                for attempt in range(1, 4):
                    try:
                        # åŒæ­¥è¿œç¨‹æ›´æ”¹
                        subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                        # æ¨é€æ›´æ”¹
                        subprocess.run(["git", "push", repo_url, "HEAD:main"], cwd=GIT_DIR, check=True)
                        log.info("æ¨é€æˆåŠŸ")
                        return True
                    except Exception as e:
                        log.warning(f"æ¨é€å¤±è´¥ (å°è¯• {attempt}/3): {str(e)}")
                        if attempt < 3:
                            time.sleep(10)
                            # é‡ç½®åˆ°è¿œç¨‹çŠ¶æ€
                            subprocess.run(["git", "reset", "--hard", "origin/main"], cwd=GIT_DIR, check=True)
                        else:
                            log.error("æ‰€æœ‰æ¨é€å°è¯•å‡å¤±è´¥")
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
            return False
        
        def get_current_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œä¿ç•™æ‰€æœ‰ç°æœ‰é”®å€¼"""
            version_path = os.path.join(GIT_DIR, VERSION_FILE)
            versions = {}
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        versions = json.load(f)
                except:
                    # å¦‚æœè§£æå¤±è´¥ï¼Œåˆ›å»ºæ–°çš„ç©ºå­—å…¸
                    pass
            return versions
        
        def update_versions(new_versions):
            """æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶ï¼Œåªä¿®æ”¹éœ€è¦æ›´æ–°çš„é”®å€¼"""
            version_path = os.path.join(GIT_DIR, VERSION_FILE)
            
            # è¯»å–ç°æœ‰ç‰ˆæœ¬ä¿¡æ¯
            current_versions = get_current_versions()
            
            # åˆå¹¶æ›´æ–°
            for key, value in new_versions.items():
                current_versions[key] = value
            
            # å†™å…¥æ›´æ–°åçš„ç‰ˆæœ¬ä¿¡æ¯
            with open(version_path, "w") as f:
                json.dump(current_versions, f, indent=2)
            log.info(f"ç‰ˆæœ¬æ–‡ä»¶å·²æ›´æ–°: {json.dumps(new_versions, indent=2)}")
        
        def extract_version_from_filename(filename):
            """ä»æ–‡ä»¶åæå–ç‰ˆæœ¬å·"""
            if not filename:
                return None
            match = re.search(r'v?(\d+\.\d+\.\d+)|v?(\d+\.\d+)|(\d{8})', filename)
            if match:
                return match.group(1) or match.group(2) or match.group(3)
            return None
        
        def should_download_apk(target_name, msg_date, new_version, current_versions):
            """åˆ¤æ–­æ˜¯å¦éœ€è¦ä¸‹è½½APK"""
            # å¦‚æœæœ¬åœ°æ²¡æœ‰è¯¥APKçš„è®°å½•ï¼Œéœ€è¦ä¸‹è½½
            if target_name not in current_versions or not current_versions[target_name]:
                log.info(f"{target_name} åœ¨ç‰ˆæœ¬æ–‡ä»¶ä¸­æ— è®°å½•ï¼Œéœ€è¦ä¸‹è½½")
                return True
            
            # è§£æå½“å‰ç‰ˆæœ¬ä¿¡æ¯
            current_value = current_versions[target_name]
            if current_value and ',' in current_value:
                try:
                    current_version, current_date = current_value.split(',', 1)
                except:
                    log.warning(f"ç‰ˆæœ¬æ ¼å¼é”™è¯¯: {current_value}")
                    return True
            else:
                log.warning(f"æ— æ•ˆç‰ˆæœ¬æ ¼å¼: {current_value}")
                return True
            
            # å°†æ¶ˆæ¯æ—¥æœŸè½¬æ¢ä¸ºæ—¥æœŸå­—ç¬¦ä¸²ï¼ˆYYYY-MM-DDï¼‰
            msg_date_str = msg_date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
            
            # å¦‚æœæ¶ˆæ¯æ—¥æœŸæ¯”è®°å½•æ—¥æœŸæ–°ï¼Œéœ€è¦ä¸‹è½½
            if msg_date_str > current_date:
                log.info(f"{target_name} æœ‰æ–°æ—¥æœŸ: {msg_date_str} > {current_date}")
                return True
            
            # æ—¥æœŸç›¸åŒçš„æƒ…å†µï¼Œæ¯”è¾ƒç‰ˆæœ¬å·
            if msg_date_str == current_date and new_version and current_version:
                if new_version != current_version:
                    log.info(f"{target_name} æœ‰æ–°ç‰ˆæœ¬: {new_version} != {current_version}")
                    return True
            
            log.info(f"{target_name} æ— éœ€æ›´æ–°: ç‰ˆæœ¬ {new_version or 'N/A'} <= {current_version}, æ—¥æœŸ {msg_date_str} <= {current_date}")
            return False
        
        async def find_apks_in_channel(client, entity):
            """åœ¨é¢‘é“ä¸­æŸ¥æ‰¾åŒ¹é…çš„APKæ–‡ä»¶"""
            apk_matches = {}
            
            # æ‰«ææœ€è¿‘çš„æ¶ˆæ¯
            async for msg in client.iter_messages(entity, limit=MESSAGE_LIMIT):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                # æ£€æŸ¥æ–‡ä»¶åå±æ€§
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                    
                    filename = attr.file_name
                    # åªæ£€æŸ¥tv-new.apk
                    if "all-sdk21-original" in filename.lower():
                        version = extract_version_from_filename(filename)
                        if not version:
                            continue
                        
                        # åªä¿ç•™æœ€æ–°çš„æ¶ˆæ¯
                        if "tv-new.apk" not in apk_matches or msg.date > apk_matches["tv-new.apk"]["message"].date:
                            apk_matches["tv-new.apk"] = {
                                "message": msg,
                                "original_filename": filename,
                                "version": version
                            }
                        break
            return apk_matches
        
        async def download_apk(client, message, target_name, filename):
            """ä¸‹è½½APKæ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•"""
            download_path = os.path.join(WORK_DIR, target_name)
            log.info(f"å¼€å§‹ä¸‹è½½: {filename}")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            size_mb = os.path.getsize(download_path) / (1024 * 1024)
            log.info(f"ä¸‹è½½å®Œæˆ: {size_mb:.1f}MB, è€—æ—¶{elapsed:.1f}ç§’")
            
            return download_path
        
        async def process_apk_updates(client, entity, current_versions):
            """å¤„ç†APKæ›´æ–°"""
            # åœ¨é¢‘é“ä¸­æŸ¥æ‰¾APKæ–‡ä»¶
            apk_matches = await find_apks_in_channel(client, entity)
            if not apk_matches:
                log.info("æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„APKæ¶ˆæ¯")
                return None
            
            updates = {}
            apk_files = {}
            
            # å¤„ç†æ¯ä¸ªåŒ¹é…çš„æ–‡ä»¶
            for target_name, data in apk_matches.items():
                msg = data["message"]
                filename = data["original_filename"]
                version = data["version"]
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸‹è½½
                if should_download_apk(target_name, msg.date, version, current_versions):
                    apk_path = await download_apk(client, msg, target_name, filename)
                    if apk_path and os.path.exists(apk_path):
                        # è·å–æ¶ˆæ¯æ—¥æœŸ
                        msg_date_str = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                        new_value = f"{version},{msg_date_str}"
                        updates[target_name] = new_value
                        apk_files[target_name] = apk_path
            
            return updates, apk_files
        
        def move_apk_to_target(apk_files):
            """å°†APKæ–‡ä»¶ç§»åŠ¨åˆ°ç›®æ ‡ç›®å½•"""
            target_dir = os.path.join(GIT_DIR, APK_DIR)
            os.makedirs(target_dir, exist_ok=True)
            
            for target_name, src_path in apk_files.items():
                dst_path = os.path.join(target_dir, target_name)
                
                # åˆ é™¤æ—§æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if os.path.exists(dst_path):
                    os.remove(dst_path)
                    log.info(f"å·²åˆ é™¤æ—§æ–‡ä»¶: {target_name}")
                
                # ç§»åŠ¨æ–°æ–‡ä»¶
                shutil.move(src_path, dst_path)
                log.info(f"å·²ç§»åŠ¨ {os.path.basename(src_path)} åˆ° {dst_path}")
        
        async def main_async():
            log.info("="*50 + "\nAPK åŒæ­¥å·¥å…·å¯åŠ¨\n" + "="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log.error(f"é”™è¯¯: ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            # è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
            current_versions = get_current_versions()
            log.info(f"å½“å‰ç‰ˆæœ¬ä¿¡æ¯: {json.dumps(current_versions, indent=2)}")
            
            # åˆå§‹åŒ–Telegramå®¢æˆ·ç«¯
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                await client.start()
                log.info(f"è¿æ¥Telegramé¢‘é“: {TELEGRAM_CHANNEL}")
                
                try:
                    entity = await client.get_entity(TELEGRAM_CHANNEL)
                except Exception as e:
                    log.error(f"è·å–é¢‘é“å®ä½“å¤±è´¥: {str(e)}")
                    return 3
                
                # å¤„ç†APKæ›´æ–°
                version_updates, apk_files = await process_apk_updates(client, entity, current_versions)
            except Exception as e:
                log.error(f"Telegramé”™è¯¯: {str(e)}")
                return 4
            finally:
                await client.disconnect()
            
            if version_updates and apk_files:
                # ç§»åŠ¨APKæ–‡ä»¶åˆ°ç›®æ ‡ç›®å½•
                move_apk_to_target(apk_files)
                
                # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                update_versions(version_updates)
                
                # æäº¤æ›´æ”¹
                commit_msg = f"æ›´æ–°APK: {', '.join(version_updates.keys())}"
                if commit_and_push(commit_msg):
                    log.info(f"åŒæ­¥æˆåŠŸ! æ›´æ–°äº† {len(version_updates)} ä¸ªæ–‡ä»¶")
                else:
                    log.error("æäº¤å¤±è´¥")
                    return 5
            else:
                log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log.info("ä¸´æ—¶ç›®å½•å·²æ¸…ç†")
            
            log.info("="*50 + "\nåŒæ­¥ä»»åŠ¡å®Œæˆ\n" + "="*50)
            return 0
        
        def main():
            import asyncio
            return asyncio.run(main_async())
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    # é‡Šæ”¾åŸºäºç¼“å­˜çš„é”
    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          const message = `ğŸš¨ Telegram APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          })

  # å·¥ä½œæµå†å²æ¸…ç†
  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "TV NEW APK Sync from TELEGRAM"
          repository: ${{ github.repository }}