name: TV NEW APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */24 * * *'  # 每24小时运行一次
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon pytz

    - name: Run Optimized APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # 配置参数
        APK_TARGETS = {
            "tv-new.apk": "all-sdk21-original",
            "tv-new-x5.apk": "armeabi-v7a-sdk21-X5"
        }
        APK_DIR = "apk"
        TELEGRAM_CHANNEL = "YYKM_release"
        MESSAGE_LIMIT = 15
        VERSION_FILE = "version.txt"
        
        # 环境变量
        WORK_DIR = "temp_apks"
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # 配置日志
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def git_setup():
            """配置Git环境"""
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = f"{actor}@users.noreply.github.com"
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # 拉取最新更改
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                log.info("Git配置完成")
                return True
            except Exception as e:
                log.error(f"Git设置失败: {str(e)}")
                return False
        
        def git_commit_push(message):
            """提交并推送更改"""
            try:
                # 添加更改
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], cwd=GIT_DIR, check=True)
                
                # 检查是否有更改
                status = subprocess.run(["git", "status", "--porcelain"], 
                                       cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("没有更改需要提交")
                    return True
                
                # 提交
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                # 使用标准Git推送
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "main"], cwd=GIT_DIR, check=True)
                log.info("推送成功")
                return True
            except Exception as e:
                log.error(f"Git操作失败: {str(e)}")
                return False
        
        def get_versions():
            """获取当前版本信息"""
            version_path = os.path.join(GIT_DIR, VERSION_FILE)
            if not os.path.exists(version_path):
                return {}
                
            try:
                with open(version_path, "r") as f:
                    return json.load(f)
            except json.JSONDecodeError:
                log.error("版本文件格式错误，重置为空白")
                return {}
        
        def update_versions(new_versions):
            """更新版本文件并显示变更"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(os.path.join(GIT_DIR, VERSION_FILE), "w") as f:
                json.dump(versions, f, indent=2)
                
            # 仅显示关心的键值版本信息
            for key, value in new_versions.items():
                log.info(f"版本更新: {key} => {value}")
        
        def extract_version(filename):
            """从文件名提取版本号"""
            match = re.search(r'v?(\d+\.\d+\.\d+)|v?(\d+\.\d+)|(\d{8})', filename)
            return (match.group(1) or match.group(2) or match.group(3)) if match else None
        
        def verify_files_exist():
            """验证所有目标文件是否存在"""
            missing_files = []
            for target_name in APK_TARGETS.keys():
                file_path = os.path.join(APK_DIR, target_name)
                if not os.path.exists(file_path):
                    log.warning(f"文件缺失: {target_name}")
                    missing_files.append(target_name)
            return missing_files
        
        async def download_apk(client, message, target_name):
            """下载APK文件"""
            download_path = os.path.join(WORK_DIR, target_name)
            log.info(f"开始下载: {target_name}")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            size_mb = os.path.getsize(download_path) / (1024 * 1024)
            log.info(f"下载完成: {size_mb:.1f}MB, 耗时{elapsed:.1f}秒")
            
            # 提取版本信息
            version = extract_version(message.document.attributes[0].file_name)
            if not version and message.text:
                version = extract_version(message.text)
            
            if not version:
                version = datetime.now().strftime("%Y%m%d")
                log.info(f"使用后备版本号: {version}")
            
            return {
                "path": download_path,
                "version": f"v{version}" if not version.startswith('v') else version,
                "date": message.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
            }
        
        def should_update(target_name, new_version, new_date, current_versions):
            """检查是否需要更新"""
            # 如果文件不存在，必须更新
            file_path = os.path.join(APK_DIR, target_name)
            if not os.path.exists(file_path):
                log.info(f"文件不存在，需要更新: {target_name}")
                return True
                
            # 如果版本信息不存在，需要更新
            if target_name not in current_versions:
                log.info(f"版本信息缺失，需要更新: {target_name}")
                return True
                
            current = current_versions[target_name]
            current_ver, current_date = current.split(",", 1) if "," in current else (current, "")
            
            # 检查版本号或日期是否更新
            return (new_version != current_ver) or (new_date > current_date)
        
        async def find_latest_apks(client, entity):
            """查找最新的APK消息"""
            apk_messages = {}
            
            async for msg in client.iter_messages(entity, limit=MESSAGE_LIMIT):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                # 检查文件名属性
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                    
                    filename = attr.file_name.lower()
                    
                    # 匹配tv-new-x5.apk
                    if "x5" in filename and "tv-new-x5.apk" not in apk_messages:
                        apk_messages["tv-new-x5.apk"] = msg
                    
                    # 匹配tv-new.apk (排除X5版本)
                    if "original" in filename and "x5" not in filename and "tv-new.apk" not in apk_messages:
                        apk_messages["tv-new.apk"] = msg
                    
                    # 如果已找到两个文件，提前退出
                    if len(apk_messages) == len(APK_TARGETS):
                        return apk_messages
            return apk_messages
        
        async def main_async():
            """异步主函数"""
            log.info("="*50 + "\nAPK 同步工具启动\n" + "="*50)
            
            # 验证环境变量
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                log.error(f"错误: 缺少环境变量: {', '.join(missing)}")
                return 1
            
            # 设置Git
            if not git_setup():
                return 2
            
            # 获取当前版本
            current_versions = get_versions()
            log.info("当前版本信息:")
            for key, value in current_versions.items():
                if key in APK_TARGETS:
                    log.info(f"  {key}: {value}")
            
            # 检查文件存在性
            missing_files = verify_files_exist()
            if missing_files:
                log.warning(f"检测到缺失文件: {', '.join(missing_files)}")
            
            # 连接Telegram
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                await client.start()
                log.info(f"连接Telegram频道: {TELEGRAM_CHANNEL}")
                entity = await client.get_entity(TELEGRAM_CHANNEL)
                
                # 查找最新APK消息
                apk_msgs = await find_latest_apks(client, entity)
                if not apk_msgs:
                    log.info("未找到符合条件的APK消息")
                    return 0
                
                updates = {}
                
                # 处理每个APK
                for target_name, msg in apk_msgs.items():
                    apk_data = await download_apk(client, msg, target_name)
                    new_value = f"{apk_data['version']},{apk_data['date']}"
                    
                    if should_update(target_name, apk_data['version'], apk_data['date'], current_versions):
                        updates[target_name] = new_value
                    else:
                        log.info(f"跳过更新: {target_name} (无新版本)")
                
                if updates:
                    # 移动文件到目标目录
                    os.makedirs(APK_DIR, exist_ok=True)
                    for target_name in updates.keys():
                        src = os.path.join(WORK_DIR, target_name)
                        dst = os.path.join(APK_DIR, target_name)
                        
                        # 确保目录存在
                        os.makedirs(os.path.dirname(dst), exist_ok=True)
                        
                        # 删除旧文件（如果存在）
                        if os.path.exists(dst):
                            os.remove(dst)
                            log.info(f"已删除旧文件: {target_name}")
                            
                        shutil.move(src, dst)
                        log.info(f"已移动: {target_name}")
                    
                    # 更新版本文件
                    update_versions(updates)
                    
                    # 提交更改
                    if git_commit_push(f"更新APK: {', '.join(updates.keys())}"):
                        log.info("同步成功!")
                    else:
                        log.error("提交失败")
                        return 3
                else:
                    log.info("没有需要更新的APK文件")
                
                return 0
            except Exception as e:
                log.error(f"处理错误: {str(e)}")
                return 4
            finally:
                await client.disconnect()
                # 清理临时目录
                if os.path.exists(WORK_DIR):
                    shutil.rmtree(WORK_DIR)
                    log.info("临时目录已清理")
        
        if __name__ == "__main__":
            import asyncio
            sys.exit(asyncio.run(main_async()))
        EOF

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `🚨 Telegram APK同步失败！工作流运行详情: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
          })

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "TV NEW APK Sync from TELEGRAM"
          repository: ${{ github.repository }}