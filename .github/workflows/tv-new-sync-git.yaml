name: TV NEW APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */24 * * *'  # æ¯24å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon pytz

    - name: Run Optimized APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        APK_TARGETS = {
            "tv-new.apk": "all-sdk21-original",
            "tv-new-x5.apk": "armeabi-v7a-sdk21-X5"
        }
        APK_DIR = "apk"
        TELEGRAM_CHANNEL = "YYKM_release"
        MESSAGE_LIMIT = 15
        VERSION_FILE = "version.txt"
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = "temp_apks"
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def git_setup():
            """é…ç½®Gitç¯å¢ƒ"""
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = f"{actor}@users.noreply.github.com"
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                log.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def git_commit_push(message):
            """æäº¤å¹¶æ¨é€æ›´æ”¹"""
            try:
                # æ·»åŠ æ›´æ”¹
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], 
                                       cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                # ä½¿ç”¨æ ‡å‡†Gitæ¨é€
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "main"], cwd=GIT_DIR, check=True)
                log.info("æ¨é€æˆåŠŸ")
                return True
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯"""
            version_path = os.path.join(GIT_DIR, VERSION_FILE)
            if not os.path.exists(version_path):
                return {}
                
            try:
                with open(version_path, "r") as f:
                    return json.load(f)
            except json.JSONDecodeError:
                log.error("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œé‡ç½®ä¸ºç©ºç™½")
                return {}
        
        def update_versions(new_versions):
            """æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶å¹¶æ˜¾ç¤ºå˜æ›´"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(os.path.join(GIT_DIR, VERSION_FILE), "w") as f:
                json.dump(versions, f, indent=2)
                
            # ä»…æ˜¾ç¤ºå…³å¿ƒçš„é”®å€¼ç‰ˆæœ¬ä¿¡æ¯
            for key, value in new_versions.items():
                log.info(f"ç‰ˆæœ¬æ›´æ–°: {key} => {value}")
        
        def extract_version(filename):
            """ä»æ–‡ä»¶åæå–ç‰ˆæœ¬å·"""
            match = re.search(r'v?(\d+\.\d+\.\d+)|v?(\d+\.\d+)|(\d{8})', filename)
            return (match.group(1) or match.group(2) or match.group(3)) if match else None
        
        def verify_files_exist():
            """éªŒè¯æ‰€æœ‰ç›®æ ‡æ–‡ä»¶æ˜¯å¦å­˜åœ¨"""
            missing_files = []
            for target_name in APK_TARGETS.keys():
                file_path = os.path.join(APK_DIR, target_name)
                if not os.path.exists(file_path):
                    log.warning(f"æ–‡ä»¶ç¼ºå¤±: {target_name}")
                    missing_files.append(target_name)
            return missing_files
        
        async def download_apk(client, message, target_name):
            """ä¸‹è½½APKæ–‡ä»¶"""
            download_path = os.path.join(WORK_DIR, target_name)
            log.info(f"å¼€å§‹ä¸‹è½½: {target_name}")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            size_mb = os.path.getsize(download_path) / (1024 * 1024)
            log.info(f"ä¸‹è½½å®Œæˆ: {size_mb:.1f}MB, è€—æ—¶{elapsed:.1f}ç§’")
            
            # æå–ç‰ˆæœ¬ä¿¡æ¯
            version = extract_version(message.document.attributes[0].file_name)
            if not version and message.text:
                version = extract_version(message.text)
            
            if not version:
                version = datetime.now().strftime("%Y%m%d")
                log.info(f"ä½¿ç”¨åå¤‡ç‰ˆæœ¬å·: {version}")
            
            return {
                "path": download_path,
                "version": f"v{version}" if not version.startswith('v') else version,
                "date": message.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
            }
        
        def should_update(target_name, new_version, new_date, current_versions):
            """æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°"""
            # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¿…é¡»æ›´æ–°
            file_path = os.path.join(APK_DIR, target_name)
            if not os.path.exists(file_path):
                log.info(f"æ–‡ä»¶ä¸å­˜åœ¨ï¼Œéœ€è¦æ›´æ–°: {target_name}")
                return True
                
            # å¦‚æœç‰ˆæœ¬ä¿¡æ¯ä¸å­˜åœ¨ï¼Œéœ€è¦æ›´æ–°
            if target_name not in current_versions:
                log.info(f"ç‰ˆæœ¬ä¿¡æ¯ç¼ºå¤±ï¼Œéœ€è¦æ›´æ–°: {target_name}")
                return True
                
            current = current_versions[target_name]
            current_ver, current_date = current.split(",", 1) if "," in current else (current, "")
            
            # æ£€æŸ¥ç‰ˆæœ¬å·æˆ–æ—¥æœŸæ˜¯å¦æ›´æ–°
            return (new_version != current_ver) or (new_date > current_date)
        
        async def find_latest_apks(client, entity):
            """æŸ¥æ‰¾æœ€æ–°çš„APKæ¶ˆæ¯"""
            apk_messages = {}
            
            async for msg in client.iter_messages(entity, limit=MESSAGE_LIMIT):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                # æ£€æŸ¥æ–‡ä»¶åå±æ€§
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                    
                    filename = attr.file_name.lower()
                    
                    # åŒ¹é…tv-new-x5.apk
                    if "x5" in filename and "tv-new-x5.apk" not in apk_messages:
                        apk_messages["tv-new-x5.apk"] = msg
                    
                    # åŒ¹é…tv-new.apk (æ’é™¤X5ç‰ˆæœ¬)
                    if "original" in filename and "x5" not in filename and "tv-new.apk" not in apk_messages:
                        apk_messages["tv-new.apk"] = msg
                    
                    # å¦‚æœå·²æ‰¾åˆ°ä¸¤ä¸ªæ–‡ä»¶ï¼Œæå‰é€€å‡º
                    if len(apk_messages) == len(APK_TARGETS):
                        return apk_messages
            return apk_messages
        
        async def main_async():
            """å¼‚æ­¥ä¸»å‡½æ•°"""
            log.info("="*50 + "\nAPK åŒæ­¥å·¥å…·å¯åŠ¨\n" + "="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                log.error(f"é”™è¯¯: ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            # è®¾ç½®Git
            if not git_setup():
                return 2
            
            # è·å–å½“å‰ç‰ˆæœ¬
            current_versions = get_versions()
            log.info("å½“å‰ç‰ˆæœ¬ä¿¡æ¯:")
            for key, value in current_versions.items():
                if key in APK_TARGETS:
                    log.info(f"  {key}: {value}")
            
            # æ£€æŸ¥æ–‡ä»¶å­˜åœ¨æ€§
            missing_files = verify_files_exist()
            if missing_files:
                log.warning(f"æ£€æµ‹åˆ°ç¼ºå¤±æ–‡ä»¶: {', '.join(missing_files)}")
            
            # è¿æ¥Telegram
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                await client.start()
                log.info(f"è¿æ¥Telegramé¢‘é“: {TELEGRAM_CHANNEL}")
                entity = await client.get_entity(TELEGRAM_CHANNEL)
                
                # æŸ¥æ‰¾æœ€æ–°APKæ¶ˆæ¯
                apk_msgs = await find_latest_apks(client, entity)
                if not apk_msgs:
                    log.info("æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„APKæ¶ˆæ¯")
                    return 0
                
                updates = {}
                
                # å¤„ç†æ¯ä¸ªAPK
                for target_name, msg in apk_msgs.items():
                    apk_data = await download_apk(client, msg, target_name)
                    new_value = f"{apk_data['version']},{apk_data['date']}"
                    
                    if should_update(target_name, apk_data['version'], apk_data['date'], current_versions):
                        updates[target_name] = new_value
                    else:
                        log.info(f"è·³è¿‡æ›´æ–°: {target_name} (æ— æ–°ç‰ˆæœ¬)")
                
                if updates:
                    # ç§»åŠ¨æ–‡ä»¶åˆ°ç›®æ ‡ç›®å½•
                    os.makedirs(APK_DIR, exist_ok=True)
                    for target_name in updates.keys():
                        src = os.path.join(WORK_DIR, target_name)
                        dst = os.path.join(APK_DIR, target_name)
                        
                        # ç¡®ä¿ç›®å½•å­˜åœ¨
                        os.makedirs(os.path.dirname(dst), exist_ok=True)
                        
                        # åˆ é™¤æ—§æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        if os.path.exists(dst):
                            os.remove(dst)
                            log.info(f"å·²åˆ é™¤æ—§æ–‡ä»¶: {target_name}")
                            
                        shutil.move(src, dst)
                        log.info(f"å·²ç§»åŠ¨: {target_name}")
                    
                    # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                    update_versions(updates)
                    
                    # æäº¤æ›´æ”¹
                    if git_commit_push(f"æ›´æ–°APK: {', '.join(updates.keys())}"):
                        log.info("åŒæ­¥æˆåŠŸ!")
                    else:
                        log.error("æäº¤å¤±è´¥")
                        return 3
                else:
                    log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
                
                return 0
            except Exception as e:
                log.error(f"å¤„ç†é”™è¯¯: {str(e)}")
                return 4
            finally:
                await client.disconnect()
                # æ¸…ç†ä¸´æ—¶ç›®å½•
                if os.path.exists(WORK_DIR):
                    shutil.rmtree(WORK_DIR)
                    log.info("ä¸´æ—¶ç›®å½•å·²æ¸…ç†")
        
        if __name__ == "__main__":
            import asyncio
            sys.exit(asyncio.run(main_async()))
        EOF

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `ğŸš¨ Telegram APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œè¯¦æƒ…: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
          })

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "TV NEW APK Sync from TELEGRAM"
          repository: ${{ github.repository }}