name: Simple_live APK Sync from Source Repository

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */12 * * *'  # 每12小时运行一次
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock 🔒
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 600
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq python3
        
    - name: Run APK sync script
      env:
        SOURCE_REPO: "xiaoyaocz/dart_simple_live"
        TARGET_REPO: "${{ github.repository }}"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
        STABLE_APK_PATTERN: "app-arm64-v8a-release"
        PRE_RELEASE_APK_PATTERN: "app-armeabi-v7a-release"
        STABLE_KEY_NAME: "simple_live.apk"
        PRE_RELEASE_KEY_NAME: "simple_live-tv.apk"
      run: |
        #!/bin/bash
        set -euo pipefail
        
        WORK_DIR=$(mktemp -d)
        trap 'rm -rf "$WORK_DIR"; echo "清理临时目录..."' EXIT
        
        # 1. 目标文件存在性检测
        echo "检查目标文件存在性..."
        STABLE_TARGET_PATH="apk/$STABLE_KEY_NAME"
        PRE_TARGET_PATH="apk/$PRE_RELEASE_KEY_NAME"
        
        # 检查文件存在性的函数
        check_file_exists() {
          local path=$1
          http_status=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$path")
          [ "$http_status" -eq 200 ]
        }
        
        STABLE_EXISTS=$(check_file_exists "$STABLE_TARGET_PATH" && echo 1 || echo 0)
        PRE_EXISTS=$(check_file_exists "$PRE_TARGET_PATH" && echo 1 || echo 0)
        echo "稳定版存在: $STABLE_EXISTS, 预发行版存在: $PRE_EXISTS"
        
        # 2. 获取源仓库发布信息
        echo "获取源仓库发布信息..."
        releases=$(curl -sL "https://api.github.com/repos/$SOURCE_REPO/releases")
        
        # 提取最新稳定版
        stable_release=$(echo "$releases" | jq -r '[.[] | select(.prerelease == false)] | sort_by(.published_at) | reverse | .[0]')
        stable_version=$(echo "$stable_release" | jq -r '.tag_name')
        stable_date=$(echo "$stable_release" | jq -r '.published_at' | TZ=UTC date -f - +'%Y-%m-%d')
        echo "稳定版: $stable_version ($stable_date)"
        
        # 提取最新预发行版
        pre_release=$(echo "$releases" | jq -r '[.[] | select(.prerelease == true)] | sort_by(.published_at) | reverse | .[0]')
        if [ "$pre_release" != "null" ]; then
          pre_version=$(echo "$pre_release" | jq -r '.tag_name' | sed 's/^tv_//')
          pre_date=$(echo "$pre_release" | jq -r '.published_at' | TZ=UTC date -f - +'%Y-%m-%d')
          echo "预发行版: $pre_version ($pre_date)"
          sync_pre_release=true
        else
          echo "无预发行版可用"
          sync_pre_release=false
        fi
        
        # 3. 获取目标仓库版本文件
        echo "获取目标仓库版本信息..."
        version_response=$(curl -s -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
        
        # 创建临时文件处理版本数据
        CURRENT_VERSION_FILE="$WORK_DIR/version.json"
        
        if [ "$(echo "$version_response" | jq -r '.message')" != "Not Found" ]; then
          echo "$version_response" | jq -r '.content' | base64 -d > "$CURRENT_VERSION_FILE"
          SHA_VERSION=$(echo "$version_response" | jq -r '.sha')
          echo "当前版本文件内容已保存到文件"
        else
          echo "{}" > "$CURRENT_VERSION_FILE"
          SHA_VERSION=""
          echo "无版本文件，创建空文件"
        fi
        
        # 4. 初始化更新标志
        SYNC_STABLE=false
        SYNC_PRE_RELEASE=false
        
        # 5. 使用Python处理版本更新
        cat > "$WORK_DIR/update_version.py" << 'EOF'
import json
import sys
import os

def main():
    version_file = sys.argv[1]
    key_name = sys.argv[2]
    new_value = sys.argv[3]
    
    # 读取当前版本数据
    with open(version_file, 'r') as f:
        data = json.load(f)
    
    # 获取当前值
    current_value = data.get(key_name, "")
    
    # 检查是否需要更新
    need_update = False
    if key_name == os.environ.get('STABLE_KEY_NAME') and os.environ.get('STABLE_EXISTS') == '0':
        need_update = True
    elif key_name == os.environ.get('PRE_RELEASE_KEY_NAME') and os.environ.get('PRE_EXISTS') == '0':
        need_update = True
    elif current_value == "":
        need_update = True
    elif current_value != new_value:
        need_update = True
    
    if need_update:
        print(f"需要更新: {key_name} (当前: {current_value}, 最新: {new_value})")
        # 更新值
        data[key_name] = new_value
        with open(version_file, 'w') as f:
            json.dump(data, f)
        return True
    else:
        print(f"无需更新: {key_name} ({current_value})")
        return False

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("用法: python update_version.py <version_file> <key_name> <new_value>")
        sys.exit(1)
    updated = main()
    sys.exit(0 if updated else 1)
EOF
        
        # 6. 检查并下载APK
        check_and_download() {
          local release_json=$1
          local key_name=$2
          local apk_pattern=$3
          local new_value="$4,$5"
          
          # 检查是否需要更新
          if python3 "$WORK_DIR/update_version.py" "$CURRENT_VERSION_FILE" "$key_name" "$new_value"; then
            echo "需要更新: $key_name"
            
            # 下载APK
            download_url=$(echo "$release_json" | jq -r \
              ".assets[] | select(.name | contains(\"$apk_pattern\")) | .browser_download_url" | head -1)
            
            if [ -z "$download_url" ]; then
              echo "错误: 未找到匹配的APK文件 (模式: $apk_pattern)"
              return 1
            fi
            
            echo "下载: $download_url"
            curl -sL "$download_url" -o "$WORK_DIR/$key_name"
            
            if [ ! -f "$WORK_DIR/$key_name" ]; then
              echo "错误: APK下载失败"
              return 1
            fi
            
            # 设置更新标志
            if [ "$key_name" = "$STABLE_KEY_NAME" ]; then
              SYNC_STABLE=true
            else
              SYNC_PRE_RELEASE=true
            fi
          fi
          
          return 0
        }
        
        # 7. 文件上传函数
        upload_file() {
          local file_path=$1
          local target_path=$2
          
          # 获取文件SHA（如果存在）
          file_info=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target_path")
          sha=$(echo "$file_info" | jq -r '.sha // empty')
          
          # 创建临时JSON文件
          json_file=$(mktemp)
          
          # 使用base64编码内容
          content_base64=$(base64 -w0 "$file_path")
          
          # 使用jq生成JSON
          jq -n \
            --arg msg "更新: $target_path" \
            --arg content "$content_base64" \
            --arg sha "$sha" \
            '{message: $msg, content: $content, sha: $sha}' > "$json_file"
          
          echo "上传: $target_path"
          response=$(curl -s -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            -d "@$json_file" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target_path")
          
          rm -f "$json_file"
          
          if ! echo "$response" | jq -e '.content' >/dev/null; then
            echo "错误: 文件上传失败"
            echo "响应: $response"
            return 1
          fi
          
          return 0
        }
        
        # 8. 处理稳定版
        echo "处理稳定版..."
        check_and_download "$stable_release" "$STABLE_KEY_NAME" "$STABLE_APK_PATTERN" "$stable_version" "$stable_date"
        if [ -f "$WORK_DIR/$STABLE_KEY_NAME" ]; then
          upload_file "$WORK_DIR/$STABLE_KEY_NAME" "apk/$STABLE_KEY_NAME"
          echo "稳定版同步成功"
        fi
        
        # 9. 处理预发行版
        if [ "$sync_pre_release" = true ]; then
          echo "处理预发行版..."
          check_and_download "$pre_release" "$PRE_RELEASE_KEY_NAME" "$PRE_RELEASE_APK_PATTERN" "$pre_version" "$pre_date"
          if [ -f "$WORK_DIR/$PRE_RELEASE_KEY_NAME" ]; then
            upload_file "$WORK_DIR/$PRE_RELEASE_KEY_NAME" "apk/$PRE_RELEASE_KEY_NAME"
            echo "预发行版同步成功"
          fi
        fi
        
        # 10. 更新版本文件（仅在需要时）
        if $SYNC_STABLE || $SYNC_PRE_RELEASE; then
          echo "准备更新版本文件..."
          
          # 创建临时JSON文件上传
          local version_json_file=$(mktemp)
          
          # 获取版本文件内容
          ENCODED_CONTENT=$(base64 -w0 "$CURRENT_VERSION_FILE")
          
          jq -n \
            --arg msg "更新版本文件" \
            --arg content "$ENCODED_CONTENT" \
            --arg sha "$SHA_VERSION" \
            '{message: $msg, content: $content, sha: $sha}' > "$version_json_file"
          
          # 上传版本文件
          response=$(curl -s -w "\n%{http_code}" -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            --data-binary "@$version_json_file" \
            "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
          
          rm -f "$version_json_file"
          
          http_code=$(echo "$response" | tail -n1)
          if [ "$http_code" -ne 200 ] && [ "$http_code" -ne 201 ]; then
            echo "错误: 版本文件更新失败 - HTTP状态码 $http_code"
            echo "响应详情: $(echo "$response" | sed '$d')"
            exit 1
          fi
          echo "版本文件更新成功"
        else
          echo "无文件更新，跳过版本文件更新"
        fi
        
        # 11. 输出结果
        echo "同步完成!"
        $SYNC_STABLE && echo "稳定版: $stable_version ($stable_date)"
        $SYNC_PRE_RELEASE && echo "预发行版: $pre_version ($pre_date)"
        exit 0

    - name: Release Repository Lock 🔓
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Simple_live APK Sync from Source Repository"
          repository: ${{ github.repository }}