name: TV APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */24 * * *'  # æ¯24å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon pytz

    - name: Run Optimized APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        APK_TARGETS = {
            "tv.apk": "all-sdk21-original",
            "tv-x5.apk": "all-sdk21-original-X5"
        }
        APK_DIR = "apk"
        TELEGRAM_CHANNEL = "mytv_android_release"
        MESSAGE_LIMIT = 20
        VERSION_FILE = "version.txt"
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = "temp_apks"
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        logger = logging.getLogger()
        
        def git_setup():
            """é…ç½®Gitç¯å¢ƒ"""
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = f"{actor}@users.noreply.github.com"
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                
                logger.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                logger.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def git_commit_push(message):
            """æäº¤å¹¶æ¨é€æ›´æ”¹"""
            try:
                # æ·»åŠ æ›´æ”¹
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], 
                                       cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    logger.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                # ä½¿ç”¨æ ‡å‡†Gitæ¨é€
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "main"], cwd=GIT_DIR, check=True)
                logger.info("æ¨é€æˆåŠŸ")
                return True
            except Exception as e:
                logger.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯ï¼ˆåªå…³å¿ƒAPK_TARGETSä¸­çš„é”®ï¼‰"""
            version_path = os.path.join(GIT_DIR, VERSION_FILE)
            if not os.path.exists(version_path):
                return {}
                
            try:
                with open(version_path, "r") as f:
                    versions = json.load(f)
                    # åªè¿”å›å…³å¿ƒçš„é”®å€¼
                    return {k: v for k, v in versions.items() if k in APK_TARGETS}
            except json.JSONDecodeError:
                logger.error("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œé‡ç½®ä¸ºç©ºç™½")
                return {}
        
        def update_versions(new_versions):
            """æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶å¹¶æ˜¾ç¤ºå˜æ›´ï¼ˆåªå…³å¿ƒAPK_TARGETSä¸­çš„é”®ï¼‰"""
            # è¯»å–æ•´ä¸ªç‰ˆæœ¬æ–‡ä»¶
            version_path = os.path.join(GIT_DIR, VERSION_FILE)
            all_versions = {}
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        all_versions = json.load(f)
                except:
                    pass
            
            # åªæ›´æ–°å…³å¿ƒçš„é”®å€¼
            for key, value in new_versions.items():
                all_versions[key] = value
            
            # ä¿å­˜æ•´ä¸ªç‰ˆæœ¬æ–‡ä»¶
            with open(version_path, "w") as f:
                json.dump(all_versions, f, indent=2)
            
            # åªæ˜¾ç¤ºå…³å¿ƒçš„é”®å€¼ç‰ˆæœ¬ä¿¡æ¯
            logger.info("ç‰ˆæœ¬æ›´æ–°:")
            for key, value in new_versions.items():
                logger.info(f"  {key}: {value}")
        
        def extract_version(filename):
            """ä»æ–‡ä»¶åæå–ç‰ˆæœ¬å·"""
            match = re.search(r'v?(\d+\.\d+\.\d+)|v?(\d+\.\d+)|(\d{8})', filename)
            return (match.group(1) or match.group(2) or match.group(3)) if match else None
        
        def verify_local_files(current_versions):
            """éªŒè¯æœ¬åœ°æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”ä¸ç‰ˆæœ¬è®°å½•ä¸€è‡´"""
            missing_files = []
            inconsistent_versions = []
            
            for target_name, version_value in current_versions.items():
                file_path = os.path.join(APK_DIR, target_name)
                
                # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                if not os.path.exists(file_path):
                    logger.warning(f"æ–‡ä»¶ç¼ºå¤±: {target_name} (ç‰ˆæœ¬: {version_value})")
                    missing_files.append(target_name)
                    continue
                
                # æ£€æŸ¥ç‰ˆæœ¬å·æ˜¯å¦åŒ¹é…
                if ',' in version_value:
                    version_str = version_value.split(',')[0]
                    extracted = extract_version(target_name)
                    if extracted and version_str != extracted:
                        logger.warning(f"ç‰ˆæœ¬ä¸ä¸€è‡´: {target_name} (è®°å½•: {version_str}, å®é™…: {extracted})")
                        inconsistent_versions.append(target_name)
            
            return missing_files, inconsistent_versions
        
        async def download_apk(client, message, target_name):
            """ä¸‹è½½APKæ–‡ä»¶"""
            download_path = os.path.join(WORK_DIR, target_name)
            logger.info(f"å¼€å§‹ä¸‹è½½: {target_name}")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            size_mb = os.path.getsize(download_path) / (1024 * 1024)
            logger.info(f"ä¸‹è½½å®Œæˆ: {size_mb:.1f}MB, è€—æ—¶{elapsed:.1f}ç§’")
            
            # æå–ç‰ˆæœ¬ä¿¡æ¯
            version = extract_version(message.document.attributes[0].file_name)
            if not version and message.text:
                version = extract_version(message.text)
            
            if not version:
                version = datetime.now().strftime("%Y%m%d")
                logger.info(f"ä½¿ç”¨åå¤‡ç‰ˆæœ¬å·: {version}")
            
            return {
                "path": download_path,
                "version": f"v{version}" if not version.startswith('v') else version,
                "date": message.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
            }
        
        def should_update(target_name, new_version, new_date, current_versions):
            """æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ï¼ˆåªå…³å¿ƒç‰ˆæœ¬å’Œæ—¥æœŸï¼‰"""
            current = current_versions.get(target_name, "")
            if not current:
                return True
                
            if ',' in current:
                current_ver, current_date = current.split(",", 1)
                return (new_version != current_ver) or (new_date > current_date)
            return new_version != current
        
        async def find_latest_apks(client, entity):
            """æŸ¥æ‰¾æœ€æ–°çš„APKæ¶ˆæ¯"""
            apk_messages = {}
            
            async for msg in client.iter_messages(entity, limit=MESSAGE_LIMIT):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                # æ£€æŸ¥æ–‡ä»¶åå±æ€§
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                    
                    filename = attr.file_name.lower()
                    
                    # åŒ¹é…tv-x5.apk
                    if "x5" in filename and "tv-x5.apk" not in apk_messages:
                        apk_messages["tv-x5.apk"] = msg
                    
                    # åŒ¹é…tv.apk (æ’é™¤X5ç‰ˆæœ¬)
                    if "original" in filename and "x5" not in filename and "tv.apk" not in apk_messages:
                        apk_messages["tv.apk"] = msg
                    
                    # å¦‚æœå·²æ‰¾åˆ°ä¸¤ä¸ªæ–‡ä»¶ï¼Œæå‰é€€å‡º
                    if len(apk_messages) == len(APK_TARGETS):
                        return apk_messages
            return apk_messages
        
        async def main_async():
            """å¼‚æ­¥ä¸»å‡½æ•°"""
            logger.info("="*50 + "\nAPK åŒæ­¥å·¥å…·å¯åŠ¨\n" + "="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                logger.error(f"é”™è¯¯: ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            # è®¾ç½®Git
            if not git_setup():
                return 2
            
            # è·å–å½“å‰ç‰ˆæœ¬ï¼ˆåªå…³å¿ƒAPK_TARGETSä¸­çš„é”®ï¼‰
            current_versions = get_versions()
            logger.info("å½“å‰å…³å¿ƒçš„ç‰ˆæœ¬ä¿¡æ¯:")
            for key, value in current_versions.items():
                logger.info(f"  {key}: {value}")
            
            # éªŒè¯æœ¬åœ°æ–‡ä»¶å­˜åœ¨æ€§å’Œä¸€è‡´æ€§
            missing_files, inconsistent_versions = verify_local_files(current_versions)
            if missing_files or inconsistent_versions:
                logger.warning("æ£€æµ‹åˆ°æœ¬åœ°æ–‡ä»¶é—®é¢˜:")
                if missing_files:
                    logger.warning(f"  - ç¼ºå¤±æ–‡ä»¶: {', '.join(missing_files)}")
                if inconsistent_versions:
                    logger.warning(f"  - ç‰ˆæœ¬ä¸ä¸€è‡´: {', '.join(inconsistent_versions)}")
            
            # è¿æ¥Telegram
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                await client.start()
                logger.info(f"è¿æ¥Telegramé¢‘é“: {TELEGRAM_CHANNEL}")
                entity = await client.get_entity(TELEGRAM_CHANNEL)
                
                # æŸ¥æ‰¾æœ€æ–°APKæ¶ˆæ¯
                apk_msgs = await find_latest_apks(client, entity)
                if not apk_msgs:
                    logger.info("æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„APKæ¶ˆæ¯")
                    return 0
                
                updates = {}
                force_updates = missing_files + inconsistent_versions
                
                # å¤„ç†æ¯ä¸ªAPK
                for target_name, msg in apk_msgs.items():
                    apk_data = await download_apk(client, msg, target_name)
                    new_value = f"{apk_data['version']},{apk_data['date']}"
                    
                    # å¦‚æœæ–‡ä»¶ç¼ºå¤±æˆ–ç‰ˆæœ¬ä¸ä¸€è‡´ï¼Œå¼ºåˆ¶æ›´æ–°
                    if target_name in force_updates:
                        logger.info(f"å¼ºåˆ¶æ›´æ–°: {target_name} (æ–‡ä»¶é—®é¢˜)")
                        updates[target_name] = new_value
                    elif should_update(target_name, apk_data['version'], apk_data['date'], current_versions):
                        updates[target_name] = new_value
                    else:
                        logger.info(f"è·³è¿‡æ›´æ–°: {target_name} (æ— æ–°ç‰ˆæœ¬)")
                
                if updates:
                    # ç§»åŠ¨æ–‡ä»¶åˆ°ç›®æ ‡ç›®å½•
                    os.makedirs(APK_DIR, exist_ok=True)
                    for target_name in updates.keys():
                        src = os.path.join(WORK_DIR, target_name)
                        dst = os.path.join(APK_DIR, target_name)
                        
                        # ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
                        os.makedirs(os.path.dirname(dst), exist_ok=True)
                        
                        # åˆ é™¤æ—§æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        if os.path.exists(dst):
                            os.remove(dst)
                            logger.info(f"å·²åˆ é™¤æ—§æ–‡ä»¶: {target_name}")
                            
                        shutil.move(src, dst)
                        logger.info(f"å·²ç§»åŠ¨: {target_name}")
                    
                    # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶ï¼ˆåªæ˜¾ç¤ºå…³å¿ƒçš„é”®å€¼ï¼‰
                    update_versions(updates)
                    
                    # æäº¤æ›´æ”¹
                    if git_commit_push(f"æ›´æ–°APK: {', '.join(updates.keys())}"):
                        logger.info("åŒæ­¥æˆåŠŸ!")
                    else:
                        logger.error("æäº¤å¤±è´¥")
                        return 3
                else:
                    logger.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
                
                return 0
            except Exception as e:
                logger.error(f"å¤„ç†é”™è¯¯: {str(e)}")
                return 4
            finally:
                await client.disconnect()
                # æ¸…ç†ä¸´æ—¶ç›®å½•
                if os.path.exists(WORK_DIR):
                    shutil.rmtree(WORK_DIR)
                    logger.info("ä¸´æ—¶ç›®å½•å·²æ¸…ç†")
        
        if __name__ == "__main__":
            import asyncio
            sys.exit(asyncio.run(main_async()))
        EOF

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `ğŸš¨ Telegram APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œè¯¦æƒ…: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
          })

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "TV APK Sync from TELEGRAM"
          repository: ${{ github.repository }}