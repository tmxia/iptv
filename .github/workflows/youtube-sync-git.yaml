name: YouTube APK Sync from Source Repository

# 使用原生并发控制
concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */4 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    # 基于缓存的锁机制
    - name: Acquire Repository Lock 🔒
      uses: softprops/turnstyle@v3
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 600
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout target repository
      uses: actions/checkout@v5
      with:
        repository: ${{ github.repository }}
        token: ${{ secrets.GITHUB_TOKEN }}
        path: target-repo
        fetch-depth: 1

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl

    - name: Run APK sync script
      env:
        SOURCE_REPO: "NoName-exe/revanced"
        TARGET_REPO: "${{ github.repository }}"
      run: |
        # 工作目录
        WORK_DIR=$(mktemp -d)
        echo "创建临时目录: $WORK_DIR"
        trap 'rm -rf "$WORK_DIR"; echo "清理临时目录..."' EXIT

        # 目标仓库目录
        TARGET_DIR="$GITHUB_WORKSPACE/target-repo"
        VERSION_FILE="$TARGET_DIR/version.txt"
        DOWNLOAD_LINKS_FILE="$TARGET_DIR/download-links.json"
        
        # 1. 版本文件键值存在性检测
        echo "检查版本文件存在性..."
        if [ -f "$VERSION_FILE" ]; then
          echo "版本文件存在: $VERSION_FILE"
          CURRENT_VERSION_DATA=$(cat "$VERSION_FILE")
          # 验证JSON格式
          if ! echo "$CURRENT_VERSION_DATA" | jq -e . >/dev/null 2>&1; then
            echo "版本文件格式无效，重置为空对象"
            CURRENT_VERSION_DATA="{}"
            echo "{}" > "$VERSION_FILE"
          fi
        else
          echo "版本文件不存在，创建空版本文件"
          echo "{}" > "$VERSION_FILE"
          CURRENT_VERSION_DATA="{}"
        fi
        
        # 2. 获取最新发布版本的资源文件
        echo "获取最新发布版本..."
        RELEASE_JSON=$(curl -sL "https://api.github.com/repos/$SOURCE_REPO/releases/latest")
        if [ $? -ne 0 ] || [ -z "$RELEASE_JSON" ]; then
          echo "错误: 无法获取最新发布版本"
          exit 1
        fi
        
        # 提取发布信息
        RELEASE_TAG=$(echo "$RELEASE_JSON" | jq -r '.tag_name')
        RELEASE_DATE=$(echo "$RELEASE_JSON" | jq -r '.published_at')
        RELEASE_DATE_UTC8=$(TZ=Asia/Shanghai date -d "$RELEASE_DATE" +'%Y-%m-%d')
        echo "最新发布版本: $RELEASE_TAG, 发布日期: $RELEASE_DATE_UTC8"
        
        # 3. 精准匹配APK文件
        echo "搜索匹配的APK文件..."
        
        # 查找YouTube APK文件 - 只匹配APK，排除Magisk模块
        YOUTUBE_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | test("^youtube-revanced.*\\.apk$")) | select(.name | test("magisk") | not) | {name: .name, url: .browser_download_url, size: .size}' | jq -s '.[0]')
        if [ "$YOUTUBE_ASSET" = "null" ] || [ -z "$YOUTUBE_ASSET" ]; then
          echo "错误: 未找到匹配的YouTube APK文件"
          exit 1
        fi
        
        YOUTUBE_APK_NAME=$(echo "$YOUTUBE_ASSET" | jq -r '.name')
        YOUTUBE_DOWNLOAD_URL=$(echo "$YOUTUBE_ASSET" | jq -r '.url')
        YOUTUBE_FILE_SIZE=$(echo "$YOUTUBE_ASSET" | jq -r '.size')
        echo "找到YouTube APK: $YOUTUBE_APK_NAME (大小: $((YOUTUBE_FILE_SIZE/1024/1024))MB)"
        
        # 查找YouTube Music APK文件 - 只匹配APK，排除Magisk模块
        YOUTUBE_MUSIC_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | test("^youtube-music-revanced.*\\.apk$")) | select(.name | test("magisk") | not) | {name: .name, url: .browser_download_url, size: .size}' | jq -s '.[0]')
        if [ "$YOUTUBE_MUSIC_ASSET" = "null" ] || [ -z "$YOUTUBE_MUSIC_ASSET" ]; then
          echo "错误: 未找到匹配的YouTube Music APK文件"
          exit 1
        fi
        
        YOUTUBE_MUSIC_APK_NAME=$(echo "$YOUTUBE_MUSIC_ASSET" | jq -r '.name')
        YOUTUBE_MUSIC_DOWNLOAD_URL=$(echo "$YOUTUBE_MUSIC_ASSET" | jq -r '.url')
        YOUTUBE_MUSIC_FILE_SIZE=$(echo "$YOUTUBE_MUSIC_ASSET" | jq -r '.size')
        echo "找到YouTube Music APK: $YOUTUBE_MUSIC_APK_NAME (大小: $((YOUTUBE_MUSIC_FILE_SIZE/1024/1024))MB)"
        
        # 4. 触发更新逻辑
        NEED_UPDATE=0
        
        # 从文件名提取版本号函数
        extract_version_from_filename() {
          local filename="$1"
          echo "从文件名提取版本号: $filename" >&2
          
          # 从文件名中提取版本号模式 vX.Y.Z
          VERSION=$(echo "$filename" | grep -oP 'v\d+\.\d+\.\d+' | head -1)
          
          if [ -z "$VERSION" ]; then
            echo "警告: 无法从文件名提取版本号" >&2
            VERSION="$RELEASE_TAG"
          fi
          
          echo "提取的版本号: $VERSION" >&2
          echo "$VERSION"
        }
        
        # 提取版本信息（从文件名）
        YOUTUBE_VERSION=$(extract_version_from_filename "$YOUTUBE_APK_NAME")
        YOUTUBE_MUSIC_VERSION=$(extract_version_from_filename "$YOUTUBE_MUSIC_APK_NAME")
        
        echo "YouTube版本: $YOUTUBE_VERSION, 发布日期: $RELEASE_DATE_UTC8"
        echo "YouTube Music版本: $YOUTUBE_MUSIC_VERSION, 发布日期: $RELEASE_DATE_UTC8"
        
        # 5. 对比更新逻辑 - 使用更安全的方法提取当前版本
        echo "提取当前版本信息..."
        
        # 使用更安全的方法从JSON中提取值
        if echo "$CURRENT_VERSION_DATA" | jq -e ".youtube" >/dev/null 2>&1; then
          CURRENT_YOUTUBE=$(echo "$CURRENT_VERSION_DATA" | jq -r ".youtube")
        else
          CURRENT_YOUTUBE=""
        fi
        
        if echo "$CURRENT_VERSION_DATA" | jq -e ".youtube_music" >/dev/null 2>&1; then
          CURRENT_YOUTUBE_MUSIC=$(echo "$CURRENT_VERSION_DATA" | jq -r ".youtube_music")
        else
          CURRENT_YOUTUBE_MUSIC=""
        fi
        
        NEW_YOUTUBE_VALUE="$YOUTUBE_VERSION,$RELEASE_DATE_UTC8"
        NEW_YOUTUBE_MUSIC_VALUE="$YOUTUBE_MUSIC_VERSION,$RELEASE_DATE_UTC8"
        
        echo "当前YouTube版本: $CURRENT_YOUTUBE"
        echo "当前YouTube Music版本: $CURRENT_YOUTUBE_MUSIC"
        echo "新YouTube版本: $NEW_YOUTUBE_VALUE"
        echo "新YouTube Music版本: $NEW_YOUTUBE_MUSIC_VALUE"
        
        # 更新检测
        if [ "$CURRENT_YOUTUBE" != "$NEW_YOUTUBE_VALUE" ]; then
          echo "YouTube版本变化：$CURRENT_YOUTUBE -> $NEW_YOUTUBE_VALUE，需要更新"
          NEED_UPDATE=1
        else
          echo "YouTube无变化"
        fi
        
        if [ "$CURRENT_YOUTUBE_MUSIC" != "$NEW_YOUTUBE_MUSIC_VALUE" ]; then
          echo "YouTube Music版本变化：$CURRENT_YOUTUBE_MUSIC -> $NEW_YOUTUBE_MUSIC_VALUE，需要更新"
          NEED_UPDATE=1
        else
          echo "YouTube Music无变化"
        fi
        
        # 检查是否需要更新
        if [ "$NEED_UPDATE" -eq 0 ]; then
          echo "没有需要更新的版本"
          exit 0
        fi
        
        # 6. 更新版本文件和下载链接文件
        echo "更新版本文件和下载链接..."
        
        # 创建临时版本文件
        TEMP_VERSION_FILE="$WORK_DIR/version_temp.json"
        
        # 更新版本文件
        if [ -n "$CURRENT_YOUTUBE" ]; then
          echo "$CURRENT_VERSION_DATA" | jq --arg key "youtube" --arg value "$NEW_YOUTUBE_VALUE" '.[$key] = $value' > "$TEMP_VERSION_FILE"
        else
          echo "$CURRENT_VERSION_DATA" | jq --arg key "youtube" --arg value "$NEW_YOUTUBE_VALUE" '. + {($key): $value}' > "$TEMP_VERSION_FILE"
        fi
        
        # 验证第一步成功
        if [ $? -ne 0 ]; then
          echo "错误: 第一步版本文件更新失败"
          exit 1
        fi
        
        # 第二步更新YouTube Music
        if [ -n "$CURRENT_YOUTUBE_MUSIC" ]; then
          cat "$TEMP_VERSION_FILE" | jq --arg key "youtube_music" --arg value "$NEW_YOUTUBE_MUSIC_VALUE" '.[$key] = $value' > "$VERSION_FILE"
        else
          cat "$TEMP_VERSION_FILE" | jq --arg key "youtube_music" --arg value "$NEW_YOUTUBE_MUSIC_VALUE" '. + {($key): $value}' > "$VERSION_FILE"
        fi
        
        # 验证第二步成功
        if [ $? -ne 0 ]; then
          echo "错误: 第二步版本文件更新失败"
          exit 1
        fi
        
        # 创建下载链接文件
        DOWNLOAD_LINKS_JSON=$(cat <<EOF
{
  "youtube": {
    "name": "$YOUTUBE_APK_NAME",
    "version": "$YOUTUBE_VERSION",
    "download_url": "$YOUTUBE_DOWNLOAD_URL",
    "size": $YOUTUBE_FILE_SIZE,
    "release_date": "$RELEASE_DATE_UTC8",
    "release_tag": "$RELEASE_TAG"
  },
  "youtube_music": {
    "name": "$YOUTUBE_MUSIC_APK_NAME",
    "version": "$YOUTUBE_MUSIC_VERSION",
    "download_url": "$YOUTUBE_MUSIC_DOWNLOAD_URL",
    "size": $YOUTUBE_MUSIC_FILE_SIZE,
    "release_date": "$RELEASE_DATE_UTC8",
    "release_tag": "$RELEASE_TAG"
  }
}
EOF
        )
        
        echo "$DOWNLOAD_LINKS_JSON" | jq -r . > "$DOWNLOAD_LINKS_FILE"
        
        echo "版本文件和下载链接已更新"
        
        # 7. 创建README文件（可选）
        README_FILE="$TARGET_DIR/APK_DOWNLOADS.md"
        cat > "$README_FILE" <<EOF
# YouTube ReVanced APK 下载信息

> 最后更新: $(date)

## 当前版本信息

| 应用 | 版本 | 发布日期 | 文件大小 | 下载链接 |
|------|------|----------|----------|----------|
| YouTube ReVanced | $YOUTUBE_VERSION | $RELEASE_DATE_UTC8 | $((YOUTUBE_FILE_SIZE/1024/1024))MB | [下载]($YOUTUBE_DOWNLOAD_URL) |
| YouTube Music ReVanced | $YOUTUBE_MUSIC_VERSION | $RELEASE_DATE_UTC8 | $((YOUTUBE_MUSIC_FILE_SIZE/1024/1024))MB | [下载]($YOUTUBE_MUSIC_DOWNLOAD_URL) |

## 使用说明

1. 点击上面的下载链接直接下载APK文件
2. 在Android设备上安装下载的APK文件
3. 如果提示"禁止安装来自未知来源的应用"，请先在设置中允许安装未知来源的应用

## 注意事项

- 这些APK文件来自 [NoName-exe/revanced](https://github.com/NoName-exe/revanced) 仓库
- 文件大小超过GitHub的100MB限制，因此不直接存储在仓库中
- 版本信息会自动同步更新

## 自动化信息

此页面由GitHub Actions自动生成，每4小时检查一次更新。

EOF
        
        # 8. 提交和推送
        cd "$TARGET_DIR"
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"

        # 添加所有更改
        git add .
        
        # 检查是否有更改
        if git diff-index --quiet HEAD --; then
          echo "没有更改需要提交"
          exit 0
        fi

        COMMIT_MESSAGE="更新YouTube APK信息: YouTube ($YOUTUBE_VERSION) YouTube Music ($YOUTUBE_MUSIC_VERSION) - $RELEASE_TAG"
        
        git commit -m "$COMMIT_MESSAGE"
        
        # 推送重试机制
        for i in {1..3}; do
          echo "尝试 $i/3: 拉取远程最新更改..."
          git pull origin main --rebase || {
            echo "拉取失败，等待10秒后重试..."
            sleep 10
            continue
          }
          
          echo "尝试 $i/3: 推送更改..."
          if git push origin main; then
            echo "推送成功!"
            break
          else
            echo "推送失败，等待10秒后重试..."
            sleep 10
          fi
        done
        
        if [ $i -eq 3 ]; then
          echo "错误: 经过3次尝试后仍无法推送更改"
          exit 1
        fi

        # 9. 最终验证
        echo "同步完成，验证结果:"
        echo "版本文件: $([ -f "$VERSION_FILE" ] && echo "存在" || echo "缺失")"
        echo "下载链接文件: $([ -f "$DOWNLOAD_LINKS_FILE" ] && echo "存在" || echo "缺失")"
        echo "README文件: $([ -f "$README_FILE" ] && echo "存在" || echo "缺失")"
        
        echo "所有文件已确认同步至仓库"
        echo "状态: 成功"

    - name: Release Repository Lock 🔓
      if: always()
      uses: softprops/turnstyle@v3
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            if (context.issue && context.issue.number) {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `🚨 YouTube APK同步失败！工作流运行: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            } else {
              const issueTitle = "YouTube APK同步失败通知";
              const issueBody = `### 🚨 YouTube APK同步失败\n\n` +
                               `**工作流**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n` +
                               `**失败时间**: ${new Date().toISOString()}\n\n` +
                               `请检查工作流日志以获取详细信息。`;
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody
              });
            }
          } catch (error) {
            console.error('通知失败:', error);
            core.warning('无法发送通知，请手动检查工作流失败情况');
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2.0.6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "YouTube APK Sync from Source Repository"
          repository: ${{ github.repository }}