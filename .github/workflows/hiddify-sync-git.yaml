name: Hiddify APK Sync from Source Repository

on:
  schedule:
    - cron: '0 */48 * * *'  # 每48小时运行一次
  workflow_dispatch:

concurrency:
  group: sync-apk-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock
      id: lock
      run: |
        LOCK_DIR="$GITHUB_WORKSPACE/.lock"
        LOCK_FILE="$LOCK_DIR/repo-lock"
        mkdir -p "$LOCK_DIR"
        
        for i in {1..10}; do
          if [ -f "$LOCK_FILE" ]; then
            echo "锁已被占用，等待重试 ($i/10)..."
            sleep 30
          else
            touch "$LOCK_FILE"
            echo "lock-acquired=true" >> $GITHUB_OUTPUT
            echo "成功获取锁"
            exit 0
          fi
        done
        
        echo "::error::无法在5分钟内获取锁"
        exit 1

    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Setup Git identity
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl
        
    - name: Run APK sync script
      env:
        SOURCE_REPO: "hiddify/hiddify-app"
        APK_PATTERN: "Android-arm64.apk"
        STABLE_KEY_NAME: "hiddify.apk"
        PRE_RELEASE_KEY_NAME: "hiddify-beta.apk"
      run: |
        STABLE_TARGET_FILENAME="apk/$STABLE_KEY_NAME"
        PRE_RELEASE_TARGET_FILENAME="apk/$PRE_RELEASE_KEY_NAME"
        
        WORK_DIR=$(mktemp -d)
        echo "创建临时目录: $WORK_DIR"
        trap 'rm -rf "$WORK_DIR"; echo "清理临时目录..."' EXIT

        mkdir -p apk

        echo "获取最新发布版本信息..."
        # 增加API请求重试和错误处理
        for i in {1..5}; do
          RELEASES_JSON=$(curl -sfL "https://api.github.com/repos/$SOURCE_REPO/releases")
          if [ $? -eq 0 ]; then
            break
          else
            echo "API请求失败，重试 ($i/5)..."
            sleep 10
          fi
        done
        
        if [ -z "$RELEASES_JSON" ]; then
          echo "错误: 无法获取发布信息"
          exit 1
        fi
        
        # 检查返回的是否是数组（而不是错误消息）
        if ! echo "$RELEASES_JSON" | jq -e 'if type == "array" then true else false end' >/dev/null; then
          echo "错误: GitHub API返回无效数据:"
          echo "$RELEASES_JSON" | head -c 200
          exit 1
        fi

        # 安全提取稳定版 - 处理可能的空结果
        LATEST_STABLE_RELEASE=$(echo "$RELEASES_JSON" | jq -r '[.[] | select(.prerelease == false)] | sort_by(.published_at) | reverse | .[0]')
        if [ -z "$LATEST_STABLE_RELEASE" ] || [ "$LATEST_STABLE_RELEASE" = "null" ]; then
          echo "错误: 无法提取稳定版发布信息"
          exit 1
        fi
        STABLE_VERSION=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.tag_name')
        STABLE_PUBLISHED_AT=$(echo "$LATEST_STABLE_RELEASE" | jq -r '.published_at')
        STABLE_DATE=$(TZ=UTC date -d "$STABLE_PUBLISHED_AT" +'%Y-%m-%d')
        echo "源仓库最新稳定版: $STABLE_VERSION (发布于: $STABLE_DATE)"

        # 安全提取预发行版
        LATEST_PRE_RELEASE=$(echo "$RELEASES_JSON" | jq -r '[.[] | select(.prerelease == true)] | sort_by(.published_at) | reverse | .[0]')
        if [ -z "$LATEST_PRE_RELEASE" ] || [ "$LATEST_PRE_RELEASE" = "null" ]; then
          echo "警告: 无法提取预发行版发布信息，跳过预发行版同步"
          SYNC_PRE_RELEASE=false
        else
          PRE_RELEASE_VERSION=$(echo "$LATEST_PRE_RELEASE" | jq -r '.tag_name')
          PRE_RELEASE_PUBLISHED_AT=$(echo "$LATEST_PRE_RELEASE" | jq -r '.published_at')
          PRE_RELEASE_DATE=$(TZ=UTC date -d "$PRE_RELEASE_PUBLISHED_AT" +'%Y-%m-%d')
          echo "源仓库最新预发行版: $PRE_RELEASE_VERSION (发布于: $PRE_RELEASE_DATE)"
          SYNC_PRE_RELEASE=true
        fi

        VERSION_FILE="version.txt"
        CURRENT_VERSION_DATA="{}"
        if [ -f "$VERSION_FILE" ]; then
          echo "找到本地版本文件"
          CURRENT_VERSION_DATA=$(cat "$VERSION_FILE" | jq . 2>/dev/null || echo "{}")
        else
          echo "创建新的版本文件"
          echo "{}" > "$VERSION_FILE"
        fi

        CURRENT_STABLE_VERSION=$(echo "$CURRENT_VERSION_DATA" | jq -r ".\"$STABLE_KEY_NAME\" // \"\"" | cut -d, -f1)
        CURRENT_STABLE_DATE=$(echo "$CURRENT_VERSION_DATA" | jq -r ".\"$STABLE_KEY_NAME\" // \"\"" | cut -d, -f2)
        CURRENT_PRE_RELEASE_VERSION=$(echo "$CURRENT_VERSION_DATA" | jq -r ".\"$PRE_RELEASE_KEY_NAME\" // \"\"" | cut -d, -f1)
        CURRENT_PRE_RELEASE_DATE=$(echo "$CURRENT_VERSION_DATA" | jq -r ".\"$PRE_RELEASE_KEY_NAME\" // \"\"" | cut -d, -f2)

        echo "当前稳定版版本: $CURRENT_STABLE_VERSION (日期: $CURRENT_STABLE_DATE)"
        echo "当前预发行版版本: $CURRENT_PRE_RELEASE_VERSION (日期: $CURRENT_PRE_RELEASE_DATE)"

        check_and_download_apk() {
          local release_json="$1"
          local target_filename="$2"
          local key_name="$3"
          local current_version="$4"
          
          local latest_version=$(echo "$release_json" | jq -r '.tag_name')
          
          echo "检查本地APK文件是否存在: $target_filename..."
          local apk_exists=false
          if [ -f "$target_filename" ]; then
            echo "本地存在APK文件: $target_filename"
            apk_exists=true
          else
            echo "本地不存在APK文件: $target_filename"
          fi
          
          local need_update=false
          
          if [ "$latest_version" != "$current_version" ]; then
            echo "发现新版本: $latest_version (当前: $current_version)"
            need_update=true
          elif [ "$apk_exists" = false ]; then
            echo "版本号匹配但APK文件不存在，需要重新下载"
            need_update=true
          elif [ -z "$current_version" ]; then
            echo "版本文件无效，需要更新"
            need_update=true
          else
            echo "版本相同 ($latest_version) 且APK文件存在，无需更新"
          fi
          
          if [ "$need_update" = true ]; then
            local download_url=$(echo "$release_json" | jq -r '.assets[] | select(.name | contains("'$APK_PATTERN'")) | .browser_download_url' | head -1)
            
            if [ -z "$download_url" ]; then
              echo "错误: 未找到匹配的APK文件"
              return 2
            fi
            
            echo "下载APK: $download_url"
            
            # 增加下载重试机制
            for i in {1..3}; do
              curl -sfL "$download_url" -o "$target_filename"
              if [ $? -eq 0 ] && [ -s "$target_filename" ]; then
                echo "下载成功"
                break
              else
                echo "下载失败，重试 ($i/3)..."
                sleep 5
                rm -f "$target_filename"
              fi
            done
            
            if [ ! -f "$target_filename" ]; then
              echo "错误: APK下载失败 - 文件未创建"
              return 2
            fi
            
            if [ ! -s "$target_filename" ]; then
              echo "错误: 下载的文件为空"
              rm -f "$target_filename"
              return 2
            fi
            
            # 添加文件大小检查
            FILESIZE=$(stat -c%s "$target_filename")
            if [ "$FILESIZE" -lt 1000000 ]; then
              echo "错误: 下载的文件太小(可能不完整)"
              rm -f "$target_filename"
              return 2
            fi
            
            return 0  # 成功下载
          else
            return 0  # 无需更新
          fi
        }

        # 处理稳定版
        STABLE_NEED_UPDATE=false
        echo "===== 处理稳定版 ====="
        check_and_download_apk "$LATEST_STABLE_RELEASE" "$STABLE_TARGET_FILENAME" "$STABLE_KEY_NAME" "$CURRENT_STABLE_VERSION"
        STABLE_RESULT=$?
        if [ $STABLE_RESULT -eq 0 ]; then
          if [ -f "$STABLE_TARGET_FILENAME" ]; then
            STABLE_NEED_UPDATE=true
            NEW_STABLE_VERSION="$STABLE_VERSION"
            NEW_STABLE_DATE="$STABLE_DATE"
            echo "稳定版需要更新"
          else
            NEW_STABLE_VERSION="$CURRENT_STABLE_VERSION"
            NEW_STABLE_DATE="$CURRENT_STABLE_DATE"
            echo "稳定版无需更新"
          fi
        else
          echo "错误: 稳定版处理失败"
          exit 1
        fi

        # 处理预发行版
        PRE_RELEASE_NEED_UPDATE=false
        if [ "$SYNC_PRE_RELEASE" = true ]; then
          echo "===== 处理预发行版 ====="
          check_and_download_apk "$LATEST_PRE_RELEASE" "$PRE_RELEASE_TARGET_FILENAME" "$PRE_RELEASE_KEY_NAME" "$CURRENT_PRE_RELEASE_VERSION"
          PRE_RELEASE_RESULT=$?
          if [ $PRE_RELEASE_RESULT -eq 0 ]; then
            if [ -f "$PRE_RELEASE_TARGET_FILENAME" ]; then
              PRE_RELEASE_NEED_UPDATE=true
              NEW_PRE_RELEASE_VERSION="$PRE_RELEASE_VERSION"
              NEW_PRE_RELEASE_DATE="$PRE_RELEASE_DATE"
              echo "预发行版需要更新"
            else
              NEW_PRE_RELEASE_VERSION="$CURRENT_PRE_RELEASE_VERSION"
              NEW_PRE_RELEASE_DATE="$CURRENT_PRE_RELEASE_DATE"
              echo "预发行版无需更新"
            fi
          else
            echo "错误: 预发行版处理失败"
            exit 1
          fi
        else
          NEW_PRE_RELEASE_VERSION="$CURRENT_PRE_RELEASE_VERSION"
          NEW_PRE_RELEASE_DATE="$CURRENT_PRE_RELEASE_DATE"
          echo "跳过预发行版处理"
        fi

        NEW_VERSION_DATA=$(echo "$CURRENT_VERSION_DATA" | jq \
            --arg stable_key "$STABLE_KEY_NAME" \
            --arg stable_value "$NEW_STABLE_VERSION,$NEW_STABLE_DATE" \
            --arg pre_key "$PRE_RELEASE_KEY_NAME" \
            --arg pre_value "$NEW_PRE_RELEASE_VERSION,$NEW_PRE_RELEASE_DATE" \
            '.[$stable_key] = $stable_value | .[$pre_key] = $pre_value')
            
        NEW_VERSION_CONTENT=$(echo "$NEW_VERSION_DATA" | jq -r .)

        echo "更新后的版本文件内容:"
        echo "$NEW_VERSION_CONTENT"
        
        echo "$NEW_VERSION_CONTENT" > "$WORK_DIR/new_version.txt"
        VERSION_CHANGED=true
        if [ -f "$VERSION_FILE" ]; then
          if diff -q "$WORK_DIR/new_version.txt" "$VERSION_FILE" >/dev/null; then
            echo "版本文件内容未变化"
            VERSION_CHANGED=false
          fi
        fi
        
        if $VERSION_CHANGED; then
          echo "$NEW_VERSION_CONTENT" > version.txt
        fi

        CHANGES_DETECTED=false
        if [ "$STABLE_NEED_UPDATE" = true ] || [ "$PRE_RELEASE_NEED_UPDATE" = true ]; then
          CHANGES_DETECTED=true
        fi
        
        if $VERSION_CHANGED; then
          CHANGES_DETECTED=true
        fi

        if [ "$CHANGES_DETECTED" = true ]; then
          echo "提交更改到Git仓库..."
          git add apk/ version.txt
          git commit -m "更新APK: 稳定版=$NEW_STABLE_VERSION, 预发行版=$NEW_PRE_RELEASE_VERSION"
          
          MAX_RETRIES=3
          RETRY_DELAY=10
          for i in $(seq 1 $MAX_RETRIES); do
            echo "推送更改 (尝试 $i/$MAX_RETRIES)..."
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            git pull --rebase origin $CURRENT_BRANCH
            if git push origin $CURRENT_BRANCH; then
              echo "推送成功"
              break
            else
              echo "推送失败，等待重试..."
              sleep $RETRY_DELAY
            fi
            if [ $i -eq $MAX_RETRIES ]; then
              echo "错误: 推送失败，超过最大重试次数"
              exit 1
            fi
          done
        else
          echo "没有检测到更改，跳过提交"
        fi

        echo "同步完成! 状态: 成功"
        echo "稳定版: $STABLE_TARGET_FILENAME ($NEW_STABLE_VERSION, $NEW_STABLE_DATE)"
        if [ "$SYNC_PRE_RELEASE" = true ]; then
          echo "预发行版: $PRE_RELEASE_TARGET_FILENAME ($NEW_PRE_RELEASE_VERSION, $NEW_PRE_RELEASE_DATE)"
        fi
        
        exit 0

    - name: Release Repository Lock
      if: always()
      run: |
        LOCK_FILE="$GITHUB_WORKSPACE/.lock/repo-lock"
        if [ -f "$LOCK_FILE" ]; then
          rm -f "$LOCK_FILE"
          echo "锁已释放"
        else
          echo "锁文件不存在，无需释放"
        fi

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Hiddify APK Sync from Source Repository"
          repository: ${{ github.repository }}