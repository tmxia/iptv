name: TV APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */24 * * *'  # æ¯24å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20åˆ†é’Ÿè¶…æ—¶
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip
        pip install telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        APK_TARGETS = {
            "tv.apk": "all-sdk21-original",
            "tv-x5.apk": "armeabi-v7a-sdk21-X5"
        }
        APK_DIR = "apk"
        TELEGRAM_CHANNEL = "YYKM_release"  # ç¡¬ç¼–ç é¢‘é“åç§°
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = os.path.join(os.getcwd(), "temp_apks")
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹ï¼ˆé˜²æ­¢å†²çªï¼‰
                log.info("æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹...")
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                
                log.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # æ·»åŠ æ‰€æœ‰æ›´æ”¹
                subprocess.run(["git", "add", "."], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # é‡è¯•æœºåˆ¶ï¼ˆæœ€å¤š3æ¬¡ï¼‰
                max_attempts = 3
                for attempt in range(1, max_attempts + 1):
                    try:
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹å¹¶å˜åŸº...")
                        subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                        
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ¨é€æ›´æ”¹...")
                        subprocess.run(
                            ["git", "push", repo_url, "HEAD:main"],
                            cwd=GIT_DIR,
                            check=True
                        )
                        log.info("æ¨é€æˆåŠŸ")
                        return True
                    except subprocess.CalledProcessError as e:
                        log.warning(f"å°è¯• {attempt} å¤±è´¥: {str(e)}")
                        if attempt < max_attempts:
                            log.info("ç­‰å¾…10ç§’åé‡è¯•...")
                            time.sleep(10)
                        else:
                            log.error(f"ç»è¿‡{max_attempts}æ¬¡å°è¯•åä»æ— æ³•æ¨é€æ›´æ”¹")
                            return False
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_current_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œè¿”å›å­—å…¸å’Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨æ ‡å¿—"""
            version_path = os.path.join(GIT_DIR, "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f), True
                except json.JSONDecodeError:
                    log.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œé‡æ–°åˆå§‹åŒ–")
                    return {}, True
                except Exception as e:
                    log.warning(f"è¯»å–ç‰ˆæœ¬æ–‡ä»¶å¤±è´¥: {str(e)}ï¼Œé‡æ–°åˆå§‹åŒ–")
                    return {}, True
            return {}, False
        
        def update_versions(versions):
            version_path = os.path.join(GIT_DIR, "version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def parse_version_from_filename(filename):
            """ä»æ–‡ä»¶åè§£æç‰ˆæœ¬å·"""
            # å°è¯•åŒ¹é…å¸¸è§çš„ç‰ˆæœ¬å·æ¨¡å¼ (vX.X.X æˆ– X.X.X)
            version_patterns = [
                r'v?(\d+\.\d+\.\d+)',  # v1.2.3 æˆ– 1.2.3
                r'v?(\d+\.\d+)',       # v1.2 æˆ– 1.2
                r'(\d{8})'             # 20230608
            ]
            
            for pattern in version_patterns:
                match = re.search(pattern, filename)
                if match:
                    version = match.group(1)
                    # ç¡®ä¿ç‰ˆæœ¬å·ä»¥"v"å¼€å¤´ï¼ˆå¦‚æœæ˜¯æ•°å­—ç‰ˆæœ¬ï¼‰
                    if re.match(r'\d', version[0]) and '.' in version:
                        return 'v' + version
                    return version
            return None
        
        async def download_apk(client, message, filename):
            download_path = os.path.join(WORK_DIR, filename)
            total_size = message.document.size
            
            log.info(f"å¼€å§‹ä¸‹è½½: {filename} ({format_size(total_size)})")
            start_time = time.time()
            
            # ä¸‹è½½æ–‡ä»¶
            await client.download_media(message, file=download_path)
            
            # è®¡ç®—ä¸‹è½½é€Ÿåº¦
            elapsed = time.time() - start_time
            avg_speed = total_size / elapsed if elapsed > 0 else 0
            log.info(f"ä¸‹è½½å®Œæˆ: {filename} - è€—æ—¶: {elapsed:.1f}ç§’, å¹³å‡é€Ÿåº¦: {format_size(avg_speed)}/s")
            
            # ç‰ˆæœ¬è§£æ
            version = None
            
            # 1. ä»æ–‡ä»¶åè§£æ
            version = parse_version_from_filename(filename)
            if version:
                log.info(f"ä»æ–‡ä»¶åè§£æå‡ºç‰ˆæœ¬å·: {version}")
            
            # 2. ä»æ¶ˆæ¯æ–‡æœ¬è§£æ
            if not version and message.text:
                log.info(f"å°è¯•ä»æ¶ˆæ¯æ–‡æœ¬è§£æç‰ˆæœ¬å·: {message.text[:50]}...")
                version = parse_version_from_filename(message.text)
                if version:
                    log.info(f"ä»æ¶ˆæ¯æ–‡æœ¬è§£æå‡ºç‰ˆæœ¬å·: {version}")
            
            # å¦‚æœæ— æ³•è§£æç‰ˆæœ¬å·ï¼Œè§†ä¸ºé”™è¯¯
            if not version:
                log.error(f"æ— æ³•è§£æç‰ˆæœ¬å·: {filename}")
                return None
            
            # åªä¿ç•™æ—¥æœŸéƒ¨åˆ†ï¼ˆYYYY-MM-DDï¼‰
            date_iso = message.date.strftime("%Y-%m-%d")
            
            return {
                "path": download_path,
                "version": version,
                "date_iso": date_iso
            }
        
        def check_local_files():
            """æ£€æŸ¥æœ¬åœ°APKæ–‡ä»¶æ˜¯å¦å­˜åœ¨å¹¶è¿”å›ç‰ˆæœ¬ä¿¡æ¯"""
            target_dir = os.path.join(GIT_DIR, APK_DIR)
            local_files = {}
            file_missing = False
            
            for target_name in APK_TARGETS.keys():
                file_path = os.path.join(target_dir, target_name)
                if os.path.exists(file_path):
                    log.info(f"æœ¬åœ°æ–‡ä»¶å­˜åœ¨: {target_name}")
                    # å°è¯•ä»ç‰ˆæœ¬æ–‡ä»¶è·å–ä¿¡æ¯
                    version_path = os.path.join(GIT_DIR, "version.txt")
                    if os.path.exists(version_path):
                        try:
                            with open(version_path, "r") as f:
                                versions = json.load(f)
                                if target_name in versions:
                                    local_files[target_name] = versions[target_name]
                                    continue
                        except:
                            pass
                    # å¦‚æœç‰ˆæœ¬æ–‡ä»¶ä¸­æ²¡æœ‰ï¼Œä½¿ç”¨æ–‡ä»¶ä¿®æ”¹æ—¶é—´ä½œä¸ºæ—¥æœŸ
                    mtime = os.path.getmtime(file_path)
                    file_date = datetime.fromtimestamp(mtime).strftime("%Y-%m-%d")
                    local_files[target_name] = f"unknown,{file_date}"
                else:
                    log.warning(f"æœ¬åœ°æ–‡ä»¶ç¼ºå¤±: {target_name}")
                    file_missing = True
                    local_files[target_name] = None
            
            return local_files, not file_missing
        
        def should_download_apk(target_name, msg_date, current_versions):
            """åˆ¤æ–­æ˜¯å¦éœ€è¦ä¸‹è½½APK"""
            # å¦‚æœæœ¬åœ°æ²¡æœ‰è¯¥APKçš„è®°å½•ï¼Œéœ€è¦ä¸‹è½½
            if target_name not in current_versions or current_versions[target_name] is None:
                log.info(f"æœ¬åœ°æ— è®°å½•ï¼Œéœ€è¦ä¸‹è½½ {target_name}")
                return True
            
            # è§£æå½“å‰ç‰ˆæœ¬ä¿¡æ¯
            current_value = current_versions[target_name]
            if current_value and ',' in current_value:
                _, current_date_str = current_value.split(',', 1)
            else:
                current_date_str = "1970-01-01"
            
            # å°†æ¶ˆæ¯æ—¥æœŸè½¬æ¢ä¸ºæ—¥æœŸå­—ç¬¦ä¸²ï¼ˆYYYY-MM-DDï¼‰
            utc8 = pytz.timezone('Asia/Shanghai')
            msg_date_utc8 = msg.date.astimezone(utc8)
            msg_date_str = msg_date_utc8.strftime("%Y-%m-%d")
            
            # å¦‚æœæ¶ˆæ¯æ—¥æœŸæ¯”è®°å½•æ—¥æœŸæ–°ï¼Œéœ€è¦ä¸‹è½½
            if msg_date_str > current_date_str:
                log.info(f"æ–°å‘å¸ƒæ—¥æœŸ: {msg_date_str} > å½“å‰æ—¥æœŸ: {current_date_str}ï¼Œéœ€è¦ä¸‹è½½")
                return True
            
            # æ—¥æœŸç›¸åŒçš„æƒ…å†µï¼Œéœ€è¦ä¸‹è½½ä»¥æ£€æŸ¥ç‰ˆæœ¬å·æ˜¯å¦æ›´æ–°
            if msg_date_str == current_date_str:
                log.info(f"åŒä¸€å¤©å‘å¸ƒçš„æ¶ˆæ¯ ({msg_date_str})ï¼Œéœ€è¦æ£€æŸ¥ç‰ˆæœ¬å·æ˜¯å¦æ›´æ–°")
                return True
            
            log.info(f"æ¶ˆæ¯æ—¥æœŸ {msg_date_str} ä¸æ–°äºå½“å‰æ—¥æœŸ {current_date_str}ï¼Œè·³è¿‡ä¸‹è½½")
            return False
        
        async def find_apks_in_channel(client, entity):
            """åœ¨é¢‘é“ä¸­æŸ¥æ‰¾åŒ¹é…çš„APKæ–‡ä»¶"""
            log.info(f"å¼€å§‹æ‰«æé¢‘é“: {entity.title}")
            latest_msgs = {}
            message_count = 0
            apk_count = 0
            
            # æ‰«ææœ€è¿‘çš„100æ¡æ¶ˆæ¯ï¼ˆä¸é™æ—¶é—´èŒƒå›´ï¼‰
            async for msg in client.iter_messages(entity, limit=100):
                message_count += 1
                if msg.media and hasattr(msg.media, "document"):
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            apk_count += 1
                            log.debug(f"å‘ç°APKæ–‡ä»¶: {filename} (å‘å¸ƒäº {msg.date})")
                            
                            # æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ¹é…ä»»ä½•ç›®æ ‡
                            for target_name, key_part in APK_TARGETS.items():
                                if key_part.lower() in filename.lower():
                                    log.info(f"æ‰¾åˆ°åŒ¹é…æ–‡ä»¶: {filename} -> {target_name} (å‘å¸ƒäº {msg.date})")
                                    
                                    # åªä¿ç•™æ¯ä¸ªç›®æ ‡çš„æœ€æ–°æ¶ˆæ¯
                                    if target_name not in latest_msgs or msg.date > latest_msgs[target_name].date:
                                        latest_msgs[target_name] = {
                                            "message": msg,
                                            "original_filename": filename
                                        }
                                    break
            
            log.info(f"æ‰«æå®Œæˆ: å…±æ£€æŸ¥ {message_count} æ¡æ¶ˆæ¯ï¼Œå‘ç° {apk_count} ä¸ªAPKæ–‡ä»¶")
            return latest_msgs
        
        async def process_apk_updates(client, entity, current_versions):
            """å¤„ç†APKæ›´æ–°"""
            # åœ¨é¢‘é“ä¸­æŸ¥æ‰¾APKæ–‡ä»¶
            apk_matches = await find_apks_in_channel(client, entity)
            if not apk_matches:
                log.warning("åœ¨é¢‘é“ä¸­æœªæ‰¾åˆ°åŒ¹é…çš„APKæ–‡ä»¶")
                return None
            
            updates = {}
            
            # å¤„ç†æ¯ä¸ªç›®æ ‡æ–‡ä»¶
            for target_name, data in apk_matches.items():
                msg = data["message"]
                original_filename = data["original_filename"]
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸‹è½½
                if not should_download_apk(target_name, msg.date, current_versions):
                    log.info(f"è·³è¿‡ä¸‹è½½: {original_filename} (ç‰ˆæœ¬å·²å­˜åœ¨æˆ–éæœ€æ–°)")
                    continue
                
                # ä¸‹è½½APK
                log.info(f"å¼€å§‹å¤„ç†: {original_filename}")
                apk_data = await download_apk(client, msg, original_filename)
                if not apk_data:
                    log.error(f"ä¸‹è½½å¤±è´¥æˆ–æ— æ³•è§£æç‰ˆæœ¬å·: {original_filename}")
                    continue
                
                # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                new_value = f"{apk_data['version']},{apk_data['date_iso']}"
                updates[target_name] = {
                    "data": apk_data,
                    "version_info": new_value
                }
            
            return updates if updates else None
        
        async def main_async():
            log.info("="*50)
            log.info("APK åŒæ­¥å·¥å…·å¯åŠ¨")
            log.info("="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log.error(f"é”™è¯¯: ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            # é¦–å…ˆæ£€æŸ¥æœ¬åœ°æ–‡ä»¶
            current_versions, all_files_exist = check_local_files()
            log.info(f"å½“å‰ç‰ˆæœ¬çŠ¶æ€: {json.dumps(current_versions, indent=2)}")
            
            # å¦‚æœæ‰€æœ‰æ–‡ä»¶éƒ½å­˜åœ¨ï¼Œåˆ™ä¸éœ€è¦ç«‹å³æ›´æ–°
            if all_files_exist:
                log.info("æ‰€æœ‰APKæ–‡ä»¶å·²å­˜åœ¨ï¼Œå°†æ£€æŸ¥æ›´æ–°")
            else:
                log.warning("éƒ¨åˆ†APKæ–‡ä»¶ç¼ºå¤±ï¼Œéœ€è¦ä»Telegramè·å–")
            
            # åˆå§‹åŒ–Telegramå®¢æˆ·ç«¯
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                await client.start()
                # ç›´æ¥ä½¿ç”¨ç¡¬ç¼–ç çš„é¢‘é“åç§°
                channel = TELEGRAM_CHANNEL
                log.info(f"è¿æ¥Telegramé¢‘é“: {channel}")
                
                try:
                    entity = await client.get_entity(channel)
                    log.info(f"æˆåŠŸè·å–é¢‘é“å®ä½“: {entity.title}")
                except Exception as e:
                    log.error(f"è·å–é¢‘é“å®ä½“å¤±è´¥: {str(e)}")
                    return 3
                
                # å¤„ç†APKæ›´æ–°
                new_apks = await process_apk_updates(client, entity, current_versions)
            except Exception as e:
                log.error(f"Telegramé”™è¯¯: {str(e)}")
                return 4
            finally:
                await client.disconnect()
            
            updated = False
            
            if new_apks:
                # å¤„ç†æ–°æ–‡ä»¶
                target_dir = os.path.join(GIT_DIR, APK_DIR)
                os.makedirs(target_dir, exist_ok=True)
                
                for target_name, data in new_apks.items():
                    # ç›®æ ‡è·¯å¾„ä½¿ç”¨æ ‡å‡†åç§°
                    target_path = os.path.join(target_dir, target_name)
                    
                    # å¤åˆ¶æ–‡ä»¶åˆ°ç›®æ ‡ä½ç½®ï¼ˆä½¿ç”¨æ ‡å‡†åç§°ï¼‰
                    shutil.copy2(data["data"]["path"], target_path)
                    
                    # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                    current_versions[target_name] = data["version_info"]
                    log.info(f"å·²æ›´æ–°: {target_name} (ç‰ˆæœ¬: {data['version_info']})")
                    updated = True
                
                # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                update_versions(current_versions)
                
                # æäº¤æ›´æ”¹
                commit_msg = f"æ›´æ–°APK: {', '.join(new_apks.keys())}"
                if commit_and_push(commit_msg):
                    log.info(f"åŒæ­¥æˆåŠŸ! æ›´æ–°äº† {len(new_apks)} ä¸ªæ–‡ä»¶")
                else:
                    log.error("æäº¤å¤±è´¥")
                    return 5
            else:
                log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
            
            # æœ€ç»ˆæ£€æŸ¥APKæ–‡ä»¶æ˜¯å¦å­˜åœ¨
            current_versions, all_files_exist = check_local_files()
            if not all_files_exist:
                log.error("å…³é”®é”™è¯¯: ç¼ºå°‘APKæ–‡ä»¶")
                return 6
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log.info("ä¸´æ—¶ç›®å½•å·²æ¸…ç†")
            
            log.info("="*50)
            log.info("åŒæ­¥ä»»åŠ¡å®Œæˆ")
            log.info("="*50)
            return 0
        
        def main():
            import asyncio
            return asyncio.run(main_async())
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          const message = `ğŸš¨ Telegram APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          })

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "TV APK Sync from TELEGRAM"
          repository: ${{ github.repository }}