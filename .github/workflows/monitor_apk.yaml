name: Real-time Directory Monitor

on:
  push:
    paths:
      - 'apk/**'
      - 'kernels/**'
      - 'version.txt'
    branches: [ main ]
  workflow_run:
    workflows: ["NagramX Sync from Source Repository", "BV APK Sync from Source Repository", "GitHub XAPK Download and Sync", "Karing Beta Sync from Source Repository", "MYTV APK Sync from Source Repository", "OK PRO APK Sync from TELEGRAM", "OK APK Sync from Source Repository", "Proxypin Sync from Source Repository", "Simple_live APK Sync from Source Repository", "OpenWrt Kernel Sync from TELEGRAM", "ServerBox Sync from Source Repository"]
    types: [completed]

jobs:
  detect-and-notify:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    concurrency: 
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.REPO_PAT }}

    - name: è·å–æœ€æ–°å˜æ›´
      run: git pull origin ${{ github.ref }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake libgit2-dev
        pip install telethon pygit2

    - name: Run enhanced detection script
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL }}
        EMAIL_RECEIVER: ${{ secrets.EMAIL_RECEIVER }}
        SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USER: ${{ secrets.SMTP_USER }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}
      run: |
        cat << 'EOF' > directory_monitor.py
        import os
        import re
        import pygit2
        import asyncio
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from urllib.parse import quote
        import json
        
        # è·å–å‡†ç¡®ç‰ˆæœ¬å·ï¼ˆä»version.txtï¼‰
        def get_accurate_version(filename):
            """ä»version.txtè·å–å‡†ç¡®çš„ç‰ˆæœ¬å·"""
            version_path = "version.txt"
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        version_data = json.load(f)
                    
                    # æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶å
                    if filename in version_data:
                        # æ ¼å¼ä¸º "ç‰ˆæœ¬å·,æ—¥æœŸ"
                        version_info = version_data[filename]
                        if isinstance(version_info, str) and ',' in version_info:
                            return version_info.split(',')[0]
                        return version_info
                except Exception as e:
                    print(f"âŒ è§£æversion.txtå¤±è´¥: {str(e)}")
            return None
        
        def generate_proxy_urls(raw_url):
            """ç”Ÿæˆä»£ç†ä¸‹è½½é“¾æ¥"""
            return {
                "gh-proxy": f"https://gh-proxy.com/{raw_url}",
                "github-speedup": f"https://github-speedup.com/{raw_url}"
            }
        
        def get_file_type(path):
            """æ ¹æ®è·¯å¾„ç¡®å®šæ–‡ä»¶ç±»å‹"""
            if path.startswith('apk/'):
                return "App File"
            elif path.startswith('kernels/'):
                return "Kernel File"
            return "File"
        
        def get_file_icon(path):
            """è·å–æ–‡ä»¶ç±»å‹å›¾æ ‡"""
            if path.endswith('.apk'):
                return "ğŸ“±"
            elif path.endswith('.zip'):
                return "ğŸ“¦"
            elif path.endswith('.tar.gz'):
                return "ğŸ—œï¸"
            return "ğŸ“„"
        
        def get_current_versions():
            """ä»version.txtè·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯"""
            version_path = "version.txt"
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f)
                except:
                    return {}
            return {}
        
        async def send_telegram_message(files):
            """ä½¿ç”¨Telethonå‘é€æ¶ˆæ¯"""
            try:
                api_id = int(os.getenv("TELEGRAM_API_ID"))
                api_hash = os.getenv("TELEGRAM_API_HASH")
                session_str = os.getenv("TELEGRAM_SESSION")
                channel = os.getenv("TELEGRAM_CHANNEL")
                
                if not all([api_id, api_hash, session_str, channel]):
                    print("âŒ Telegramé…ç½®ä¸å®Œæ•´")
                    return False
                
                async with TelegramClient(
                    StringSession(session_str), 
                    api_id, 
                    api_hash
                ) as client:
                    # æ„å»ºç®€æ´æ¶ˆæ¯
                    message = "ğŸš€ **å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥**\n\n"
                    message += f"ğŸ”– ä»“åº“: `{os.getenv('GITHUB_REPOSITORY')}`\n"
                    message += f"ğŸ†” æäº¤: [{os.getenv('GITHUB_SHA')[:7]}](https://github.com/{os.getenv('GITHUB_REPOSITORY')}/commit/{os.getenv('GITHUB_SHA')})\n\n"
                    
                    # æ·»åŠ æ–‡ä»¶åˆ—è¡¨
                    for file in files:
                        # ä½¿ç”¨åå¼•å·åŒ…è£¹æ–‡ä»¶åï¼Œé¿å…è¢«è§£æä¸ºé“¾æ¥
                        icon = get_file_icon(file['path'])
                        file_type = get_file_type(file['path'])
                        message += f"{icon} **{file_type}**: `{file['name']}`\n"
                        message += f"  - ç‰ˆæœ¬: `{file['version']}`\n"
                        message += f"  - æ›´æ–°: `{file['date']}`\n"
                        message += f"  - [ä¸‹è½½æ–‡ä»¶]({file['url']})\n\n"
                    
                    await client.send_message(
                        entity=channel,
                        message=message,
                        parse_mode='md',
                        link_preview=False
                    )
                    return True
            except Exception as e:
                print(f"âŒ Telethoné”™è¯¯: {str(e)}")
                return False
        
        def send_email(files, receiver_email):
            """å‘é€é‚®ä»¶é€šçŸ¥"""
            try:
                # ä»ç¯å¢ƒå˜é‡è·å–SMTPé…ç½®
                smtp_server = os.getenv("SMTP_SERVER")
                smtp_port = int(os.getenv("SMTP_PORT", 587))
                smtp_user = os.getenv("SMTP_USER")
                smtp_password = os.getenv("SMTP_PASSWORD")
                
                # éªŒè¯é…ç½®å®Œæ•´æ€§
                if not all([smtp_server, smtp_user, smtp_password]):
                    print("âŒ SMTPé…ç½®ä¸å®Œæ•´")
                    return False
                
                # æ„å»ºé‚®ä»¶ä¸»é¢˜å’Œå†…å®¹
                subject = f"å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥ - {os.getenv('GITHUB_REPOSITORY')}"
                
                # HTMLæ ¼å¼çš„é‚®ä»¶å†…å®¹
                html_content = f"""
                <html>
                <body>
                    <h2>ğŸš€ å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥</h2>
                    <p><strong>ğŸ”– ä»“åº“:</strong> {os.getenv('GITHUB_REPOSITORY')}</p>
                    <p><strong>ğŸ†” æäº¤:</strong> <a href="https://github.com/{os.getenv('GITHUB_REPOSITORY')}/commit/{os.getenv('GITHUB_SHA')}">{os.getenv('GITHUB_SHA')[:7]}</a></p>
                    <p><strong>ğŸ“¦ æ£€æµ‹åˆ° {len(files)} ä¸ªæ–‡ä»¶æ›´æ–°:</strong></p>
                    <ul>
                """
                
                for file in files:
                    proxy_urls = generate_proxy_urls(file['url'])
                    icon = get_file_icon(file['path'])
                    file_type = get_file_type(file['path'])
                    html_content += f"""
                    <li>
                        <p><strong>{icon} {file_type}: {file['name']}</strong></p>
                        <ul>
                            <li><strong>ç‰ˆæœ¬:</strong> {file['version']}</li>
                            <li><strong>æ›´æ–°æ—¥æœŸ:</strong> {file['date']}</li>
                            <li><strong>ä¸‹è½½åœ°å€:</strong> 
                                <a href="{file['url']}">åŸå§‹åœ°å€</a> | 
                                <a href="{proxy_urls['gh-proxy']}">gh-proxy</a> | 
                                <a href="{proxy_urls['github-speedup']}">github-speedup</a>
                            </li>
                        </ul>
                    </li>
                    """
                
                html_content += """
                    </ul>
                    <p>æ­¤é‚®ä»¶ç”± GitHub Actions è‡ªåŠ¨å‘é€</p>
                </body>
                </html>
                """
                
                # åˆ›å»ºé‚®ä»¶
                msg = MIMEMultipart()
                msg['From'] = smtp_user
                msg['To'] = receiver_email
                msg['Subject'] = subject
                msg.attach(MIMEText(html_content, 'html'))
                
                # ä½¿ç”¨SSLè¿æ¥SMTPæœåŠ¡å™¨
                server = smtplib.SMTP_SSL(smtp_server, smtp_port)
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, receiver_email, msg.as_string())
                server.quit()
                
                print(f"âœ… é‚®ä»¶å·²å‘é€è‡³: {receiver_email}")
                return True
            except Exception as e:
                # æ‰“å°è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                import traceback
                traceback.print_exc()
                print(f"âŒ é‚®ä»¶å‘é€å¤±è´¥: {str(e)}")
                return False
        
        def main():
            print("ğŸš€ å¼€å§‹å®æ—¶ç›‘æ§ç›®å½•å˜æ›´...")
            repo = pygit2.Repository('.')
            
            # è·å–å½“å‰æäº¤
            head_commit = repo.head.peel()
            print(f"å½“å‰æäº¤: {head_commit.id}")
            
            # è·å–çˆ¶æäº¤
            parent_commits = head_commit.parents
            if not parent_commits:
                print("âš ï¸ åˆå§‹æäº¤ - æ— å‰ä¸€ç‰ˆæœ¬")
                return
            
            # ä½¿ç”¨ç¬¬ä¸€ä¸ªçˆ¶æäº¤è¿›è¡Œæ¯”è¾ƒ
            parent_commit = parent_commits[0]
            print(f"çˆ¶æäº¤: {parent_commit.id}")
            
            # è®¡ç®—å·®å¼‚
            diff = repo.diff(parent_commit, head_commit)
            changed_files = []
            
            # è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯ï¼ˆç”¨äºå¢å¼ºç›‘æ§ï¼‰
            current_versions = get_current_versions()
            print(f"å½“å‰ç‰ˆæœ¬ä¿¡æ¯: {json.dumps(current_versions, indent=2)}")
            
            # è§£æå·®å¼‚
            for delta in diff.deltas:
                # åªå¤„ç†æ–°å¢å’Œä¿®æ”¹çš„æ–‡ä»¶ï¼Œå¿½ç•¥åˆ é™¤çš„æ–‡ä»¶
                if delta.status not in (pygit2.GIT_DELTA_ADDED, pygit2.GIT_DELTA_MODIFIED):
                    continue
                
                file_path = delta.new_file.path or delta.old_file.path
                print(f"æ£€æµ‹åˆ°å˜æ›´: {file_path} [çŠ¶æ€: {delta.status}]")
                
                # åªå¤„ç†apkå’Œkernelsç›®å½•ä¸‹çš„æ–‡ä»¶
                if not (file_path.startswith('apk/') or file_path.startswith('kernels/')):
                    continue
                
                # è·å–æ–‡ä»¶å
                filename = os.path.basename(file_path)
                
                # è·å–æ›´æ–°æ—¶é—´ (è½¬æ¢ä¸ºUTCæ—¶é—´)
                commit_time = datetime.utcfromtimestamp(head_commit.commit_time).strftime('%Y-%m-%d %H:%M UTC')
                
                # æ„å»ºåŸå§‹ä¸‹è½½URL
                encoded_path = quote(file_path)
                raw_url = f"https://raw.githubusercontent.com/{os.getenv('GITHUB_REPOSITORY')}/main/{encoded_path}"
                
                # è·å–å‡†ç¡®ç‰ˆæœ¬å·ï¼ˆä¼˜å…ˆä»version.txtï¼‰
                accurate_version = get_accurate_version(filename)
                if accurate_version:
                    version = accurate_version
                    version_source = "version.txt"
                else:
                    # å¦‚æœversion.txtä¸­æ²¡æœ‰ï¼Œå°è¯•ä»æ–‡ä»¶åè§£æ
                    version = "unknown"
                    version_source = "æ–‡ä»¶åè§£æå¤±è´¥"
                    print(f"âš ï¸ æœªåœ¨version.txtä¸­æ‰¾åˆ° {filename} çš„ç‰ˆæœ¬ä¿¡æ¯")
                
                changed_files.append({
                    "path": file_path,
                    "name": filename,
                    "version": version,
                    "date": commit_time,
                    "url": raw_url,
                    "version_source": version_source
                })
            
            if not changed_files:
                print("âœ… æœªæ£€æµ‹åˆ°æ–‡ä»¶å˜æ›´")
                return
            
            print(f"ğŸ“¦ æ£€æµ‹åˆ° {len(changed_files)} ä¸ªæ–‡ä»¶å˜æ›´:")
            for file in changed_files:
                print(f"  - {file['path']} (v{file['version']}, {file['date']}) [æ¥æº: {file['version_source']}]")
            
            # å‘é€åˆ°Telegram
            loop = asyncio.get_event_loop()
            telegram_success = loop.run_until_complete(send_telegram_message(changed_files))
            
            # å‘é€åˆ°é‚®ç®±
            email_receiver = os.getenv("EMAIL_RECEIVER")
            if email_receiver:
                email_success = send_email(changed_files, email_receiver)
            else:
                print("âš ï¸ æœªé…ç½®EMAIL_RECEIVERï¼Œè·³è¿‡é‚®ä»¶é€šçŸ¥")
                email_success = False
            
            if telegram_success:
                print("âœ… Telegramé€šçŸ¥å‘é€æˆåŠŸ!")
            else:
                print("âŒ Telegramé€šçŸ¥å‘é€å¤±è´¥")
            
            if email_success:
                print("âœ… é‚®ä»¶é€šçŸ¥å‘é€æˆåŠŸ!")
            else:
                print("âŒ é‚®ä»¶é€šçŸ¥å‘é€å¤±è´¥")
        
        if __name__ == "__main__":
            main()
        EOF
        
        python directory_monitor.py

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Real-time Directory Monitor"
          repository: ${{ github.repository }}