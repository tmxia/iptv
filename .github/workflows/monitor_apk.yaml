name: Real-time Directory Monitor

on:
  push:
    paths:
      - 'apk/**'
      - 'kernels/**'
      - 'version.txt'
      - 'kernel_versions.json'
    branches: [ main ]
  
  workflow_run:
    workflows: 
      - "NagramX Sync from Source Repository"
      - "BV APK Sync from Source Repository"
      - "GitHub XAPK Download and Sync"
      - "Karing Beta Sync from Source Repository"
      - "MYTV APK Sync from Source Repository"
      - "OK PRO APK Sync from TELEGRAM"
      - "OK APK Sync from Source Repository"
      - "Proxypin Sync from Source Repository"
      - "Simple_live APK Sync from Source Repository"
      - "OpenWrt Kernel Sync from TELEGRAM"
      - "ServerBox Sync from Source Repository"
      - "TV APK Sync from TELEGRAM"
      - "TV NEW APK Sync from TELEGRAM"
      - "Hiddify APK Sync from Source Repository"
      - "Termux APK Sync from Source Repository"
      - "Passwall Packages Sync from Source Repository"
      - "Plus APK Download and Sync"
      - "TAuxiliary APK Sync from TELEGRAM"
    types: [completed]
    branches: [main]

jobs:
  # å‰ç½®éªŒè¯é˜¶æ®µ
  pre-check:
    name: Validate Trigger Conditions
    runs-on: ubuntu-latest
    outputs:
      valid_trigger: ${{ steps.validate.outputs.valid }}
    steps:
      - name: Check trigger validity
        id: validate
        run: |
          # å¯¹äºworkflow_runè§¦å‘
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "::set-output name=valid::false"
              echo "ğŸ›‘ ä¸Šæ¸¸å·¥ä½œæµæœªæˆåŠŸï¼Œç»ˆæ­¢æ‰§è¡Œ"
              exit 0
            fi
          fi
          
          # å¯¹äºpushè§¦å‘ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å®é™…å˜æ›´
          if [[ "${{ github.event_name }}" == "push" ]]; then
            changed_files=$(git diff --name-only HEAD^ HEAD)
            relevant_changes=$(echo "$changed_files" | grep -E 'apk/|kernels/|version.txt|kernel_versions.json' || true)
            
            if [ -z "$relevant_changes" ]; then
              echo "::set-output name=valid::false"
              echo "â­ï¸ æ— ç›¸å…³æ–‡ä»¶å˜æ›´ï¼Œè·³è¿‡æ‰§è¡Œ"
              exit 0
            fi
          fi
          
          echo "::set-output name=valid::true"

  # æ ¸å¿ƒç›‘æ§é˜¶æ®µ
  detect-and-notify:
    needs: pre-check
    if: ${{ needs.pre-check.outputs.valid_trigger == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    concurrency:
      group: monitor-${{ github.ref }}-${{ github.event_name }}-${{ github.event.workflow_run.id || github.sha }}
      cancel-in-progress: false

    steps:
    - name: Checkout with depth
      uses: actions/checkout@v4
      with:
        fetch-depth: 5
        token: ${{ secrets.REPO_PAT }}

    - name: Pull latest changes
      run: git pull origin ${{ github.ref }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake libgit2-dev

    - name: Install pinned Python packages
      run: |
        pip install \
          pygit2==1.14.1 \
          telethon==1.34.0 \
          pytz==2024.1 \
          --no-cache-dir
        
        echo "Installed versions:"
        pip freeze | grep -E 'pygit2|telethon|pytz'

    - name: Run enhanced directory monitor
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL }}
        EMAIL_RECEIVER: ${{ secrets.EMAIL_RECEIVER }}
        SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USER: ${{ secrets.SMTP_USER }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
      run: |
        cat << 'EOF' > enhanced_monitor.py
        # å®Œæ•´çš„Pythonç›‘æ§è„šæœ¬
        import os
        import re
        import time
        import json
        import pygit2
        import asyncio
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        from datetime import datetime
        from pytz import timezone
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from urllib.parse import quote
        
        # ---- é…ç½®å¸¸é‡ ----
        UTC_TZ = timezone('UTC')
        BEIJING_TZ = timezone('Asia/Shanghai')
        VERSION_FILES = {
            'apk/': 'version.txt',
            'kernels/': 'kernel_versions.json'
        }
        ALLOWED_EXTENSIONS = ['.apk', '.zip', '.tar.gz', '.json', '.txt']
        
        # ---- é‡è¯•è£…é¥°å™¨ ----
        def retry(max_attempts=3, delay=1):
            def decorator(func):
                async def async_wrapper(*args, **kwargs):
                    for attempt in range(max_attempts):
                        try:
                            return await func(*args, **kwargs)
                        except Exception as e:
                            if attempt == max_attempts - 1:
                                raise
                            print(f"å°è¯• {attempt+1}/{max_attempts} å¤±è´¥: {str(e)}")
                            await asyncio.sleep(delay * (2 ** attempt))
                return async_wrapper
            return decorator
        
        # ---- ç‰ˆæœ¬ç®¡ç† ----
        class VersionManager:
            _apk_versions = None
            _kernel_versions = None
            
            @classmethod
            def load_apk_versions(cls):
                """åŠ è½½APKç‰ˆæœ¬æ•°æ®"""
                if cls._apk_versions is None:
                    cls._apk_versions = cls._load_version_file('version.txt')
                return cls._apk_versions
            
            @classmethod
            def load_kernel_versions(cls):
                """åŠ è½½å†…æ ¸ç‰ˆæœ¬æ•°æ®"""
                if cls._kernel_versions is None:
                    cls._kernel_versions = cls._load_version_file('kernel_versions.json')
                return cls._kernel_versions
            
            @staticmethod
            def _load_version_file(path):
                """åŠ è½½ç‰ˆæœ¬æ–‡ä»¶"""
                if not os.path.exists(path):
                    return {}
                
                try:
                    with open(path, 'r') as f:
                        if path.endswith('.json'):
                            return json.load(f)
                        # å¤„ç†version.txtæ ¼å¼
                        versions = {}
                        for line in f:
                            if ',' in line:
                                key, value = line.strip().split(',', 1)
                                versions[key] = value
                        return versions
                except Exception as e:
                    print(f"âš ï¸ åŠ è½½ç‰ˆæœ¬æ–‡ä»¶å¤±è´¥ {path}: {str(e)}")
                    return {}
            
            @classmethod
            def reset_cache(cls):
                """é‡ç½®ç¼“å­˜"""
                cls._apk_versions = None
                cls._kernel_versions = None
        
        # ---- å˜æ›´åˆ†æå™¨ ----
        class ChangeAnalyzer:
            def __init__(self, repo_path='.'):
                self.repo = pygit2.Repository(repo_path)
                self.head_commit = self.repo.head.peel()
            
            def get_effective_changes(self):
                """è·å–æœ‰æ•ˆå˜æ›´æ–‡ä»¶"""
                if not self.head_commit.parents:
                    return self._handle_initial_commit()
                
                changes = []
                for parent in self.head_commit.parents:
                    diff = self.repo.diff(parent, self.head_commit)
                    for delta in diff.deltas:
                        if delta.status in (pygit2.GIT_DELTA_ADDED, pygit2.GIT_DELTA_MODIFIED):
                            file_path = delta.new_file.path
                            if file_path not in [c['path'] for c in changes]:
                                changes.append({
                                    'path': file_path,
                                    'status': delta.status
                                })
                return changes
            
            def _handle_initial_commit(self):
                """å¤„ç†åˆå§‹æäº¤"""
                changes = []
                for entry in self.head_commit.tree:
                    changes.append({
                        'path': entry.name,
                        'status': pygit2.GIT_DELTA_ADDED
                    })
                return changes
            
            def get_commit_time(self):
                """è·å–æäº¤æ—¶é—´ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰"""
                utc_time = datetime.utcfromtimestamp(self.head_commit.commit_time)
                utc_time = UTC_TZ.localize(utc_time)
                return utc_time.astimezone(BEIJING_TZ).strftime('%Y-%m-%d %H:%M')
        
        # ---- æ–‡ä»¶å¤„ç†å™¨ ----
        class FileProcessor:
            @staticmethod
            def is_relevant_file(file_path):
                """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ç›¸å…³"""
                return (file_path.startswith(('apk/', 'kernels/')) and 
                        any(file_path.endswith(ext) for ext in ALLOWED_EXTENSIONS))
            
            @staticmethod
            def get_file_info(file_path, commit_time):
                """è·å–æ–‡ä»¶è¯¦ç»†ä¿¡æ¯"""
                filename = os.path.basename(file_path)
                
                # æ£€æŸ¥ç‰ˆæœ¬æ–‡ä»¶æ›´æ–°
                FileProcessor.check_version_file_update(file_path)
                
                # è·å–ç‰ˆæœ¬ä¿¡æ¯
                version_info = FileProcessor.get_version_info(filename, file_path, commit_time)
                
                return {
                    'path': file_path,
                    'name': filename,
                    'version': version_info.get('version', 'æœªçŸ¥ç‰ˆæœ¬'),
                    'date': version_info.get('date', commit_time),
                    'url': f"https://raw.githubusercontent.com/{os.getenv('GITHUB_REPOSITORY')}/main/{quote(file_path)}"
                }
            
            @staticmethod
            def check_version_file_update(file_path):
                """æ£€æŸ¥ç‰ˆæœ¬æ–‡ä»¶æ˜¯å¦éœ€è¦æ›´æ–°"""
                for prefix, vfile in VERSION_FILES.items():
                    if file_path.startswith(prefix):
                        if os.path.exists(vfile) and os.path.getmtime(vfile) > os.path.getmtime(file_path):
                            print(f"ğŸ”„ æ£€æµ‹åˆ°ç‰ˆæœ¬æ–‡ä»¶ {vfile} å·²æ›´æ–°ï¼Œé‡ç½®ç¼“å­˜")
                            VersionManager.reset_cache()
            
            @staticmethod
            def get_version_info(filename, file_path, default_date):
                """è·å–ç‰ˆæœ¬ä¿¡æ¯"""
                # å†…æ ¸æ–‡ä»¶å¤„ç†
                if file_path.startswith('kernels/'):
                    kernel_versions = VersionManager.load_kernel_versions()
                    # å°è¯•å¤šç§åŒ¹é…æ¨¡å¼
                    for pattern in [filename, filename.split('.')[0], filename.replace('-', '_')]:
                        if pattern in kernel_versions:
                            return FileProcessor.parse_version_data(kernel_versions[pattern])
                    
                    # æ¨¡ç³ŠåŒ¹é…
                    for key in kernel_versions:
                        if key in filename:
                            return FileProcessor.parse_version_data(kernel_versions[key])
                
                # APKæ–‡ä»¶å¤„ç†
                apk_versions = VersionManager.load_apk_versions()
                if filename in apk_versions:
                    return FileProcessor.parse_version_data(apk_versions[filename])
                
                return {'version': 'æœªçŸ¥ç‰ˆæœ¬', 'date': default_date}
            
            @staticmethod
            def parse_version_data(data):
                """è§£æç‰ˆæœ¬æ•°æ®"""
                if isinstance(data, dict):
                    return data
                if isinstance(data, str):
                    parts = data.split(',', 1)
                    return {
                        'version': parts[0].strip(),
                        'date': parts[1].strip() if len(parts) > 1 else "æœªçŸ¥æ—¥æœŸ"
                    }
                return {'version': str(data), 'date': "æœªçŸ¥æ—¥æœŸ"}
        
        # ---- é€šçŸ¥æœåŠ¡ ----
        class Notifier:
            @retry()
            async def send_telegram(self, files):
                """å‘é€Telegramé€šçŸ¥"""
                try:
                    api_id = int(os.getenv("TELEGRAM_API_ID"))
                    api_hash = os.getenv("TELEGRAM_API_HASH")
                    session_str = os.getenv("TELEGRAM_SESSION")
                    channel = os.getenv("TELEGRAM_CHANNEL")
                    
                    async with TelegramClient(
                        StringSession(session_str), 
                        api_id, 
                        api_hash
                    ) as client:
                        message = self._build_telegram_message(files)
                        await client.send_message(
                            entity=channel,
                            message=message,
                            parse_mode='md',
                            link_preview=False
                        )
                        return True
                except Exception as e:
                    print(f"âŒ Telegramå‘é€å¤±è´¥: {str(e)}")
                    raise
            
            def send_email(self, files, receiver):
                """å‘é€é‚®ä»¶é€šçŸ¥"""
                try:
                    # é…ç½®æ£€æŸ¥
                    smtp_server = os.getenv("SMTP_SERVER")
                    smtp_port = int(os.getenv("SMTP_PORT", 465))
                    smtp_user = os.getenv("SMTP_USER")
                    smtp_pass = os.getenv("SMTP_PASSWORD")
                    
                    if not all([smtp_server, smtp_user, smtp_pass]):
                        print("âš ï¸ SMTPé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡é‚®ä»¶å‘é€")
                        return False
                    
                    # åˆ›å»ºé‚®ä»¶
                    msg = MIMEMultipart()
                    msg['From'] = smtp_user
                    msg['To'] = receiver
                    msg['Subject'] = f"æ–‡ä»¶æ›´æ–°é€šçŸ¥ - {datetime.now(BEIJING_TZ).strftime('%Y-%m-%d %H:%M')}"
                    
                    # æ„å»ºHTMLå†…å®¹
                    html_content = self._build_email_content(files)
                    msg.attach(MIMEText(html_content, 'html'))
                    
                    # å‘é€é‚®ä»¶
                    with smtplib.SMTP_SSL(smtp_server, smtp_port) as server:
                        server.login(smtp_user, smtp_pass)
                        server.sendmail(smtp_user, receiver, msg.as_string())
                    
                    return True
                except Exception as e:
                    print(f"âŒ é‚®ä»¶å‘é€å¤±è´¥: {str(e)}")
                    return False
            
            def _build_telegram_message(self, files):
                """æ„å»ºTelegramæ¶ˆæ¯"""
                repo = os.getenv("GITHUB_REPOSITORY")
                sha_short = os.getenv("GITHUB_SHA", "")[:7]
                commit_url = f"https://github.com/{repo}/commit/{os.getenv('GITHUB_SHA')}"
                
                message = [
                    "ğŸš€ **å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥**",
                    f"ğŸ”– ä»“åº“: `{repo}`",
                    f"ğŸ†” æäº¤: [{sha_short}]({commit_url})",
                    "",
                    "ğŸ“¦ æ›´æ–°æ–‡ä»¶åˆ—è¡¨:"
                ]
                
                for file in files:
                    icon = "ğŸ“±" if file['path'].endswith('.apk') else "ğŸ“¦"
                    file_type = "åº”ç”¨" if "apk" in file['path'] else "å†…æ ¸"
                    
                    message.append(
                        f"{icon} **{file_type}æ–‡ä»¶**: `{file['name']}`\n"
                        f"  - ç‰ˆæœ¬: `{file['version']}`\n"
                        f"  - æ›´æ–°æ—¶é—´: `{file['date']}` (åŒ—äº¬æ—¶é—´)"
                    )
                
                return "\n".join(message)
            
            def _build_email_content(self, files):
                """æ„å»ºé‚®ä»¶HTMLå†…å®¹"""
                repo = os.getenv("GITHUB_REPOSITORY")
                sha_short = os.getenv("GITHUB_SHA", "")[:7]
                commit_url = f"https://github.com/{repo}/commit/{os.getenv('GITHUB_SHA')}"
                
                html = f"""
                <html>
                <head>
                    <style>
                        body {{ font-family: Arial, sans-serif; line-height: 1.6; }}
                        .header {{ background-color: #f8f9fa; padding: 20px; border-bottom: 1px solid #eaeaea; }}
                        .container {{ max-width: 800px; margin: 0 auto; padding: 20px; }}
                        .file-list {{ margin-top: 20px; }}
                        .file-item {{ border: 1px solid #eaeaea; border-radius: 5px; padding: 15px; margin-bottom: 15px; }}
                        .file-icon {{ font-size: 24px; margin-right: 10px; }}
                        .file-name {{ font-weight: bold; font-size: 18px; }}
                        .file-details {{ margin-left: 35px; }}
                        .commit-link {{ color: #0366d6; text-decoration: none; }}
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>ğŸš€ æ–‡ä»¶æ›´æ–°é€šçŸ¥</h1>
                    </div>
                    <div class="container">
                        <p><strong>ğŸ”– ä»“åº“:</strong> {repo}</p>
                        <p><strong>ğŸ†” æäº¤:</strong> <a href="{commit_url}" class="commit-link">{sha_short}</a></p>
                        <p><strong>ğŸ“… æ£€æµ‹æ—¶é—´:</strong> {datetime.now(BEIJING_TZ).strftime('%Y-%m-%d %H:%M')} (åŒ—äº¬æ—¶é—´)</p>
                        
                        <div class="file-list">
                            <h2>ğŸ“¦ æ›´æ–°æ–‡ä»¶ ({len(files)}ä¸ª)</h2>
                """
                
                for file in files:
                    icon = "ğŸ“±" if file['path'].endswith('.apk') else "ğŸ“¦"
                    file_type = "åº”ç”¨" if "apk" in file['path'] else "å†…æ ¸"
                    
                    html += f"""
                    <div class="file-item">
                        <div>
                            <span class="file-icon">{icon}</span>
                            <span class="file-name">{file['name']}</span>
                        </div>
                        <div class="file-details">
                            <p><strong>ç±»å‹:</strong> {file_type}æ–‡ä»¶</p>
                            <p><strong>ç‰ˆæœ¬:</strong> {file['version']}</p>
                            <p><strong>æ›´æ–°æ—¶é—´:</strong> {file['date']} (åŒ—äº¬æ—¶é—´)</p>
                            <p><strong>ä¸‹è½½åœ°å€:</strong> 
                                <a href="{file['url']}">åŸå§‹åœ°å€</a> | 
                                <a href="https://gh-proxy.com/{file['url']}">gh-proxy</a>
                            </p>
                        </div>
                    </div>
                    """
                
                html += """
                        </div>
                        <p><em>æ­¤é‚®ä»¶ç”± GitHub Actions è‡ªåŠ¨å‘é€</em></p>
                    </div>
                </body>
                </html>
                """
                return html
        
        # ---- ä¸»æµç¨‹ ----
        async def main():
            print("ğŸ”„ å¯åŠ¨å¢å¼ºå‹ç›®å½•ç›‘æ§")
            start_time = time.time()
            
            try:
                # åˆå§‹åŒ–åˆ†æå™¨
                analyzer = ChangeAnalyzer()
                commit_time = analyzer.get_commit_time()
                
                # è·å–å˜æ›´
                changes = analyzer.get_effective_changes()
                if not changes:
                    print("âœ… æœªæ£€æµ‹åˆ°æœ‰æ•ˆå˜æ›´")
                    return
                
                print(f"ğŸ” å‘ç° {len(changes)} ä¸ªå˜æ›´æ–‡ä»¶")
                
                # å¤„ç†æ–‡ä»¶ä¿¡æ¯
                valid_files = []
                for change in changes:
                    if FileProcessor.is_relevant_file(change['path']):
                        file_info = FileProcessor.get_file_info(change['path'], commit_time)
                        valid_files.append(file_info)
                        print(f"  - {change['path']} (v{file_info['version']})")
                
                if not valid_files:
                    print("â„¹ï¸ æ— ç›‘æ§ç›®å½•å†…çš„ç›¸å…³æ–‡ä»¶å˜æ›´")
                    return
                
                # å‘é€é€šçŸ¥
                notifier = Notifier()
                tasks = []
                
                # Telegramé€šçŸ¥
                if all([os.getenv("TELEGRAM_API_ID"), os.getenv("TELEGRAM_API_HASH"), 
                       os.getenv("TELEGRAM_SESSION"), os.getenv("TELEGRAM_CHANNEL")]):
                    tasks.append(notifier.send_telegram(valid_files))
                    print("ğŸ“¤ åŠ å…¥Telegramé€šçŸ¥é˜Ÿåˆ—")
                else:
                    print("âš ï¸ Telegramé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡é€šçŸ¥")
                
                # é‚®ä»¶é€šçŸ¥
                email_receiver = os.getenv("EMAIL_RECEIVER")
                if email_receiver:
                    tasks.append(asyncio.to_thread(notifier.send_email, valid_files, email_receiver))
                    print("ğŸ“§ åŠ å…¥é‚®ä»¶é€šçŸ¥é˜Ÿåˆ—")
                else:
                    print("âš ï¸ æœªé…ç½®é‚®ä»¶æ¥æ”¶è€…ï¼Œè·³è¿‡é‚®ä»¶é€šçŸ¥")
                
                if tasks:
                    print("ğŸš€ å¼€å§‹å‘é€é€šçŸ¥...")
                    results = await asyncio.gather(*tasks, return_exceptions=True)
                    
                    for i, result in enumerate(results):
                        if isinstance(result, Exception):
                            print(f"âŒ é€šçŸ¥ä»»åŠ¡ {i+1} å¤±è´¥: {str(result)}")
                        elif result:
                            print(f"âœ… é€šçŸ¥ä»»åŠ¡ {i+1} æˆåŠŸ")
                
                print(f"ğŸ‰ ç›‘æ§å®Œæˆ! è€—æ—¶: {time.time()-start_time:.2f}ç§’")
                
            except Exception as e:
                print(f"ğŸ”¥ ä¸¥é‡é”™è¯¯: {str(e)}")
                # è¿™é‡Œå¯ä»¥æ·»åŠ é¢å¤–çš„é”™è¯¯é€šçŸ¥é€»è¾‘
                raise
        
        if __name__ == "__main__":
            asyncio.run(main())
        EOF
        
        python enhanced_monitor.py

  # å·¥ä½œæµå†å²æ¸…ç†
  cleanup_self:
    name: Cleanup Workflow History
    runs-on: ubuntu-latest
    needs: detect-and-notify
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Enhanced Real-time Directory Monitor"
          repository: ${{ github.repository }}