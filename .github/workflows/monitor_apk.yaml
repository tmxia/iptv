name: Real-time Directory Monitor

on:
  # æ‰‹åŠ¨è§¦å‘é…ç½®
  workflow_dispatch:
    inputs:
      force-run:
        description: "å¼ºåˆ¶è¿è¡Œï¼ˆå¿½ç•¥å‰ç½®æ£€æŸ¥ï¼‰"
        required: false
        default: "false"
        type: boolean
  
  # è‡ªåŠ¨è§¦å‘é…ç½®
  push:
    paths:
      - 'apk/**'
      - 'kernels/**'
      - 'version.txt'
      - 'kernel_versions.json'
    branches: [ main ]
  
  workflow_run:
    workflows: 
      - "NagramX Sync from Source Repository"
      - "BV APK Sync from Source Repository"
      - "GitHub XAPK Download and Sync"
      - "Karing Beta Sync from Source Repository"
      - "MYTV APK Sync from Source Repository"
      - "OK PRO APK Sync from TELEGRAM"
      - "OK APK Sync from Source Repository"
      - "Proxypin Sync from Source Repository"
      - "Simple_live APK Sync from Source Repository"
      - "OpenWrt Kernel Sync from TELEGRAM"
      - "ServerBox Sync from Source Repository"
      - "TV APK Sync from TELEGRAM"
      - "TV NEW APK Sync from TELEGRAM"
      - "Hiddify APK Sync from Source Repository"
      - "Termux APK Sync from Source Repository"
      - "Passwall Packages Sync from Source Repository"
      - "Plus APK Download and Sync"
      - "TAuxiliary APK Sync from TELEGRAM"
    types: [completed]
    branches: [main]

jobs:
  # å‰ç½®éªŒè¯é˜¶æ®µ
  pre-check:
    name: Validate Trigger Conditions
    runs-on: ubuntu-latest
    outputs:
      valid_trigger: ${{ steps.validate.outputs.valid }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # è·å–æœ€è¿‘2æ¬¡æäº¤ç”¨äºå˜æ›´æ£€æµ‹
          
      - name: Check trigger validity
        id: validate
        run: |
          # å¦‚æœæ˜¯æ‰‹åŠ¨è§¦å‘ä¸”é€‰æ‹©äº†å¼ºåˆ¶è¿è¡Œ
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.force-run }}" == "true" ]]; then
            echo "::set-output name=valid::true"
            echo "ğŸ”§ æ‰‹åŠ¨å¼ºåˆ¶è§¦å‘ï¼Œè·³è¿‡æ‰€æœ‰æ£€æŸ¥"
            exit 0
          fi
          
          # å¯¹äºworkflow_runè§¦å‘
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "::set-output name=valid::false"
              echo "ğŸ›‘ ä¸Šæ¸¸å·¥ä½œæµæœªæˆåŠŸï¼Œç»ˆæ­¢æ‰§è¡Œ"
              exit 0
            else
              echo "::set-output name=valid::true"
              echo "âœ… ä¸Šæ¸¸å·¥ä½œæµæˆåŠŸï¼Œç»§ç»­æ‰§è¡Œ"
              exit 0
            fi
          fi
          
          # å¯¹äºæ‰‹åŠ¨è§¦å‘ï¼ˆéå¼ºåˆ¶æ¨¡å¼ï¼‰å’Œpushè§¦å‘
          echo "ğŸ” æ£€æŸ¥æ–‡ä»¶å˜æ›´..."
          git fetch origin main --depth=2
          
          # è·å–å½“å‰æäº¤å’Œå‰ä¸€ä¸ªæäº¤
          current_sha=$(git rev-parse HEAD)
          parent_sha=$(git rev-parse HEAD^)
          
          # æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„çˆ¶æäº¤
          if [ "$parent_sha" == "$current_sha" ]; then
            echo "â„¹ï¸ æ— çˆ¶æäº¤ï¼ˆå¯èƒ½æ˜¯åˆå§‹æäº¤ï¼‰ï¼Œè§†ä¸ºæ‰€æœ‰æ–‡ä»¶å˜æ›´"
            echo "::set-output name=valid::true"
            exit 0
          fi
          
          # è·å–å˜æ›´æ–‡ä»¶åˆ—è¡¨
          changed_files=$(git diff --name-only $parent_sha $current_sha)
          relevant_changes=$(echo "$changed_files" | grep -E 'apk/|kernels/|version.txt|kernel_versions.json' || true)
          
          if [ -z "$relevant_changes" ]; then
            echo "::set-output name=valid::false"
            echo "â­ï¸ æ— ç›¸å…³æ–‡ä»¶å˜æ›´ï¼Œè·³è¿‡æ‰§è¡Œ"
            echo "å˜æ›´æ–‡ä»¶åˆ—è¡¨:"
            echo "$changed_files"
          else
            echo "::set-output name=valid::true"
            echo "âœ… æ£€æµ‹åˆ°ç›¸å…³æ–‡ä»¶å˜æ›´ï¼Œç»§ç»­æ‰§è¡Œ"
            echo "ç›¸å…³å˜æ›´æ–‡ä»¶:"
            echo "$relevant_changes"
          fi

  # æ ¸å¿ƒç›‘æ§é˜¶æ®µ
  detect-and-notify:
    needs: pre-check
    if: ${{ needs.pre-check.outputs.valid_trigger == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    concurrency:
      group: monitor-${{ github.ref }}-${{ github.event_name }}-${{ github.event.workflow_run.id || github.run_id }}
      cancel-in-progress: false

    steps:
    - name: Checkout with depth
      uses: actions/checkout@v4
      with:
        fetch-depth: 5
        token: ${{ secrets.REPO_PAT }}

    - name: Pull latest changes
      run: git pull origin ${{ github.ref }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake libgit2-dev

    - name: Install pinned Python packages
      run: |
        pip install \
          pygit2==1.14.1 \
          telethon==1.34.0 \
          pytz==2024.1 \
          --no-cache-dir
        
        echo "å·²å®‰è£…çš„ä¾èµ–ç‰ˆæœ¬:"
        pip freeze | grep -E 'pygit2|telethon|pytz'

    - name: Run enhanced directory monitor
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL }}
        EMAIL_RECEIVER: ${{ secrets.EMAIL_RECEIVER }}
        SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USER: ${{ secrets.SMTP_USER }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
      run: |
        cat << 'EOF' > enhanced_monitor.py
        import os
        import re
        import time
        import json
        import pygit2
        import asyncio
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        from datetime import datetime
        from pytz import timezone
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from urllib.parse import quote
        import hashlib
        
        # ---- é…ç½®å¸¸é‡ ----
        UTC_TZ = timezone('UTC')
        BEIJING_TZ = timezone('Asia/Shanghai')
        VERSION_FILES = {
            'apk/': 'version.txt',
            'kernels/': 'kernel_versions.json'
        }
        ALLOWED_EXTENSIONS = ['.apk', '.zip', '.tar.gz', '.json', '.txt']
        
        # ---- é‡è¯•è£…é¥°å™¨ ----
        def retry(max_attempts=3, delay=1):
            def decorator(func):
                async def async_wrapper(*args, **kwargs):
                    for attempt in range(max_attempts):
                        try:
                            return await func(*args, **kwargs)
                        except Exception as e:
                            if attempt == max_attempts - 1:
                                raise
                            print(f"å°è¯• {attempt+1}/{max_attempts} å¤±è´¥: {str(e)}")
                            await asyncio.sleep(delay * (2 ** attempt))
                return async_wrapper
            return decorator
        
        # ---- ç‰ˆæœ¬ç®¡ç† ----
        class VersionManager:
            _apk_versions = None
            _kernel_versions = None
            
            @classmethod
            def load_apk_versions(cls):
                """åŠ è½½APKç‰ˆæœ¬æ•°æ®"""
                if cls._apk_versions is None:
                    cls._apk_versions = cls._load_version_file('version.txt')
                return cls._apk_versions
            
            @classmethod
            def load_kernel_versions(cls):
                """åŠ è½½å†…æ ¸ç‰ˆæœ¬æ•°æ®"""
                if cls._kernel_versions is None:
                    cls._kernel_versions = cls._load_version_file('kernel_versions.json')
                return cls._kernel_versions
            
            @staticmethod
            def _load_version_file(path):
                """åŠ è½½ç‰ˆæœ¬æ–‡ä»¶"""
                if not os.path.exists(path):
                    return {}
                
                try:
                    with open(path, 'r') as f:
                        if path.endswith('.json'):
                            return json.load(f)
                        # å¤„ç†version.txtæ ¼å¼
                        versions = {}
                        for line in f:
                            if ',' in line:
                                key, value = line.strip().split(',', 1)
                                versions[key] = value
                        return versions
                except Exception as e:
                    print(f"âš ï¸ åŠ è½½ç‰ˆæœ¬æ–‡ä»¶å¤±è´¥ {path}: {str(e)}")
                    return {}
            
            @classmethod
            def reset_cache(cls):
                """é‡ç½®ç¼“å­˜"""
                cls._apk_versions = None
                cls._kernel_versions = None
        
        # ---- æ–‡ä»¶å†…å®¹å˜æ›´æ£€æµ‹ ----
        class FileChangeDetector:
            @staticmethod
            def calculate_file_hash(file_path):
                """è®¡ç®—æ–‡ä»¶å†…å®¹çš„SHA256å“ˆå¸Œå€¼"""
                if not os.path.exists(file_path):
                    return None
                
                try:
                    with open(file_path, 'rb') as f:
                        return hashlib.sha256(f.read()).hexdigest()
                except Exception as e:
                    print(f"âš ï¸ æ— æ³•è®¡ç®—æ–‡ä»¶å“ˆå¸Œ {file_path}: {str(e)}")
                    return None
            
            @staticmethod
            def has_file_content_changed(file_path, parent_commit, head_commit):
                """æ£€æŸ¥æ–‡ä»¶å†…å®¹æ˜¯å¦å®é™…å‘ç”Ÿå˜åŒ–"""
                # è·å–å½“å‰æ–‡ä»¶å†…å®¹å“ˆå¸Œ
                current_hash = FileChangeDetector.calculate_file_hash(file_path)
                if not current_hash:
                    return False
                
                # è·å–çˆ¶æäº¤ä¸­çš„æ–‡ä»¶å†…å®¹å“ˆå¸Œ
                try:
                    parent_blob = parent_commit.tree[file_path]
                    parent_content = parent_blob.data
                    parent_hash = hashlib.sha256(parent_content).hexdigest()
                except KeyError:
                    # æ–‡ä»¶åœ¨çˆ¶æäº¤ä¸­ä¸å­˜åœ¨ï¼ˆæ–°å¢æ–‡ä»¶ï¼‰
                    return True
                except Exception as e:
                    print(f"âš ï¸ æ— æ³•è·å–çˆ¶æäº¤æ–‡ä»¶å†…å®¹ {file_path}: {str(e)}")
                    return True
                
                return current_hash != parent_hash
        
        # ---- å˜æ›´åˆ†æå™¨å¢å¼ºç‰ˆ ----
        class EnhancedChangeAnalyzer:
            def __init__(self, repo_path='.'):
                self.repo = pygit2.Repository(repo_path)
                self.head_commit = self.repo.head.peel()
            
            def get_effective_changes(self):
                """è·å–æœ‰æ•ˆå˜æ›´æ–‡ä»¶ï¼ˆåŒ…æ‹¬å†…å®¹å˜åŒ–ï¼‰"""
                if not self.head_commit.parents:
                    return self._handle_initial_commit()
                
                # ä½¿ç”¨ç¬¬ä¸€ä¸ªçˆ¶æäº¤è¿›è¡Œæ¯”è¾ƒ
                parent_commit = self.head_commit.parents[0]
                changes = []
                
                # è®¡ç®—å·®å¼‚
                diff = self.repo.diff(parent_commit, self.head_commit)
                
                for delta in diff.deltas:
                    if delta.status in (pygit2.GIT_DELTA_ADDED, pygit2.GIT_DELTA_MODIFIED):
                        file_path = delta.new_file.path
                        
                        # æ£€æŸ¥æ–‡ä»¶å†…å®¹æ˜¯å¦å®é™…å˜åŒ–
                        if FileChangeDetector.has_file_content_changed(file_path, parent_commit, self.head_commit):
                            changes.append({
                                'path': file_path,
                                'status': delta.status
                            })
                        else:
                            print(f"  - è·³è¿‡: {file_path} (å†…å®¹æœªå˜åŒ–)")
                
                return changes
            
            def _handle_initial_commit(self):
                """å¤„ç†åˆå§‹æäº¤"""
                changes = []
                for entry in self.head_commit.tree:
                    file_path = entry.name
                    if self.is_relevant_file(file_path):
                        changes.append({
                            'path': file_path,
                            'status': pygit2.GIT_DELTA_ADDED
                        })
                return changes
            
            @staticmethod
            def is_relevant_file(file_path):
                """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦åœ¨ç›‘æ§èŒƒå›´å†…"""
                return (file_path.startswith(('apk/', 'kernels/')) and \
                       any(file_path.endswith(ext) for ext in ALLOWED_EXTENSIONS)
            
            def get_commit_time(self):
                """è·å–æäº¤æ—¶é—´ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰"""
                utc_time = datetime.utcfromtimestamp(self.head_commit.commit_time)
                utc_time = UTC_TZ.localize(utc_time)
                return utc_time.astimezone(BEIJING_TZ).strftime('%Y-%m-%d %H:%M')
        
        # ---- æ–‡ä»¶å¤„ç†å™¨å¢å¼ºç‰ˆ ----
        class EnhancedFileProcessor:
            @staticmethod
            def get_file_info(file_path, commit_time):
                """è·å–æ–‡ä»¶è¯¦ç»†ä¿¡æ¯ï¼ˆå¢å¼ºç‰ˆæœ¬æ£€æµ‹ï¼‰"""
                filename = os.path.basename(file_path)
                
                # æ£€æŸ¥ç‰ˆæœ¬æ–‡ä»¶æ›´æ–°
                EnhancedFileProcessor.check_version_file_update(file_path)
                
                # è·å–ç‰ˆæœ¬ä¿¡æ¯
                version_info = EnhancedFileProcessor.get_version_info(filename, file_path, commit_time)
                
                return {
                    'path': file_path,
                    'name': filename,
                    'version': version_info.get('version', 'æœªçŸ¥ç‰ˆæœ¬'),
                    'date': version_info.get('date', commit_time),
                    'url': f"https://raw.githubusercontent.com/{os.getenv('GITHUB_REPOSITORY')}/main/{quote(file_path)}"
                }
            
            @staticmethod
            def check_version_file_update(file_path):
                """æ£€æŸ¥ç‰ˆæœ¬æ–‡ä»¶æ˜¯å¦éœ€è¦æ›´æ–°"""
                for prefix, vfile in VERSION_FILES.items():
                    if file_path.startswith(prefix):
                        if os.path.exists(vfile) and os.path.getmtime(vfile) > os.path.getmtime(file_path):
                            print(f"ğŸ”„ æ£€æµ‹åˆ°ç‰ˆæœ¬æ–‡ä»¶ {vfile} å·²æ›´æ–°ï¼Œé‡ç½®ç¼“å­˜")
                            VersionManager.reset_cache()
            
            @staticmethod
            def get_version_info(filename, file_path, default_date):
                """è·å–ç‰ˆæœ¬ä¿¡æ¯ï¼ˆå¢å¼ºåŒ¹é…é€»è¾‘ï¼‰"""
                # å†…æ ¸æ–‡ä»¶å¤„ç†
                if file_path.startswith('kernels/'):
                    kernel_versions = VersionManager.load_kernel_versions()
                    
                    # å°è¯•å¤šç§åŒ¹é…æ¨¡å¼
                    patterns = [
                        filename,
                        filename.split('.')[0],
                        filename.replace('-', '_'),
                        filename.split('_')[0],
                        '_'.join(filename.split('_')[:2])
                    ]
                    
                    for pattern in patterns:
                        if pattern in kernel_versions:
                            return EnhancedFileProcessor.parse_version_data(kernel_versions[pattern])
                    
                    # æ¨¡ç³ŠåŒ¹é…
                    for key in kernel_versions:
                        if key in filename:
                            return EnhancedFileProcessor.parse_version_data(kernel_versions[key])
                    
                    # å°è¯•ä»æ–‡ä»¶åä¸­æå–ç‰ˆæœ¬
                    version_match = re.search(r'(\d+\.\d+\.\d+)', filename)
                    if version_match:
                        return {
                            'version': version_match.group(1),
                            'date': default_date
                        }
                
                # APKæ–‡ä»¶å¤„ç†
                apk_versions = VersionManager.load_apk_versions()
                if filename in apk_versions:
                    return EnhancedFileProcessor.parse_version_data(apk_versions[filename])
                
                # å°è¯•ä»æ–‡ä»¶åä¸­æå–ç‰ˆæœ¬
                version_match = re.search(r'[vV]?(\d+\.\d+\.\d+)', filename)
                if version_match:
                    return {
                        'version': version_match.group(1),
                        'date': default_date
                    }
                
                return {'version': 'æœªçŸ¥ç‰ˆæœ¬', 'date': default_date}
            
            @staticmethod
            def parse_version_data(data):
                """è§£æç‰ˆæœ¬æ•°æ®"""
                if isinstance(data, dict):
                    return data
                if isinstance(data, str):
                    parts = data.split(',', 1)
                    return {
                        'version': parts[0].strip(),
                        'date': parts[1].strip() if len(parts) > 1 else "æœªçŸ¥æ—¥æœŸ"
                    }
                return {'version': str(data), 'date': "æœªçŸ¥æ—¥æœŸ"}
        
        # ---- é€šçŸ¥æœåŠ¡ ----
        class Notifier:
            @retry()
            async def send_telegram(self, files):
                """å‘é€Telegramé€šçŸ¥"""
                try:
                    api_id = int(os.getenv("TELEGRAM_API_ID"))
                    api_hash = os.getenv("TELEGRAM_API_HASH")
                    session_str = os.getenv("TELEGRAM_SESSION")
                    channel = os.getenv("TELEGRAM_CHANNEL")
                    
                    async with TelegramClient(
                        StringSession(session_str), 
                        api_id, 
                        api_hash
                    ) as client:
                        message = self._build_telegram_message(files)
                        await client.send_message(
                            entity=channel,
                            message=message,
                            parse_mode='md',
                            link_preview=False
                        )
                        return True
                except Exception as e:
                    print(f"âŒ Telegramå‘é€å¤±è´¥: {str(e)}")
                    raise
            
            def send_email(self, files, receiver):
                """å‘é€é‚®ä»¶é€šçŸ¥"""
                try:
                    # é…ç½®æ£€æŸ¥
                    smtp_server = os.getenv("SMTP_SERVER")
                    smtp_port = int(os.getenv("SMTP_PORT", 465))
                    smtp_user = os.getenv("SMTP_USER")
                    smtp_pass = os.getenv("SMTP_PASSWORD")
                    
                    if not all([smtp_server, smtp_user, smtp_pass]):
                        print("âš ï¸ SMTPé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡é‚®ä»¶å‘é€")
                        return False
                    
                    # åˆ›å»ºé‚®ä»¶
                    msg = MIMEMultipart()
                    msg['From'] = smtp_user
                    msg['To'] = receiver
                    msg['Subject'] = f"æ–‡ä»¶æ›´æ–°é€šçŸ¥ - {datetime.now(BEIJING_TZ).strftime('%Y-%m-%d %H:%M')}"
                    
                    # æ„å»ºHTMLå†…å®¹
                    html_content = self._build_email_content(files)
                    msg.attach(MIMEText(html_content, 'html'))
                    
                    # å‘é€é‚®ä»¶
                    with smtplib.SMTP_SSL(smtp_server, smtp_port) as server:
                        server.login(smtp_user, smtp_pass)
                        server.sendmail(smtp_user, receiver, msg.as_string())
                    
                    return True
                except Exception as e:
                    print(f"âŒ é‚®ä»¶å‘é€å¤±è´¥: {str(e)}")
                    return False
            
            def _build_telegram_message(self, files):
                """æ„å»ºTelegramæ¶ˆæ¯"""
                repo = os.getenv("GITHUB_REPOSITORY")
                sha_short = os.getenv("GITHUB_SHA", "")[:7]
                commit_url = f"https://github.com/{repo}/commit/{os.getenv('GITHUB_SHA')}"
                
                message = [
                    "ğŸš€ **å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥**",
                    f"ğŸ”– ä»“åº“: `{repo}`",
                    f"ğŸ†” æäº¤: [{sha_short}]({commit_url})",
                    "",
                    "ğŸ“¦ æ›´æ–°æ–‡ä»¶åˆ—è¡¨:"
                ]
                
                for file in files:
                    icon = "ğŸ“±" if file['path'].endswith('.apk') else "ğŸ“¦"
                    file_type = "åº”ç”¨" if "apk" in file['path'] else "å†…æ ¸"
                    
                    message.append(
                        f"{icon} **{file_type}æ–‡ä»¶**: `{file['name']}`\n"
                        f"  - ç‰ˆæœ¬: `{file['version']}`\n"
                        f"  - æ›´æ–°æ—¶é—´: `{file['date']}` (åŒ—äº¬æ—¶é—´)"
                    )
                
                return "\n".join(message)
            
            def _build_email_content(self, files):
                """æ„å»ºé‚®ä»¶HTMLå†…å®¹"""
                repo = os.getenv("GITHUB_REPOSITORY")
                sha_short = os.getenv("GITHUB_SHA", "")[:7]
                commit_url = f"https://github.com/{repo}/commit/{os.getenv('GITHUB_SHA')}"
                detection_time = datetime.now(BEIJING_TZ).strftime('%Y-%m-%d %H:%M')
                
                html = f"""
                <html>
                <head>
                    <style>
                        body {{ font-family: Arial, sans-serif; line-height: 1.6; }}
                        .header {{ background-color: #f8f9fa; padding: 20px; border-bottom: 1px solid #eaeaea; }}
                        .container {{ max-width: 800px; margin: 0 auto; padding: 20px; }}
                        .file-list {{ margin-top: 20px; }}
                        .file-item {{ border: 1px solid #eaeaea; border-radius: 5px; padding: 15px; margin-bottom: 15px; }}
                        .file-icon {{ font-size: 24px; margin-right: 10px; }}
                        .file-name {{ font-weight: bold; font-size: 18px; }}
                        .file-details {{ margin-left: 35px; }}
                        .commit-link {{ color: #0366d6; text-decoration: none; }}
                        .section-title {{ margin-top: 25px; padding-bottom: 10px; border-bottom: 1px solid #eee; }}
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>ğŸš€ æ–‡ä»¶æ›´æ–°é€šçŸ¥</h1>
                    </div>
                    <div class="container">
                        <div class="section-title">
                            <h2>ä»“åº“ä¿¡æ¯</h2>
                        </div>
                        <p><strong>ğŸ”– ä»“åº“:</strong> {repo}</p>
                        <p><strong>ğŸ†” æäº¤:</strong> <a href="{commit_url}" class="commit-link">{sha_short}</a></p>
                        <p><strong>ğŸ“… æ£€æµ‹æ—¶é—´:</strong> {detection_time} (åŒ—äº¬æ—¶é—´)</p>
                        
                        <div class="section-title">
                            <h2>ğŸ“¦ æ›´æ–°æ–‡ä»¶ ({len(files)}ä¸ª)</h2>
                        </div>
                """
                
                for file in files:
                    icon = "ğŸ“±" if file['path'].endswith('.apk') else "ğŸ“¦"
                    file_type = "åº”ç”¨" if "apk" in file['path'] else "å†…æ ¸"
                    
                    # ç”Ÿæˆä»£ç†é“¾æ¥
                    gh_proxy_url = f"https://gh-proxy.com/{file['url']}"
                    github_speedup_url = f"https://github-speedup.com/{file['url']}"
                    
                    html += f"""
                    <div class="file-item">
                        <div>
                            <span class="file-icon">{icon}</span>
                            <span class="file-name">{file['name']}</span>
                        </div>
                        <div class="file-details">
                            <p><strong>ç±»å‹:</strong> {file_type}æ–‡ä»¶</p>
                            <p><strong>ç‰ˆæœ¬:</strong> {file['version']}</p>
                            <p><strong>æ›´æ–°æ—¶é—´:</strong> {file['date']} (åŒ—äº¬æ—¶é—´)</p>
                            <p><strong>ä¸‹è½½åœ°å€:</strong> 
                                <a href="{file['url']}">åŸå§‹åœ°å€</a> | 
                                <a href="{gh_proxy_url}">gh-proxy</a> | 
                                <a href="{github_speedup_url}">github-speedup</a>
                            </p>
                        </div>
                    </div>
                    """
                
                html += """
                        <div class="section-title">
                            <h2>ç³»ç»Ÿä¿¡æ¯</h2>
                        </div>
                        <p><em>æ­¤é‚®ä»¶ç”± GitHub Actions å·¥ä½œæµè‡ªåŠ¨å‘é€</em></p>
                        <p><strong>å·¥ä½œæµåç§°:</strong> Enhanced Real-time Directory Monitor</p>
                        <p><strong>è§¦å‘æ–¹å¼:</strong> ${{ github.event_name }}</p>
                    </div>
                </body>
                </html>
                """
                return html
        
        # ---- ä¸»æµç¨‹å¢å¼ºç‰ˆ ----
        async def enhanced_main():
            print("ğŸ”„ å¯åŠ¨å¢å¼ºå‹ç›®å½•ç›‘æ§")
            start_time = time.time()
            
            try:
                # åˆå§‹åŒ–åˆ†æå™¨
                analyzer = EnhancedChangeAnalyzer()
                commit_time = analyzer.get_commit_time()
                print(f"ğŸ—“ï¸ æäº¤æ—¶é—´ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰: {commit_time}")
                
                # è·å–å˜æ›´
                changes = analyzer.get_effective_changes()
                if not changes:
                    print("âœ… æœªæ£€æµ‹åˆ°æœ‰æ•ˆå˜æ›´")
                    return
                
                print(f"ğŸ” å‘ç° {len(changes)} ä¸ªå˜æ›´æ–‡ä»¶")
                for change in changes:
                    print(f"  - {change['path']} (çŠ¶æ€: {change['status']})")
                
                # å¤„ç†æ–‡ä»¶ä¿¡æ¯
                valid_files = []
                for change in changes:
                    if analyzer.is_relevant_file(change['path']):
                        file_info = EnhancedFileProcessor.get_file_info(change['path'], commit_time)
                        valid_files.append(file_info)
                        print(f"  - æœ‰æ•ˆå˜æ›´: {change['path']} (v{file_info['version']})")
                    else:
                        print(f"  - è·³è¿‡: {change['path']} (éç›‘æ§æ–‡ä»¶)")
                
                if not valid_files:
                    print("â„¹ï¸ æ— ç›‘æ§ç›®å½•å†…çš„ç›¸å…³æ–‡ä»¶å˜æ›´")
                    return
                
                # å‘é€é€šçŸ¥
                notifier = Notifier()
                tasks = []
                
                # Telegramé€šçŸ¥
                telegram_enabled = all([
                    os.getenv("TELEGRAM_API_ID"), 
                    os.getenv("TELEGRAM_API_HASH"),
                    os.getenv("TELEGRAM_SESSION"), 
                    os.getenv("TELEGRAM_CHANNEL")
                ])
                
                if telegram_enabled:
                    tasks.append(notifier.send_telegram(valid_files))
                    print("ğŸ“¤ åŠ å…¥Telegramé€šçŸ¥é˜Ÿåˆ—")
                else:
                    print("âš ï¸ Telegramé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡é€šçŸ¥")
                
                # é‚®ä»¶é€šçŸ¥
                email_receiver = os.getenv("EMAIL_RECEIVER")
                if email_receiver:
                    tasks.append(asyncio.to_thread(notifier.send_email, valid_files, email_receiver))
                    print("ğŸ“§ åŠ å…¥é‚®ä»¶é€šçŸ¥é˜Ÿåˆ—")
                else:
                    print("âš ï¸ æœªé…ç½®é‚®ä»¶æ¥æ”¶è€…ï¼Œè·³è¿‡é‚®ä»¶é€šçŸ¥")
                
                if tasks:
                    print("ğŸš€ å¼€å§‹å‘é€é€šçŸ¥...")
                    results = await asyncio.gather(*tasks, return_exceptions=True)
                    
                    # å¤„ç†é€šçŸ¥ç»“æœ
                    for i, result in enumerate(results):
                        if isinstance(result, Exception):
                            print(f"âŒ é€šçŸ¥ä»»åŠ¡ {i+1} å¤±è´¥: {str(result)}")
                        elif result:
                            print(f"âœ… é€šçŸ¥ä»»åŠ¡ {i+1} æˆåŠŸ")
                        else:
                            print(f"âš ï¸ é€šçŸ¥ä»»åŠ¡ {i+1} è¿”å›æœªçŸ¥ç»“æœ")
                else:
                    print("â„¹ï¸ æ— æœ‰æ•ˆé€šçŸ¥ä»»åŠ¡")
                
                print(f"ğŸ‰ ç›‘æ§å®Œæˆ! è€—æ—¶: {time.time()-start_time:.2f}ç§’")
                
            except Exception as e:
                print(f"ğŸ”¥ ä¸¥é‡é”™è¯¯: {str(e)}")
                # è¿™é‡Œå¯ä»¥æ·»åŠ é¢å¤–çš„é”™è¯¯é€šçŸ¥é€»è¾‘
                raise
        
        if __name__ == "__main__":
            asyncio.run(enhanced_main())
        EOF
        
        python enhanced_monitor.py

  # å·¥ä½œæµå†å²æ¸…ç†
  cleanup_self:
    name: Cleanup Workflow History
    runs-on: ubuntu-latest
    needs: detect-and-notify
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Real-time Directory Monitor"
          repository: ${{ github.repository }}