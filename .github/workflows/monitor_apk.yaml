name: Real-time APK/ZIP Directory Monitor

on:
  push:
    paths:
      - 'apk/**'  # 监控所有子目录
    branches: [ main ]

jobs:
  detect-and-notify:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
    - name: Checkout repository (深度克隆)
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.ref }}

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake libgit2-dev
        pip install pygit2 httpx

    - name: Run enhanced detection
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHANNEL_ID: ${{ secrets.TELEGRAM_CHANNEL_ID }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
      run: |
        cat << 'EOF' > apk_monitor.py
        import os
        import re
        import pygit2
        import httpx
        import json
        from datetime import datetime
        from urllib.parse import quote
        
        # 增强版版本号提取
        def extract_version(filename):
            patterns = [
                r'[vV]?(\d+\.\d+(?:\.\d+)?)(?:[-_](beta|alpha|rc|preview)\d*)?',  # v9.4, v1.2.3
                r'(\d+)_(\d+)',  # 9_4
                r'[^\d]*(\d+)[^\d]*(\d+)'  # 爱美化9.4
            ]
            
            for pattern in patterns:
                match = re.search(pattern, filename)
                if match:
                    # 处理 xx_yy 格式
                    if len(match.groups()) >= 2 and match.group(2):
                        return f"{match.group(1)}.{match.group(2)}"
                    return match.group(1)
            return "unknown"
        
        # 处理中文文件名
        def safe_filename(filename):
            try:
                return filename.encode('latin1').decode('utf-8')
            except:
                return filename
        
        # 文件大小格式化
        def format_size(size):
            if size > 1024 * 1024:
                return f"{size/(1024*1024):.1f} MB"
            if size > 1024:
                return f"{size/1024:.1f} KB"
            return f"{size} bytes"
        
        def main():
            print("🚀 开始监控APK目录变更...")
            repo = pygit2.Repository('.')
            
            # 获取当前提交
            head_commit = repo.head.peel()
            print(f"当前提交: {head_commit.id}")
            
            # 获取父提交（处理初始提交情况）
            parent_commit = head_commit.parents[0] if head_commit.parents else None
            
            changed_files = []
            
            if parent_commit:
                print(f"父提交: {parent_commit.id}")
                diff = repo.diff(parent_commit, head_commit)
            else:
                print("⚠️ 初始提交 - 检测所有文件")
                diff = head_commit.tree.diff_to_tree(swap=True)
            
            # 解析差异
            for delta in diff.deltas:
                file_path = delta.new_file.path or delta.old_file.path
                print(f"检测到变更: {file_path} [状态: {delta.status}]")
                
                # 只处理apk目录下的文件
                if not file_path.startswith('apk/'):
                    continue
                
                # 处理中文路径
                try:
                    file_path = file_path.encode('latin1').decode('utf8')
                except:
                    pass
                
                filename = safe_filename(os.path.basename(file_path))
                file_ext = os.path.splitext(filename)[1][1:].upper() if '.' in filename else "文件"
                
                # 获取文件元数据
                try:
                    entry = head_commit.tree[file_path]
                    blob = repo[entry.id]
                    file_size = format_size(blob.size)
                except:
                    file_size = "未知大小"
                
                # 获取提交时间
                commit_time = datetime.utcfromtimestamp(head_commit.commit_time).strftime('%Y-%m-%d %H:%M UTC')
                
                # 构建下载URL（处理特殊字符）
                encoded_path = quote(file_path)
                raw_url = f"https://raw.githubusercontent.com/{os.getenv('GITHUB_REPOSITORY')}/main/{encoded_path}"
                
                changed_files.append({
                    "name": filename,
                    "path": file_path,
                    "type": file_ext,
                    "version": extract_version(filename),
                    "size": file_size,
                    "date": commit_time,
                    "url": raw_url
                })
            
            if not changed_files:
                print("✅ 未检测到APK/ZIP文件变更")
                return
            
            print(f"📦 检测到 {len(changed_files)} 个文件变更:")
            for file in changed_files:
                print(f"  - {file['name']} (v{file['version']})")
            
            # 发送Telegram通知
            bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
            channel_id = os.getenv("TELEGRAM_CHANNEL_ID")
            
            if not bot_token or not channel_id:
                print("❌ Telegram凭据未配置!")
                return
            
            # 构建消息
            message = f"📱 **APK目录更新通知**\n\n"
            message += f"🔖 仓库: `{os.getenv('GITHUB_REPOSITORY')}`\n"
            message += f"🆔 提交: [{os.getenv('GITHUB_SHA')[:7]}](https://github.com/{os.getenv('GITHUB_REPOSITORY')}/commit/{os.getenv('GITHUB_SHA')})\n\n"
            message += f"📦 检测到 {len(changed_files)} 个文件更新:\n\n"
            
            for file in changed_files:
                message += f"📄 **{file['name']}**\n"
                message += f"  - 类型: `{file['type']}`\n"
                message += f"  - 版本: `{file['version']}`\n"
                message += f"  - 大小: `{file['size']}`\n"
                message += f"  - 更新: `{file['date']}`\n"
                message += f"  - [下载文件]({file['url']})\n\n"
            
            message += f"🔗 [查看仓库目录](https://github.com/{os.getenv('GITHUB_REPOSITORY')}/tree/main/apk)"
            
            # 发送请求
            api_url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
            payload = {
                "chat_id": channel_id,
                "text": message,
                "parse_mode": "Markdown",
                "disable_web_page_preview": True
            }
            
            try:
                response = httpx.post(api_url, json=payload, timeout=10.0)
                if response.status_code == 200:
                    print("✅ Telegram通知发送成功!")
                else:
                    print(f"❌ Telegram发送失败: {response.status_code} - {response.text}")
            except Exception as e:
                print(f"❌ 请求异常: {str(e)}")
        
        if __name__ == "__main__":
            main()
        EOF
        
        python apk_monitor.py