name: Real-time Directory Monitor

on:
  push:
    paths:
      - 'apk/**'
      - 'kernels/**'
      - 'version.txt'
      - 'kernel_versions.json'
    branches: [ main ]
  workflow_run:
    workflows: ["NagramX Sync from Source Repository", "BV APK Sync from Source Repository", "GitHub XAPK Download and Sync", "Karing Beta Sync from Source Repository", "MYTV APK Sync from Source Repository", "OK PRO APK Sync from TELEGRAM", "OK APK Sync from Source Repository", "Proxypin Sync from Source Repository", "Simple_live APK Sync from Source Repository", "OpenWrt Kernel Sync from TELEGRAM", "ServerBox Sync from Source Repository", "TV APK Sync from TELEGRAM", "TV NEW APK Sync from TELEGRAM", "Hiddify APK Sync from Source Repository", "Termux APK Sync from Source Repository", "Passwall Packages Sync from Source Repository",  "Plus APK Download and Sync", "TAuxiliary APK Sync from TELEGRAM"]
    types: [completed]
  workflow_dispatch:

jobs:
  detect-and-notify:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    concurrency: 
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.REPO_PAT }}

    - name: è·å–æœ€æ–°å˜æ›´
      run: git pull origin ${{ github.ref }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake libgit2-dev
        pip install telethon pygit2 pytz

    - name: Run enhanced detection script
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL }}
        EMAIL_RECEIVER: ${{ secrets.EMAIL_RECEIVER }}
        SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USER: ${{ secrets.SMTP_USER }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}
      run: |
        cat << 'EOF' > directory_monitor.py
        import os
        import re
        import pygit2
        import asyncio
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        from datetime import datetime
        from pytz import timezone
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from urllib.parse import quote
        import json
        
        # è®¾ç½®æ—¶åŒº
        UTC_TZ = timezone('UTC')
        BEIJING_TZ = timezone('Asia/Shanghai')
        
        # è·å–å†…æ ¸ç‰ˆæœ¬ä¿¡æ¯
        def get_kernel_versions():
            """ä»kernel_versions.jsonè·å–å†…æ ¸ç‰ˆæœ¬ä¿¡æ¯"""
            kernel_version_path = "kernel_versions.json"
            if os.path.exists(kernel_version_path):
                try:
                    with open(kernel_version_path, "r") as f:
                        return json.load(f)
                except Exception as e:
                    print(f"âŒ è§£ækernel_versions.jsonå¤±è´¥: {str(e)}")
            return {}
        
        # è·å–å‡†ç¡®ç‰ˆæœ¬å·
        def get_accurate_version(filename, file_path):
            """
            è·å–æ–‡ä»¶çš„å‡†ç¡®ç‰ˆæœ¬ä¿¡æ¯
            apkæ–‡ä»¶: ä»version.txtè·å–
            kernelsæ–‡ä»¶: ä»kernel_versions.jsonè·å–
            """
            # å¤„ç†å†…æ ¸æ–‡ä»¶
            if file_path.startswith('kernels/'):
                kernel_versions = get_kernel_versions()
                
                # ä»æ–‡ä»¶åæå–ç»„å (æ ¼å¼: openwrt_flippy6.1_6.1.141-flippy-93+o.zip)
                match = re.match(r'^([a-zA-Z0-9_]+)_(\d+\..*)\.zip$', filename)
                if match:
                    group = match.group(1)
                    file_version = match.group(2)
                    
                    # åœ¨ç‰ˆæœ¬æ•°æ®ä¸­æŸ¥æ‰¾ç»„
                    if group in kernel_versions:
                        version_data = kernel_versions[group]
                        return {
                            "version": version_data.get("version", file_version),
                            "date": version_data.get("date", "æœªçŸ¥æ—¥æœŸ")
                        }
                    else:
                        print(f"âš ï¸ kernel_versions.jsonä¸­æœªæ‰¾åˆ°ç»„: {group}")
                
                # å¦‚æœæ— æ³•è§£ææ–‡ä»¶åï¼Œè¿”å›é»˜è®¤å€¼
                return {
                    "version": "æœªçŸ¥ç‰ˆæœ¬",
                    "date": "æœªçŸ¥æ—¥æœŸ"
                }
            
            # å¤„ç†APKæ–‡ä»¶
            version_path = "version.txt"
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        version_data = json.load(f)
                    
                    # æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶å
                    if filename in version_data:
                        version_info = version_data[filename]
                        if isinstance(version_info, str):
                            if ',' in version_info:
                                version, date = version_info.split(',', 1)
                                return {"version": version, "date": date}
                            return {"version": version_info, "date": "æœªçŸ¥æ—¥æœŸ"}
                        elif isinstance(version_info, dict):
                            return {
                                "version": version_info.get("version", "æœªçŸ¥ç‰ˆæœ¬"),
                                "date": version_info.get("date", "æœªçŸ¥æ—¥æœŸ")
                            }
                except Exception as e:
                    print(f"âŒ è§£æversion.txtå¤±è´¥: {str(e)}")
            
            return None
        
        def generate_proxy_urls(raw_url):
            """ç”Ÿæˆä»£ç†ä¸‹è½½é“¾æ¥"""
            return {
                "gh-proxy": f"https://gh-proxy.com/{raw_url}",
                "github-speedup": f"https://github-speedup.com/{raw_url}"
            }
        
        def get_file_type(path):
            """æ ¹æ®è·¯å¾„ç¡®å®šæ–‡ä»¶ç±»å‹"""
            if path.startswith('apk/'):
                return "App File"
            elif path.startswith('kernels/'):
                return "Kernel File"
            return "File"
        
        def get_file_icon(path):
            """è·å–æ–‡ä»¶ç±»å‹å›¾æ ‡"""
            if path.endswith('.apk'):
                return "ğŸ“±"
            elif path.endswith('.zip'):
                return "ğŸ“¦"
            elif path.endswith('.tar.gz'):
                return "ğŸ—œï¸"
            return "ğŸ“„"
        
        async def send_telegram_message(files):
            """ä½¿ç”¨Telethonå‘é€æ¶ˆæ¯"""
            try:
                api_id = int(os.getenv("TELEGRAM_API_ID"))
                api_hash = os.getenv("TELEGRAM_API_HASH")
                session_str = os.getenv("TELEGRAM_SESSION")
                channel = os.getenv("TELEGRAM_CHANNEL")
                
                if not all([api_id, api_hash, session_str, channel]):
                    print("âŒ Telegramé…ç½®ä¸å®Œæ•´")
                    return False
                
                async with TelegramClient(
                    StringSession(session_str), 
                    api_id, 
                    api_hash
                ) as client:
                    # æ„å»ºç®€æ´æ¶ˆæ¯
                    message = "ğŸš€ **å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥**\n\n"
                    message += f"ğŸ”– ä»“åº“: `{os.getenv('GITHUB_REPOSITORY')}`\n"
                    message += f"ğŸ†” æäº¤: [{os.getenv('GITHUB_SHA')[:7]}](https://github.com/{os.getenv('GITHUB_REPOSITORY')}/commit/{os.getenv('GITHUB_SHA')})\n\n"
                    
                    # æ·»åŠ æ–‡ä»¶åˆ—è¡¨
                    for file in files:
                        icon = get_file_icon(file['path'])
                        file_type = get_file_type(file['path'])
                        message += f"{icon} **{file_type}**: `{file['name']}`\n"
                        message += f"  - ç‰ˆæœ¬: `{file['version']}`\n"
                        message += f"  - æ›´æ–°æ—¶é—´: `{file['date']}` (åŒ—äº¬æ—¶é—´)\n"
                        message += f"  - \n\n"
                    
                    await client.send_message(
                        entity=channel,
                        message=message,
                        parse_mode='md',
                        link_preview=False
                    )
                    return True
            except Exception as e:
                print(f"âŒ Telethoné”™è¯¯: {str(e)}")
                return False
        
        def send_email(files, receiver_email):
            """å‘é€é‚®ä»¶é€šçŸ¥"""
            try:
                # ä»ç¯å¢ƒå˜é‡è·å–SMTPé…ç½®
                smtp_server = os.getenv("SMTP_SERVER")
                smtp_port = int(os.getenv("SMTP_PORT", 587))
                smtp_user = os.getenv("SMTP_USER")
                smtp_password = os.getenv("SMTP_PASSWORD")
                
                # éªŒè¯é…ç½®å®Œæ•´æ€§
                if not all([smtp_server, smtp_user, smtp_password]):
                    print("âŒ SMTPé…ç½®ä¸å®Œæ•´")
                    return False
                
                # æ„å»ºé‚®ä»¶ä¸»é¢˜å’Œå†…å®¹
                subject = f"å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥ - {os.getenv('GITHUB_REPOSITORY')}"
                
                # HTMLæ ¼å¼çš„é‚®ä»¶å†…å®¹
                html_content = f"""
                <html>
                <body>
                    <h2>ğŸš€ å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥</h2>
                    <p><strong>ğŸ”– ä»“åº“:</strong> {os.getenv('GITHUB_REPOSITORY')}</p>
                    <p><strong>ğŸ†” æäº¤:</strong> <a href="https://github.com/{os.getenv('GITHUB_REPOSITORY')}/commit/{os.getenv('GITHUB_SHA')}">{os.getenv('GITHUB_SHA')[:7]}</a></p>
                    <p><strong>ğŸ“¦ æ£€æµ‹åˆ° {len(files)} ä¸ªæ–‡ä»¶æ›´æ–°:</strong> (æ‰€æœ‰æ—¶é—´å‡ä¸ºåŒ—äº¬æ—¶é—´)</p>
                    <ul>
                """
                
                for file in files:
                    proxy_urls = generate_proxy_urls(file['url'])
                    icon = get_file_icon(file['path'])
                    file_type = get_file_type(file['path'])
                    html_content += f"""
                    <li>
                        <p><strong>{icon} {file_type}: {file['name']}</strong></p>
                        <ul>
                            <li><strong>ç‰ˆæœ¬:</strong> {file['version']}</li>
                            <li><strong>æ›´æ–°æ—¶é—´:</strong> {file['date']} (åŒ—äº¬æ—¶é—´)</li>
                            <li><strong>ä¸‹è½½åœ°å€:</strong> 
                                <a href="{file['url']}">åŸå§‹åœ°å€</a> | 
                                <a href="{proxy_urls['gh-proxy']}">gh-proxy</a> | 
                                <a href="{proxy_urls['github-speedup']}">github-speedup</a>
                            </li>
                        </ul>
                    </li>
                    """
                
                html_content += """
                    </ul>
                    <p>æ­¤é‚®ä»¶ç”± GitHub Actions è‡ªåŠ¨å‘é€</p>
                </body>
                </html>
                """
                
                # åˆ›å»ºé‚®ä»¶
                msg = MIMEMultipart()
                msg['From'] = smtp_user
                msg['To'] = receiver_email
                msg['Subject'] = subject
                msg.attach(MIMEText(html_content, 'html'))
                
                # ä½¿ç”¨SSLè¿æ¥SMTPæœåŠ¡å™¨
                server = smtplib.SMTP_SSL(smtp_server, smtp_port)
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, receiver_email, msg.as_string())
                server.quit()
                
                print(f"âœ… é‚®ä»¶å·²å‘é€è‡³: {receiver_email}")
                return True
            except Exception as e:
                # æ‰“å°è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                import traceback
                traceback.print_exc()
                print(f"âŒ é‚®ä»¶å‘é€å¤±è´¥: {str(e)}")
                return False
        
        def main():
            print("ğŸš€ å¼€å§‹å®æ—¶ç›‘æ§ç›®å½•å˜æ›´...")
            repo = pygit2.Repository('.')
            
            # è·å–å½“å‰æäº¤
            head_commit = repo.head.peel()
            print(f"å½“å‰æäº¤: {head_commit.id}")
            
            # è·å–çˆ¶æäº¤
            parent_commits = head_commit.parents
            if not parent_commits:
                print("âš ï¸ åˆå§‹æäº¤ - æ— å‰ä¸€ç‰ˆæœ¬")
                return
            
            # ä½¿ç”¨ç¬¬ä¸€ä¸ªçˆ¶æäº¤è¿›è¡Œæ¯”è¾ƒ
            parent_commit = parent_commits[0]
            print(f"çˆ¶æäº¤: {parent_commit.id}")
            
            # è®¡ç®—å·®å¼‚
            diff = repo.diff(parent_commit, head_commit)
            changed_files = []
            
            # è§£æå·®å¼‚
            for delta in diff.deltas:
                # åªå¤„ç†æ–°å¢å’Œä¿®æ”¹çš„æ–‡ä»¶ï¼Œå¿½ç•¥åˆ é™¤çš„æ–‡ä»¶
                if delta.status not in (pygit2.GIT_DELTA_ADDED, pygit2.GIT_DELTA_MODIFIED):
                    continue
                
                file_path = delta.new_file.path or delta.old_file.path
                print(f"æ£€æµ‹åˆ°å˜æ›´: {file_path} [çŠ¶æ€: {delta.status}]")
                
                # åªå¤„ç†apkå’Œkernelsç›®å½•ä¸‹çš„æ–‡ä»¶
                if not (file_path.startswith('apk/') or file_path.startswith('kernels/')):
                    continue
                
                # è·å–æ–‡ä»¶å
                filename = os.path.basename(file_path)
                
                # è·å–UTCæ—¶é—´å¹¶è½¬æ¢ä¸ºåŒ—äº¬æ—¶é—´
                utc_time = datetime.utcfromtimestamp(head_commit.commit_time)
                utc_time = UTC_TZ.localize(utc_time)  # æ ‡è®°ä¸ºUTCæ—¶åŒº
                beijing_time = utc_time.astimezone(BEIJING_TZ)
                commit_time = beijing_time.strftime('%Y-%m-%d %H:%M')
                
                # æ„å»ºåŸå§‹ä¸‹è½½URL
                encoded_path = quote(file_path)
                raw_url = f"https://raw.githubusercontent.com/{os.getenv('GITHUB_REPOSITORY')}/main/{encoded_path}"
                
                # è·å–å‡†ç¡®ç‰ˆæœ¬ä¿¡æ¯
                version_info = get_accurate_version(filename, file_path)
                
                if version_info:
                    version = version_info.get("version", "æœªçŸ¥ç‰ˆæœ¬")
                    version_date = version_info.get("date", commit_time)
                    version_source = "ç‰ˆæœ¬æ–‡ä»¶"
                else:
                    version = "æœªçŸ¥ç‰ˆæœ¬"
                    version_date = commit_time
                    version_source = "é»˜è®¤æ—¶é—´"
                
                changed_files.append({
                    "path": file_path,
                    "name": filename,
                    "version": version,
                    "date": version_date,
                    "url": raw_url,
                    "version_source": version_source
                })
            
            if not changed_files:
                print("âœ… æœªæ£€æµ‹åˆ°æ–‡ä»¶å˜æ›´")
                return
            
            print(f"ğŸ“¦ æ£€æµ‹åˆ° {len(changed_files)} ä¸ªæ–‡ä»¶å˜æ›´:")
            for file in changed_files:
                print(f"  - {file['path']} (v{file['version']}, {file['date']} åŒ—äº¬æ—¶é—´) [æ¥æº: {file['version_source']}]")
            
            # å‘é€åˆ°Telegram
            loop = asyncio.get_event_loop()
            telegram_success = loop.run_until_complete(send_telegram_message(changed_files))
            
            # å‘é€åˆ°é‚®ç®±
            email_receiver = os.getenv("EMAIL_RECEIVER")
            if email_receiver:
                email_success = send_email(changed_files, email_receiver)
            else:
                print("âš ï¸ æœªé…ç½®EMAIL_RECEIVERï¼Œè·³è¿‡é‚®ä»¶é€šçŸ¥")
                email_success = False
            
            if telegram_success:
                print("âœ… Telegramé€šçŸ¥å‘é€æˆåŠŸ!")
            else:
                print("âŒ Telegramé€šçŸ¥å‘é€å¤±è´¥")
            
            if email_success:
                print("âœ… é‚®ä»¶é€šçŸ¥å‘é€æˆåŠŸ!")
            else:
                print("âŒ é‚®ä»¶é€šçŸ¥å‘é€å¤±è´¥")
        
        if __name__ == "__main__":
            main()
        EOF
        
        python directory_monitor.py

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: detect-and-notify
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Real-time Directory Monitor"
          repository: ${{ github.repository }}
