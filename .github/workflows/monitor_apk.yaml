name: Real-time Directory Monitor

on:
  push:
    paths:
      - 'apk/**'
      - 'kernels/**'
      - 'version.txt'
      - 'kernel_versions.json'
    branches: [ main ]
  workflow_run:
    workflows: ["NagramX Sync from Source Repository", "BV APK Sync from Source Repository", "GitHub XAPK Download and Sync", "Karing Beta Sync from Source Repository", "MYTV APK Sync from Source Repository", "OK PRO APK Sync from TELEGRAM", "OK APK Sync from TELEGRAM", "OK APK Sync from Source Repository", "Proxypin Sync from Source Repository", "Simple_live APK Sync from Source Repository", "OpenWrt Kernel Sync from TELEGRAM", "ServerBox Sync from Source Repository", "TV APK Sync from TELEGRAM", "TV NEW APK Sync from TELEGRAM", "Hiddify APK Sync from Source Repository", "Termux APK Sync from Source Repository", "Passwall Packages Sync from Source Repository",  "Plus APK Download and Sync", "TAuxiliary APK Sync from TELEGRAM", "PLUS MODZ APK Sync from TELEGRAM", "YYKM TV APK Sync from TELEGRAM", "YouTube APK Sync from Source Repository"]
    types: [completed]
  workflow_dispatch:

jobs:
  detect-and-notify:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency: 
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        fetch-depth: 2
        token: ${{ secrets.REPO_PAT }}

    - name: è·å–æœ€æ–°å˜æ›´
      run: |
        git fetch --all
        git pull origin ${{ github.ref }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake libgit2-dev pkg-config
        # å®‰è£…å…¼å®¹çš„Telethonç‰ˆæœ¬
        pip install telethon==1.28.5 pygit2 pytz

    - name: Run enhanced detection script
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL }}
        EMAIL_RECEIVER: ${{ secrets.EMAIL_RECEIVER }}
        SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USER: ${{ secrets.SMTP_USER }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}
        GITHUB_REF: ${{ github.ref }}
      run: |
        cat << 'EOF' > directory_monitor.py
        import os
        import re
        import pygit2
        import asyncio
        import smtplib
        import hashlib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        from datetime import datetime
        from pytz import timezone
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from urllib.parse import quote
        import json
        import subprocess
        
        # è®¾ç½®æ—¶åŒº
        UTC_TZ = timezone('UTC')
        BEIJING_TZ = timezone('Asia/Shanghai')
        
        def run_git_command(cmd):
            """è¿è¡Œgitå‘½ä»¤å¹¶è¿”å›è¾“å‡º"""
            try:
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
                return result.stdout.strip()
            except subprocess.CalledProcessError as e:
                print(f"Gitå‘½ä»¤å¤±è´¥: {cmd}, é”™è¯¯: {e}")
                return None
        
        def get_changed_files():
            """ä½¿ç”¨gitå‘½ä»¤è·å–å˜æ›´æ–‡ä»¶åˆ—è¡¨"""
            current_sha = os.getenv('GITHUB_SHA')
            print(f"å½“å‰æäº¤SHA: {current_sha}")
            
            # è·å–å‰ä¸€ä¸ªæäº¤
            previous_sha = run_git_command(f"git rev-parse {current_sha}^")
            if not previous_sha:
                print("âš ï¸ æ— æ³•è·å–å‰ä¸€ä¸ªæäº¤ï¼Œå°è¯•ä½¿ç”¨HEAD^")
                previous_sha = run_git_command("git rev-parse HEAD^")
            
            if not previous_sha:
                print("âŒ æ— æ³•è·å–çˆ¶æäº¤ï¼Œä½¿ç”¨ç©ºæ ‘æ¯”è¾ƒ")
                previous_sha = "4b825dc642cb6eb9a060e54bf8d69288fbee4904"  # ç©ºæ ‘
            
            print(f"å‰ä¸€ä¸ªæäº¤SHA: {previous_sha}")
            
            # è·å–å˜æ›´æ–‡ä»¶åˆ—è¡¨
            changed_files_output = run_git_command(f"git diff --name-only {previous_sha} {current_sha}")
            if not changed_files_output:
                print("âŒ æ— æ³•è·å–å˜æ›´æ–‡ä»¶åˆ—è¡¨")
                return []
            
            changed_files = []
            for line in changed_files_output.split('\n'):
                line = line.strip()
                if line and (line.startswith('apk/') or line.startswith('kernels/')):
                    changed_files.append(line)
            
            print(f"Gitæ£€æµ‹åˆ°å˜æ›´æ–‡ä»¶: {changed_files}")
            return changed_files
        
        # è·å–å†…æ ¸ç‰ˆæœ¬ä¿¡æ¯
        def get_kernel_versions():
            """ä»kernel_versions.jsonè·å–å†…æ ¸ç‰ˆæœ¬ä¿¡æ¯"""
            kernel_version_path = "kernel_versions.json"
            if os.path.exists(kernel_version_path):
                try:
                    with open(kernel_version_path, "r", encoding='utf-8') as f:
                        return json.load(f)
                except Exception as e:
                    print(f"âŒ è§£ækernel_versions.jsonå¤±è´¥: {str(e)}")
            return {}
        
        # è·å–å‡†ç¡®ç‰ˆæœ¬å·
        def get_accurate_version(filename, file_path):
            """
            è·å–æ–‡ä»¶çš„å‡†ç¡®ç‰ˆæœ¬ä¿¡æ¯
            apkæ–‡ä»¶: ä»version.txtè·å–
            kernelsæ–‡ä»¶: ä»kernel_versions.jsonè·å–
            """
            # å¤„ç†å†…æ ¸æ–‡ä»¶
            if file_path.startswith('kernels/'):
                kernel_versions = get_kernel_versions()
                
                # ä»æ–‡ä»¶åæå–ç»„å (æ ¼å¼: openwrt_flippy6.1_6.1.141-flippy-93+o.zip)
                match = re.match(r'^([a-zA-Z0-9_]+)_(.*)\.zip$', filename)
                if match:
                    group = match.group(1)
                    file_version = match.group(2)
                    
                    # åœ¨ç‰ˆæœ¬æ•°æ®ä¸­æŸ¥æ‰¾ç»„
                    if group in kernel_versions:
                        version_data = kernel_versions[group]
                        return {
                            "version": version_data.get("version", file_version),
                            "date": version_data.get("date", "æœªçŸ¥æ—¥æœŸ")
                        }
                    else:
                        print(f"âš ï¸ kernel_versions.jsonä¸­æœªæ‰¾åˆ°ç»„: {group}")
                
                # å¦‚æœæ— æ³•è§£ææ–‡ä»¶åï¼Œè¿”å›é»˜è®¤å€¼
                return {
                    "version": "æœªçŸ¥ç‰ˆæœ¬",
                    "date": "æœªçŸ¥æ—¥æœŸ"
                }
            
            # å¤„ç†APKæ–‡ä»¶ - ä»version.txtè·å–ç‰ˆæœ¬ä¿¡æ¯
            version_path = "version.txt"
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r", encoding='utf-8') as f:
                        content = f.read().strip()
                    
                    # å°è¯•è§£æä¸ºJSON
                    try:
                        version_data = json.loads(content)
                        if filename in version_data:
                            version_info = version_data[filename]
                            if isinstance(version_info, str):
                                if ',' in version_info:
                                    version, date = version_info.split(',', 1)
                                    return {"version": version.strip(), "date": date.strip()}
                                return {"version": version_info, "date": "æœªçŸ¥æ—¥æœŸ"}
                            elif isinstance(version_info, dict):
                                return {
                                    "version": version_info.get("version", "æœªçŸ¥ç‰ˆæœ¬"),
                                    "date": version_info.get("date", "æœªçŸ¥æ—¥æœŸ")
                                }
                    except json.JSONDecodeError:
                        # å¦‚æœä¸æ˜¯JSONï¼Œå°è¯•æŒ‰è¡Œè§£æ
                        for line in content.split('\n'):
                            line = line.strip()
                            if ':' in line and filename in line:
                                parts = line.split(':', 1)
                                version_info = parts[1].strip()
                                if ',' in version_info:
                                    version, date = version_info.split(',', 1)
                                    return {"version": version.strip(), "date": date.strip()}
                                return {"version": version_info, "date": "æœªçŸ¥æ—¥æœŸ"}
                except Exception as e:
                    print(f"âŒ è§£æversion.txtå¤±è´¥: {str(e)}")
            
            return None
        
        def generate_proxy_urls(raw_url):
            """ç”Ÿæˆä»£ç†ä¸‹è½½é“¾æ¥"""
            return {
                "gh-proxy": f"https://ghproxy.com/{raw_url}",
                "github-speedup": f"https://pd.zwc365.com/seturl/{raw_url}"
            }
        
        def get_file_type(path):
            """æ ¹æ®è·¯å¾„ç¡®å®šæ–‡ä»¶ç±»å‹"""
            if path.startswith('apk/'):
                return "App File"
            elif path.startswith('kernels/'):
                return "Kernel File"
            return "File"
        
        def get_file_icon(path):
            """è·å–æ–‡ä»¶ç±»å‹å›¾æ ‡"""
            if path.endswith('.apk'):
                return "ğŸ“±"
            elif path.endswith('.zip'):
                return "ğŸ“¦"
            elif path.endswith('.tar.gz') or path.endswith('.tgz'):
                return "ğŸ—œï¸"
            return "ğŸ“„"
        
        def calculate_file_hash(file_path):
            """è®¡ç®—æ–‡ä»¶çš„SHA-256å“ˆå¸Œå€¼ï¼ˆç”¨äºå»é‡ï¼‰"""
            sha256_hash = hashlib.sha256()
            try:
                with open(file_path, "rb") as f:
                    # åˆ†å—è¯»å–ä»¥é¿å…å¤§æ–‡ä»¶å†…å­˜é—®é¢˜
                    for byte_block in iter(lambda: f.read(4096), b""):
                        sha256_hash.update(byte_block)
                return sha256_hash.hexdigest()
            except Exception as e:
                print(f"âŒ è®¡ç®—æ–‡ä»¶å“ˆå¸Œå¤±è´¥: {file_path} - {str(e)}")
                return None
        
        def get_file_size(file_path):
            """è·å–æ–‡ä»¶å¤§å°ï¼ˆMBï¼‰"""
            try:
                size_bytes = os.path.getsize(file_path)
                return f"{size_bytes / (1024 * 1024):.2f} MB"
            except Exception as e:
                print(f"âŒ è·å–æ–‡ä»¶å¤§å°å¤±è´¥: {file_path} - {str(e)}")
                return "æœªçŸ¥å¤§å°"
        
        async def send_telegram_message(files):
            """ä½¿ç”¨Telethonå‘é€æ¶ˆæ¯"""
            try:
                api_id = int(os.getenv("TELEGRAM_API_ID"))
                api_hash = os.getenv("TELEGRAM_API_HASH")
                session_str = os.getenv("TELEGRAM_SESSION")
                channel = os.getenv("TELEGRAM_CHANNEL")
                
                if not all([api_id, api_hash, session_str, channel]):
                    print("âŒ Telegramé…ç½®ä¸å®Œæ•´")
                    return False
                
                async with TelegramClient(
                    StringSession(session_str), 
                    api_id, 
                    api_hash
                ) as client:
                    # æ„å»ºç®€æ´æ¶ˆæ¯
                    message = "ğŸš€ **å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥**\\n\\n"
                    message += f"ğŸ”– ä»“åº“: `{os.getenv('GITHUB_REPOSITORY')}`\\n"
                    message += f"ğŸ†” æäº¤: [{os.getenv('GITHUB_SHA')[:7]}](https://github.com/{os.getenv('GITHUB_REPOSITORY')}/commit/{os.getenv('GITHUB_SHA')})\\n\\n"
                    
                    # æ·»åŠ æ–‡ä»¶åˆ—è¡¨
                    for file in files:
                        icon = get_file_icon(file['path'])
                        file_type = get_file_type(file['path'])
                        message += f"{icon} **{file_type}**: `{file['name']}`\\n"
                        message += f"  - ç‰ˆæœ¬: `{file['version']}`\\n"
                        message += f"  - å¤§å°: `{file['size']}`\\n"
                        message += f"  - æ›´æ–°æ—¶é—´: `{file['date']}` (åŒ—äº¬æ—¶é—´)\\n\\n"
                    
                    await client.send_message(
                        entity=channel,
                        message=message,
                        parse_mode='md',
                        link_preview=False
                    )
                    return True
            except Exception as e:
                print(f"âŒ Telethoné”™è¯¯: {str(e)}")
                return False
        
        def send_email(files, receiver_email):
            """å‘é€é‚®ä»¶é€šçŸ¥"""
            try:
                # ä»ç¯å¢ƒå˜é‡è·å–SMTPé…ç½®
                smtp_server = os.getenv("SMTP_SERVER")
                smtp_port = int(os.getenv("SMTP_PORT", 587))
                smtp_user = os.getenv("SMTP_USER")
                smtp_password = os.getenv("SMTP_PASSWORD")
                
                # éªŒè¯é…ç½®å®Œæ•´æ€§
                if not all([smtp_server, smtp_user, smtp_password]):
                    print("âŒ SMTPé…ç½®ä¸å®Œæ•´")
                    return False
                
                # æ„å»ºé‚®ä»¶ä¸»é¢˜å’Œå†…å®¹
                subject = f"å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥ - {os.getenv('GITHUB_REPOSITORY')}"
                
                # HTMLæ ¼å¼çš„é‚®ä»¶å†…å®¹
                html_content = f"""
                <html>
                <body>
                    <h2>ğŸš€ å®æ—¶æ–‡ä»¶æ›´æ–°é€šçŸ¥</h2>
                    <p><strong>ğŸ”– ä»“åº“:</strong> {os.getenv('GITHUB_REPOSITORY')}</p>
                    <p><strong>ğŸ†” æäº¤:</strong> <a href="https://github.com/{os.getenv('GITHUB_REPOSITORY')}/commit/{os.getenv('GITHUB_SHA')}">{os.getenv('GITHUB_SHA')[:7]}</a></p>
                    <p><strong>ğŸ“¦ æ£€æµ‹åˆ° {len(files)} ä¸ªæ–‡ä»¶æ›´æ–°:</strong> (æ‰€æœ‰æ—¶é—´å‡ä¸ºåŒ—äº¬æ—¶é—´)</p>
                    <ul>
                """
                
                for file in files:
                    proxy_urls = generate_proxy_urls(file['url'])
                    icon = get_file_icon(file['path'])
                    file_type = get_file_type(file['path'])
                    html_content += f"""
                    <li>
                        <p><strong>{icon} {file_type}: {file['name']}</strong></p>
                        <ul>
                            <li><strong>ç‰ˆæœ¬:</strong> {file['version']}</li>
                            <li><strong>å¤§å°:</strong> {file['size']}</li>
                            <li><strong>æ›´æ–°æ—¶é—´:</strong> {file['date']} (åŒ—äº¬æ—¶é—´)</li>
                            <li><strong>ä¸‹è½½åœ°å€:</strong> 
                                <a href="{file['url']}">åŸå§‹åœ°å€</a> | 
                                <a href="{proxy_urls['gh-proxy']}">gh-proxy</a> | 
                                <a href="{proxy_urls['github-speedup']}">github-speedup</a>
                            </li>
                        </ul>
                    </li>
                    """
                
                html_content += """
                    </ul>
                    <p>æ­¤é‚®ä»¶ç”± GitHub Actions è‡ªåŠ¨å‘é€</p>
                </body>
                </html>
                """
                
                # åˆ›å»ºé‚®ä»¶
                msg = MIMEMultipart()
                msg['From'] = smtp_user
                msg['To'] = receiver_email
                msg['Subject'] = subject
                msg.attach(MIMEText(html_content, 'html'))
                
                # ä½¿ç”¨SSLè¿æ¥SMTPæœåŠ¡å™¨
                server = smtplib.SMTP_SSL(smtp_server, smtp_port)
                server.login(smtp_user, smtp_password)
                server.sendmail(smtp_user, receiver_email, msg.as_string())
                server.quit()
                
                print(f"âœ… é‚®ä»¶å·²å‘é€è‡³: {receiver_email}")
                return True
            except Exception as e:
                # æ‰“å°è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                import traceback
                traceback.print_exc()
                print(f"âŒ é‚®ä»¶å‘é€å¤±è´¥: {str(e)}")
                return False
        
        def main():
            print("ğŸš€ å¼€å§‹å®æ—¶ç›‘æ§ç›®å½•å˜æ›´...")
            
            # ä½¿ç”¨gitå‘½ä»¤è·å–å˜æ›´æ–‡ä»¶
            changed_file_paths = get_changed_files()
            if not changed_file_paths:
                print("âœ… æœªæ£€æµ‹åˆ°æ–‡ä»¶å˜æ›´")
                return
            
            changed_files = []
            changed_hashes = set()
            
            for file_path in changed_file_paths:
                print(f"å¤„ç†æ–‡ä»¶: {file_path}")
                
                # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                if not os.path.exists(file_path):
                    print(f"âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨: {file_path} - è·³è¿‡")
                    continue
                
                # è®¡ç®—æ–‡ä»¶å“ˆå¸Œï¼ˆç”¨äºå»é‡ï¼‰
                file_hash = calculate_file_hash(file_path)
                if not file_hash:
                    print(f"âš ï¸ æ— æ³•è®¡ç®—æ–‡ä»¶å“ˆå¸Œ: {file_path} - è·³è¿‡")
                    continue
                
                # æ£€æŸ¥å“ˆå¸Œæ˜¯å¦å·²å­˜åœ¨ï¼ˆé¿å…é‡å¤é€šçŸ¥ï¼‰
                if file_hash in changed_hashes:
                    print(f"âš ï¸ æ–‡ä»¶å“ˆå¸Œå·²å­˜åœ¨: {file_path} - è·³è¿‡é‡å¤æ–‡ä»¶")
                    continue
                
                # è·å–æ–‡ä»¶å
                filename = os.path.basename(file_path)
                
                # è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—´ï¼ˆä½œä¸ºé»˜è®¤æ—¶é—´ï¼‰
                file_mtime = os.path.getmtime(file_path)
                beijing_time = datetime.fromtimestamp(file_mtime).astimezone(BEIJING_TZ)
                commit_time = beijing_time.strftime('%Y-%m-%d %H:%M')
                
                # æ„å»ºåŸå§‹ä¸‹è½½URL
                encoded_path = quote(file_path)
                raw_url = f"https://raw.githubusercontent.com/{os.getenv('GITHUB_REPOSITORY')}/main/{encoded_path}"
                
                # è·å–å‡†ç¡®ç‰ˆæœ¬ä¿¡æ¯
                version_info = get_accurate_version(filename, file_path)
                
                if version_info:
                    version = version_info.get("version", "æœªçŸ¥ç‰ˆæœ¬")
                    version_date = version_info.get("date", commit_time)
                    version_source = "ç‰ˆæœ¬æ–‡ä»¶"
                else:
                    version = "æœªçŸ¥ç‰ˆæœ¬"
                    version_date = commit_time
                    version_source = "æ–‡ä»¶ä¿®æ”¹æ—¶é—´"
                
                # è·å–æ–‡ä»¶å¤§å°
                file_size = get_file_size(file_path)
                
                changed_files.append({
                    "path": file_path,
                    "name": filename,
                    "version": version,
                    "date": version_date,
                    "url": raw_url,
                    "version_source": version_source,
                    "size": file_size
                })
                
                # æ·»åŠ åˆ°å“ˆå¸Œé›†åˆ
                changed_hashes.add(file_hash)
            
            if not changed_files:
                print("âœ… æ— æœ‰æ•ˆæ–‡ä»¶å˜æ›´éœ€è¦é€šçŸ¥")
                return
            
            print(f"ğŸ“¦ æ£€æµ‹åˆ° {len(changed_files)} ä¸ªæ–‡ä»¶å˜æ›´:")
            for file in changed_files:
                print(f"  - {file['path']} (v{file['version']}, {file['date']} åŒ—äº¬æ—¶é—´) [å¤§å°: {file['size']}]")
            
            # å‘é€åˆ°Telegram
            try:
                loop = asyncio.get_event_loop()
            except RuntimeError:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
            
            telegram_success = loop.run_until_complete(send_telegram_message(changed_files))
            
            # å‘é€åˆ°é‚®ç®±
            email_receiver = os.getenv("EMAIL_RECEIVER")
            if email_receiver:
                email_success = send_email(changed_files, email_receiver)
            else:
                print("âš ï¸ æœªé…ç½®EMAIL_RECEIVERï¼Œè·³è¿‡é‚®ä»¶é€šçŸ¥")
                email_success = False
            
            if telegram_success:
                print("âœ… Telegramé€šçŸ¥å‘é€æˆåŠŸ!")
            else:
                print("âŒ Telegramé€šçŸ¥å‘é€å¤±è´¥")
            
            if email_success:
                print("âœ… é‚®ä»¶é€šçŸ¥å‘é€æˆåŠŸ!")
            else:
                print("âŒ é‚®ä»¶é€šçŸ¥å‘é€å¤±è´¥")
        
        if __name__ == "__main__":
            main()
        EOF
        
        python directory_monitor.py

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: detect-and-notify
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2.0.6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Real-time Directory Monitor"
          repository: ${{ github.repository }}