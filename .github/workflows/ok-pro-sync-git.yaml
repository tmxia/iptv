name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        WORK_DIR = "temp_apks"
        VERSION_FILE = "version.txt"
        
        # ç¡¬ç¼–ç çš„Telegramé¢‘é“
        TELEGRAM_CHANNELS = ["tvb_ys", "tvboxjk"]
        
        # è®¾ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        logger = logging.getLogger()
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def git_setup():
            """é…ç½®Gitç”¨æˆ·ä¿¡æ¯"""
            actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
            email = f"{actor}@users.noreply.github.com"
            
            subprocess.run(["git", "config", "user.name", actor], check=True)
            subprocess.run(["git", "config", "user.email", email], check=True)
            logger.info("Gité…ç½®å®Œæˆ")
            
            # æ‹‰å–æœ€æ–°æ›´æ”¹
            logger.info("æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹...")
            subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
            return True
        
        def git_commit_push(message):
            """æäº¤å¹¶æ¨é€æ›´æ”¹"""
            try:
                # åªæ·»åŠ apkç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹ï¼ˆå¿½ç•¥æœªè·Ÿè¸ªæ–‡ä»¶ï¼‰
                status = subprocess.run(
                    ["git", "status", "--porcelain", "--untracked-files=no"],
                    capture_output=True, text=True, check=True
                )
                if not status.stdout.strip():
                    logger.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                # ä½¿ç”¨Tokenæ¨é€
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                logger.info("æ¨é€æˆåŠŸ")
                return True
            except Exception as e:
                logger.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯å¹¶éªŒè¯é”®å€¼ç»“æ„"""
            if not os.path.exists(VERSION_FILE):
                return {}
            
            try:
                with open(VERSION_FILE, "r") as f:
                    versions = json.load(f)
                    # éªŒè¯æ˜¯å¦ä¸ºå­—å…¸æ ¼å¼
                    if not isinstance(versions, dict):
                        logger.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼æ— æ•ˆï¼Œé‡ç½®ä¸ºç©ºå­—å…¸")
                        return {}
                    return versions
            except Exception as e:
                logger.error(f"ç‰ˆæœ¬æ–‡ä»¶è¯»å–å¤±è´¥: {str(e)}")
                return {}
        
        def update_versions(new_versions):
            """æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(VERSION_FILE, "w") as f:
                json.dump(versions, f, indent=2)
                logger.info("ç‰ˆæœ¬æ–‡ä»¶å·²æ›´æ–°")
                
                # ä»…æ˜¾ç¤ºå…³å¿ƒçš„é”®å€¼ç‰ˆæœ¬ä¿¡æ¯
                for apk, ver in new_versions.items():
                    logger.info(f"ç‰ˆæœ¬æ›´æ–°: {apk} => {ver}")
        
        def extract_apk_version(apk_path):
            """ä½¿ç”¨aapt2ä»APKæå–ç‰ˆæœ¬å·"""
            try:
                aapt2 = os.path.join(
                    os.environ['ANDROID_HOME'],
                    "build-tools/34.0.0/aapt2"
                )
                
                result = subprocess.run(
                    [aapt2, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # æŸ¥æ‰¾versionName
                match = re.search(r"versionName='([^']*)'", result.stdout)
                if match:
                    version = match.group(1)
                    return f"v{version}" if not version.startswith('v') else version
                return None
            except Exception as e:
                logger.error(f"æå–ç‰ˆæœ¬å·å¤±è´¥: {str(e)}")
                return None
        
        def extract_version_from_filename(filename):
            """ä»æ–‡ä»¶åä¸­æå–ç‰ˆæœ¬å·ï¼Œå¤„ç†ç‰¹æ®Šå­—ç¬¦"""
            # å¤šç§ç‰ˆæœ¬å·åŒ¹é…æ¨¡å¼ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åº
            patterns = [
                r'[ï¹£-]+([\d.]+)\.apk$',           # åŒ¹é… "ï¹£-3.5.3.apk" æ ¼å¼
                r'[ï¹£-]([\d.]+)\.apk$',            # åŒ¹é… "ï¹£3.5.3.apk" æ ¼å¼  
                r'v?([\d.]+)\.apk$',               # åŒ¹é… "3.5.3.apk" æˆ– "v3.5.3.apk" æ ¼å¼
                r'[^a-zA-Z]([\d.]+)\.apk$'         # é€šç”¨åŒ¹é…
            ]
            
            for pattern in patterns:
                match = re.search(pattern, filename)
                if match:
                    version = match.group(1)
                    # ç¡®ä¿ç‰ˆæœ¬å·æ ¼å¼æ­£ç¡®
                    if version and re.match(r'^\d+(\.\d+)*$', version):
                        return f"v{version}"
            
            return None
        
        def map_filename(original_name, channel_name):
            """å°†åŸå§‹æ–‡ä»¶åæ˜ å°„åˆ°æ ‡å‡†æ–‡ä»¶å"""
            # ç²¾ç¡®æ’é™¤æ¨¡æ‹Ÿå™¨ä¸“ç‰ˆ
            if "æ¨¡æ‹Ÿå™¨" in original_name or "æ¨¡æ‹Ÿå™¨ä¸“ç‰ˆ" in original_name:
                return None
            
            # ç¬¬ä¸€ä¸ªé¢‘é“çš„ç›´æ¥åŒ¹é…
            if channel_name == "tvb_ys" and original_name in APK_FILES:
                return original_name
            
            # ç¬¬äºŒä¸ªé¢‘é“çš„æ–‡ä»¶åæ˜ å°„è§„åˆ™
            if channel_name == "tvboxjk":
                # å¿…é¡»åŒ…å«"okå½±è§†"æˆ–"OKå½±è§†"å­—æ ·ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
                if not any(keyword in original_name.lower() for keyword in ["okå½±è§†", "okys"]):
                    return None
                
                # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæ›´ç²¾å‡†çš„åŒ¹é…
                
                # åŒ¹é…æ‰‹æœºç‰ˆ - æ”¯æŒå¤šç§åˆ†éš”ç¬¦å’Œç‰ˆæœ¬æ ¼å¼
                mobile_patterns = [
                    r"æ‰‹æœºç‰ˆ",                    # ä¸­æ–‡æ ‡è¯†
                    r"mobile",                   # è‹±æ–‡æ ‡è¯†
                    r"æ‰‹æœº.*?[ï¹£-].*?[\d.]+\.apk$" # æ‰‹æœºç‰ˆ+ç‰ˆæœ¬å·æ¨¡å¼
                ]
                
                # åŒ¹é…ç”µè§†ç‰ˆ - æ”¯æŒå¤šç§åˆ†éš”ç¬¦å’Œç‰ˆæœ¬æ ¼å¼  
                tv_patterns = [
                    r"ç”µè§†ç‰ˆ",                    # ä¸­æ–‡æ ‡è¯†
                    r"leanback",                 # è‹±æ–‡æ ‡è¯†
                    r"ç”µè§†.*?[ï¹£-].*?[\d.]+\.apk$" # ç”µè§†ç‰ˆ+ç‰ˆæœ¬å·æ¨¡å¼
                ]
                
                # æ£€æŸ¥æ‰‹æœºç‰ˆæ¨¡å¼
                if any(re.search(pattern, original_name, re.IGNORECASE) for pattern in mobile_patterns):
                    return "mobile-pro.apk"
                
                # æ£€æŸ¥ç”µè§†ç‰ˆæ¨¡å¼
                if any(re.search(pattern, original_name, re.IGNORECASE) for pattern in tv_patterns):
                    return "leanback-pro.apk"
                
                # å¦‚æœä¸Šè¿°æ¨¡å¼éƒ½ä¸åŒ¹é…ï¼Œä½†æ–‡ä»¶åç¬¦åˆåŸºæœ¬æ ¼å¼ï¼Œä½¿ç”¨å¯å‘å¼åˆ¤æ–­
                if "æ‰‹æœº" in original_name or "mobile" in original_name.lower():
                    return "mobile-pro.apk"
                elif "ç”µè§†" in original_name or "leanback" in original_name.lower() or "tv" in original_name.lower():
                    return "leanback-pro.apk"
            
            return None
        
        async def download_apk(client, message, target_filename, original_filename, channel_name):
            """ä¸‹è½½APKæ–‡ä»¶å¹¶æå–å…ƒæ•°æ®"""
            download_path = os.path.join(WORK_DIR, target_filename)
            total_size = message.document.size
            logger.info(f"å¼€å§‹ä¸‹è½½: {original_filename} -> {target_filename} ({format_size(total_size)})")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            logger.info(f"ä¸‹è½½å®Œæˆ: è€—æ—¶{elapsed:.1f}ç§’")
            
            # éªŒè¯æ–‡ä»¶æ˜¯å¦æˆåŠŸä¸‹è½½
            if not os.path.exists(download_path):
                raise FileNotFoundError(f"æ–‡ä»¶ä¸‹è½½å¤±è´¥: {download_path}")
            
            # é’ˆå¯¹tvboxjké¢‘é“ä¼˜å…ˆä½¿ç”¨æ–‡ä»¶åä¸­çš„ç‰ˆæœ¬å·
            if channel_name == "tvboxjk":
                version = extract_version_from_filename(original_filename)
                if version:
                    logger.info(f"ä½¿ç”¨æ–‡ä»¶åç‰ˆæœ¬å·: {version}")
                    return {
                        "path": download_path,
                        "version": version,
                        "date": message.date.strftime("%Y-%m-%d")
                    }
            
            # å…¶ä»–æƒ…å†µä½¿ç”¨aapt2æå–ç‰ˆæœ¬å·
            version = extract_apk_version(download_path)
            if not version:
                # æœ€åå°è¯•ä»åŸå§‹æ–‡ä»¶åæå–ç‰ˆæœ¬å·
                version = extract_version_from_filename(original_filename)
                if version:
                    logger.info(f"ä»æ–‡ä»¶åæå–ç‰ˆæœ¬å·: {version}")
                else:
                    version = f"v{target_filename.split('.')[0]}-{message.date.strftime('%Y%m%d')}"
                    logger.info(f"ä½¿ç”¨åå¤‡ç‰ˆæœ¬å·: {version}")
            
            return {
                "path": download_path,
                "version": version,
                "date": message.date.strftime("%Y-%m-%d")
            }
        
        async def check_channel(client, channel_name, current_versions):
            """æ£€æŸ¥å•ä¸ªTelegramé¢‘é“ä¸­çš„æ–°APK"""
            logger.info(f"è¿æ¥Telegramé¢‘é“: {channel_name}")
            entity = await client.get_entity(channel_name)
            
            updates = {}
            processed_targets = set()
            
            # ç¬¬ä¸€éæ‰«æï¼šä»…æ”¶é›†æ¶ˆæ¯IDå’Œæ—¥æœŸï¼Œä¸ä¸‹è½½
            message_candidates = []
            async for msg in client.iter_messages(entity, limit=20):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                        
                    original_name = attr.file_name
                    target_name = map_filename(original_name, channel_name)
                    
                    if not target_name:
                        continue
                    
                    # é¿å…é‡å¤å¤„ç†åŒä¸€ç›®æ ‡æ–‡ä»¶
                    if target_name in processed_targets:
                        continue
                    processed_targets.add(target_name)
                    
                    # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸‹è½½
                    current = current_versions.get(target_name, "")
                    msg_date = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                    
                    # å¯¹äºtvboxjké¢‘é“ï¼Œä¼˜å…ˆä½¿ç”¨æ–‡ä»¶åä¸­çš„ç‰ˆæœ¬å·è¿›è¡Œé¢„æ£€æŸ¥
                    if channel_name == "tvboxjk":
                        # å°è¯•ä»æ–‡ä»¶åæå–ç‰ˆæœ¬å·
                        file_version = extract_version_from_filename(original_name)
                        if file_version:
                            # å¦‚æœå½“å‰æœ‰å­˜å‚¨ç‰ˆæœ¬ï¼Œç›´æ¥æ¯”è¾ƒç‰ˆæœ¬å·
                            if current:
                                try:
                                    stored_version = current.split(',')[0].strip()
                                    if stored_version == file_version:
                                        logger.info(f"é¢„è·³è¿‡ç›¸åŒç‰ˆæœ¬: {target_name} (ç‰ˆæœ¬ {file_version})")
                                        continue  # è·³è¿‡ä¸‹è½½
                                except Exception:
                                    pass
                    
                    # ç›®æ ‡æ–‡ä»¶ä¸å­˜åœ¨æ—¶å¼ºåˆ¶æ›´æ–°
                    target_path = os.path.join(APK_DIR, target_name)
                    if not os.path.exists(target_path):
                        logger.warning(f"ç›®æ ‡æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¼ºåˆ¶æ›´æ–°: {target_name}")
                        message_candidates.append((msg, target_name, original_name))
                        continue
                    
                    # å¸¸è§„ç‰ˆæœ¬å¯¹æ¯”é€»è¾‘
                    skip = False
                    if current:
                        try:
                            # æ­£ç¡®è§£æç‰ˆæœ¬æ–‡ä»¶ä¸­çš„ä¿¡æ¯
                            stored_version, stored_date = current.split(',')
                            stored_version = stored_version.strip()
                            stored_date = stored_date.strip()
                            
                            # è°ƒè¯•ä¿¡æ¯
                            logger.info(f"ç‰ˆæœ¬å¯¹æ¯”: {target_name} | å­˜å‚¨: {stored_version},{stored_date} | æ¶ˆæ¯æ—¥æœŸ: {msg_date}")
                            
                            # ä¸¥æ ¼ç‰ˆæœ¬å¯¹æ¯”
                            if msg_date < stored_date:
                                logger.info(f"è·³è¿‡æ—§ç‰ˆæœ¬: {target_name} ({msg_date} < {stored_date})")
                                skip = True
                            elif msg_date == stored_date:
                                # åŒä¸€å¤©ç‰ˆæœ¬éœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥
                                logger.info(f"åŒä¸€å¤©ç‰ˆæœ¬: {target_name} ({msg_date})ï¼Œç­‰å¾…è¿›ä¸€æ­¥æ£€æŸ¥")
                        except (IndexError, ValueError) as e:
                            logger.warning(f"ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯({current})ï¼Œç»§ç»­å¤„ç†: {str(e)}")
                    
                    if not skip:
                        message_candidates.append((msg, target_name, original_name))
                        logger.info(f"æ·»åŠ å€™é€‰: {target_name} ({original_name})")
            
            # ç¬¬äºŒéå¤„ç†ï¼šæŒ‰æ—¶é—´å€’åºå¤„ç†å€™é€‰æ¶ˆæ¯
            message_candidates.sort(key=lambda x: x[0].date, reverse=True)
            logger.info(f"é¢‘é“ {channel_name} å…±æœ‰ {len(message_candidates)} ä¸ªå€™é€‰APK")
            
            # å¤„ç†å€™é€‰æ¶ˆæ¯
            for msg, target_name, original_name in message_candidates:
                try:
                    apk_data = await download_apk(client, msg, target_name, original_name, channel_name)
                    new_value = f"{apk_data['version']},{apk_data['date']}"
                    
                    # ä¸‹è½½åå†æ¬¡éªŒè¯ç‰ˆæœ¬
                    current_value = current_versions.get(target_name, "")
                    if current_value == new_value:
                        logger.info(f"è·³è¿‡ç›¸åŒç‰ˆæœ¬: {target_name} (å½“å‰: {current_value} == æ–°: {new_value})")
                        os.remove(apk_data['path'])  # åˆ é™¤ä¸´æ—¶æ–‡ä»¶
                    else:
                        updates[target_name] = new_value
                        logger.info(f"å‘ç°æ–°ç‰ˆæœ¬: {target_name} (å½“å‰: {current_value} â†’ æ–°: {new_value})")
                        # æˆåŠŸè·å–æ›´æ–°åä¸å†å¤„ç†åŒç±»å‹æ–‡ä»¶
                        processed_targets.add(target_name)
                except Exception as e:
                    logger.error(f"ä¸‹è½½å¤±è´¥: {original_name} -> {target_name}, é”™è¯¯: {str(e)}")
            
            return updates
        
        async def main_async():
            """å¼‚æ­¥ä¸»å‡½æ•°"""
            logger.info("="*50 + "\nAPK åŒæ­¥å·¥å…·å¯åŠ¨\n" + "="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                raise ValueError(f"ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
            
            git_setup()
            # ç¡®ä¿æ¸…ç†ä¸´æ—¶ç›®å½•
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            # è·å–å½“å‰ç‰ˆæœ¬
            current_versions = get_versions()
            logger.info(f"å½“å‰ç‰ˆæœ¬ä¿¡æ¯: {json.dumps(current_versions, indent=2)}")
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            all_updates = {}
            
            async with client:
                # æ£€æŸ¥æ‰€æœ‰ç¡¬ç¼–ç çš„é¢‘é“
                for channel in TELEGRAM_CHANNELS:
                    try:
                        logger.info(f"å¼€å§‹æ£€æŸ¥é¢‘é“: {channel}")
                        updates = await check_channel(client, channel, current_versions)
                        all_updates.update(updates)
                        
                        # æ›´æ–°å½“å‰ç‰ˆæœ¬ä¿¡æ¯ç”¨äºåç»­é¢‘é“æ£€æŸ¥
                        current_versions.update(updates)
                        logger.info(f"é¢‘é“ {channel} æ£€æŸ¥å®Œæˆï¼Œæ›´æ–°: {len(updates)} ä¸ªAPK")
                    except Exception as e:
                        logger.error(f"å¤„ç†é¢‘é“ {channel} æ—¶å‡ºé”™: {str(e)}")
                        # ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªé¢‘é“
            
            if all_updates:
                logger.info(f"å‘ç° {len(all_updates)} ä¸ªAPKéœ€è¦æ›´æ–°")
                
                # å¤åˆ¶APKæ–‡ä»¶åˆ°ä»“åº“
                for apk in all_updates.keys():
                    src = os.path.join(WORK_DIR, apk)
                    if not os.path.exists(src):
                        logger.error(f"æºæ–‡ä»¶ä¸å­˜åœ¨: {src}")
                        raise FileNotFoundError(f"APKæ–‡ä»¶æœªæˆåŠŸä¸‹è½½: {apk}")
                    
                    dst = os.path.join(APK_DIR, apk)
                    shutil.copy2(src, dst)
                    logger.info(f"å·²å¤åˆ¶: {apk} åˆ° {dst}")
                
                # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                update_versions(all_updates)
                
                # æäº¤æ›´æ”¹
                commit_msg = f"æ›´æ–°APK: {', '.join(all_updates.keys())}"
                if not git_commit_push(commit_msg):
                    raise RuntimeError("æäº¤å¤±è´¥")
                else:
                    logger.info("æ‰€æœ‰æ›´æ–°å·²æˆåŠŸæäº¤")
            else:
                logger.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            logger.info("æ¸…ç†ä¸´æ—¶ç›®å½•...")
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            
            logger.info("="*50 + "\nåŒæ­¥ä»»åŠ¡å®Œæˆ\n" + "="*50)
            return 0
        
        if __name__ == "__main__":
            try:
                from asyncio import run
                run(main_async())
            except Exception as e:
                logging.error(f"ä¸¥é‡é”™è¯¯: {str(e)}")
                sys.exit(1)
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„ issue number
            if (context.issue && context.issue.number) {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `ğŸš¨ Telegram APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œè¯¦æƒ…: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            } else {
              // æ²¡æœ‰å…³è”çš„ issueï¼Œå‘é€åˆ°ä»“åº“è®¨è®º
              const repo = context.repo;
              const discussionTitle = "å·¥ä½œæµå¤±è´¥é€šçŸ¥";
              
              // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è®¨è®º
              const discussions = await github.rest.discussions.listForRepo({
                owner: repo.owner,
                repo: repo.repo,
                per_page: 1,
                direction: 'desc'
              });
              
              // åˆ›å»ºæˆ–æ›´æ–°è®¨è®º
              if (discussions.data.length > 0) {
                const discussion = discussions.data[0];
                await github.rest.discussions.updateComment({
                  owner: repo.owner,
                  repo: repo.repo,
                  discussion_number: discussion.number,
                  comment_number: discussion.comments[0]?.number || 0,
                  body: `### ğŸš¨ å·¥ä½œæµå¤±è´¥é€šçŸ¥\n\n` +
                        `**å·¥ä½œæµ**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n` +
                        `**å¤±è´¥æ—¶é—´**: ${new Date().toISOString()}\n` +
                        `**åŸå› **: APKåŒæ­¥å¤±è´¥\n\n` +
                        `è¯·æ£€æŸ¥å·¥ä½œæµæ—¥å¿—ä»¥è·å–è¯¦ç»†ä¿¡æ¯ã€‚`
                });
              } else {
                await github.rest.discussions.create({
                  owner: repo.owner,
                  repo: repo.repo,
                  title: discussionTitle,
                  body: `### ğŸš¨ å·¥ä½œæµå¤±è´¥é€šçŸ¥\n\n` +
                        `**å·¥ä½œæµ**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n` +
                        `**å¤±è´¥æ—¶é—´**: ${new Date().toISOString()}\n` +
                        `**åŸå› **: APKåŒæ­¥å¤±è´¥\n\n` +
                        `è¯·æ£€æŸ¥å·¥ä½œæµæ—¥å¿—ä»¥è·å–è¯¦ç»†ä¿¡æ¯ã€‚`,
                  category: "GENERAL"
                });
              }
            }
          } catch (error) {
            console.error('é€šçŸ¥å¤±è´¥:', error);
            // å›é€€åˆ°åŸºæœ¬æ—¥å¿—è¾“å‡º
            core.warning('æ— æ³•å‘é€é€šçŸ¥ï¼Œè¯·æ‰‹åŠ¨æ£€æŸ¥å·¥ä½œæµå¤±è´¥æƒ…å†µ');
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}