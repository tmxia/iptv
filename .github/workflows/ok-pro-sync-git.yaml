name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20åˆ†é’Ÿè¶…æ—¶
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install Android SDK for aapt2
      run: |
        SDK_TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-10406996_latest.zip"
        curl -sL "$SDK_TOOLS_URL" -o sdk-tools.zip
        unzip -q sdk-tools.zip -d android-sdk
        
        echo "ANDROID_SDK_ROOT=$GITHUB_WORKSPACE/android-sdk" >> $GITHUB_ENV
        echo "$GITHUB_WORKSPACE/android-sdk/cmdline-tools/bin" >> $GITHUB_PATH
        
        yes | android-sdk/cmdline-tools/bin/sdkmanager --sdk_root=$GITHUB_WORKSPACE/android-sdk "build-tools;34.0.0"
        echo "aapt2è·¯å¾„: $GITHUB_WORKSPACE/android-sdk/build-tools/34.0.0/aapt2"
        
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip
        pip install telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL || 'tvb_ys' }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = os.path.join(os.getcwd(), "temp_apks")
        GIT_DIR = os.getcwd()
        ANDROID_SDK_ROOT = os.environ.get('ANDROID_SDK_ROOT', '/usr/local/lib/android/sdk')
        AAPT2_PATH = f"{ANDROID_SDK_ROOT}/build-tools/34.0.0/aapt2"
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹ï¼ˆé˜²æ­¢å†²çªï¼‰
                log.info("æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹...")
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                
                log.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # åªæ·»åŠ apkç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", APK_DIR, "version.txt"], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # é‡è¯•æœºåˆ¶ï¼ˆæœ€å¤š3æ¬¡ï¼‰
                max_attempts = 3
                for attempt in range(1, max_attempts + 1):
                    try:
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹å¹¶å˜åŸº...")
                        subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                        
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ¨é€æ›´æ”¹...")
                        subprocess.run(
                            ["git", "push", repo_url, "HEAD:main"],
                            cwd=GIT_DIR,
                            check=True
                        )
                        log.info("æ¨é€æˆåŠŸ")
                        return True
                    except subprocess.CalledProcessError as e:
                        log.warning(f"å°è¯• {attempt} å¤±è´¥: {str(e)}")
                        if attempt < max_attempts:
                            log.info("ç­‰å¾…10ç§’åé‡è¯•...")
                            time.sleep(10)
                        else:
                            log.error(f"ç»è¿‡{max_attempts}æ¬¡å°è¯•åä»æ— æ³•æ¨é€æ›´æ”¹")
                            return False
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_current_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œè¿”å›å­—å…¸å’Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨æ ‡å¿—"""
            version_path = os.path.join(GIT_DIR, "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f), True
                except json.JSONDecodeError:
                    log.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œé‡æ–°åˆå§‹åŒ–")
                    return {}, True
                except Exception as e:
                    log.warning(f"è¯»å–ç‰ˆæœ¬æ–‡ä»¶å¤±è´¥: {str(e)}ï¼Œé‡æ–°åˆå§‹åŒ–")
                    return {}, True
            return {}, False
        
        def update_versions(versions):
            version_path = os.path.join(GIT_DIR, "version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def extract_apk_version(apk_path):
            """ä½¿ç”¨aapt2ä»APKæå–ç‰ˆæœ¬å·"""
            try:
                result = subprocess.run(
                    [AAPT2_PATH, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # æŸ¥æ‰¾versionName
                for line in result.stdout.splitlines():
                    if "versionName" in line:
                        match = re.search(r"versionName='([^']*)'", line)
                        if match:
                            version = match.group(1)
                            # ç¡®ä¿ç‰ˆæœ¬å·ä»¥"v"å¼€å¤´
                            if not version.startswith('v'):
                                version = 'v' + version
                            return version
                return None
            except Exception as e:
                log.error(f"æå–ç‰ˆæœ¬å·å¤±è´¥: {str(e)}")
                return None
        
        async def download_apk(client, message, filename):
            download_path = os.path.join(WORK_DIR, filename)
            total_size = message.document.size
            
            # ç®€åŒ–ä¸‹è½½æ—¥å¿— - åªæ˜¾ç¤ºå¼€å§‹å’Œå®Œæˆ
            log.info(f"å¼€å§‹ä¸‹è½½: {filename} ({format_size(total_size)})")
            start_time = time.time()
            
            # ä¸‹è½½æ–‡ä»¶
            await client.download_media(message, file=download_path)
            
            # è®¡ç®—ä¸‹è½½é€Ÿåº¦
            elapsed = time.time() - start_time
            avg_speed = total_size / elapsed if elapsed > 0 else 0
            log.info(f"ä¸‹è½½å®Œæˆ: {filename} - è€—æ—¶: {elapsed:.1f}ç§’, å¹³å‡é€Ÿåº¦: {format_size(avg_speed)}/s")
            
            # ä»APKæå–ç‰ˆæœ¬å·
            version = extract_apk_version(download_path)
            if not version:
                # å¦‚æœæ— æ³•æå–ç‰ˆæœ¬å·ï¼Œä½¿ç”¨æ—¥æœŸä½œä¸ºåå¤‡
                date_str = message.date.strftime("%Y%m%d")
                version = f"v{filename.split('.')[0]}-{date_str}"
                log.info(f"ä½¿ç”¨åå¤‡ç‰ˆæœ¬å·: {version}")
            
            # åªä¿ç•™æ—¥æœŸéƒ¨åˆ†ï¼ˆYYYY-MM-DDï¼‰
            date_iso = message.date.strftime("%Y-%m-%d")
            
            return {
                "path": download_path,
                "version": version,
                "date_iso": date_iso
            }
        
        def should_download_apk(filename, msg_date, current_versions, version_file_exists):
            """æ™ºèƒ½åˆ¤æ–­æ˜¯å¦éœ€è¦ä¸‹è½½APK"""
            # å¦‚æœç‰ˆæœ¬æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ€»æ˜¯éœ€è¦ä¸‹è½½
            if not version_file_exists:
                log.info(f"ç‰ˆæœ¬æ–‡ä»¶ä¸å­˜åœ¨ï¼Œéœ€è¦ä¸‹è½½ {filename}")
                return True
            
            # å¦‚æœè¯¥APKåœ¨ç‰ˆæœ¬æ–‡ä»¶ä¸­æ²¡æœ‰è®°å½•ï¼Œéœ€è¦ä¸‹è½½
            if filename not in current_versions:
                log.info(f"APK {filename} åœ¨ç‰ˆæœ¬æ–‡ä»¶ä¸­æ— è®°å½•ï¼Œéœ€è¦ä¸‹è½½")
                return True
            
            # è§£æç‰ˆæœ¬æ–‡ä»¶ä¸­çš„æ—¥æœŸ
            current_value = current_versions[filename]
            if ',' in current_value:
                current_version, current_date_str = current_value.split(',', 1)
            else:
                # æ—§æ ¼å¼å…¼å®¹ - åªæœ‰ç‰ˆæœ¬å·
                current_version = current_value
                current_date_str = "1970-01-01"  # è®¾ç½®ä¸ºå¾ˆæ—§çš„æ—¥æœŸå¼ºåˆ¶æ›´æ–°
            
            # å°†æ¶ˆæ¯æ—¥æœŸè½¬æ¢ä¸ºæ—¥æœŸå­—ç¬¦ä¸²ï¼ˆYYYY-MM-DDï¼‰
            utc8 = pytz.timezone('Asia/Shanghai')
            msg_date_utc8 = msg_date.astimezone(utc8)
            msg_date_str = msg_date_utc8.strftime("%Y-%m-%d")
            
            # å¦‚æœæ¶ˆæ¯æ—¥æœŸæ¯”è®°å½•æ—¥æœŸæ–°ï¼Œéœ€è¦ä¸‹è½½
            if msg_date_str > current_date_str:
                log.info(f"æ–°å‘å¸ƒæ—¥æœŸ: {msg_date_str} > å½“å‰æ—¥æœŸ: {current_date_str}ï¼Œéœ€è¦ä¸‹è½½")
                return True
            
            # å¦‚æœæ¶ˆæ¯æ—¥æœŸæ¯”è®°å½•æ—¥æœŸæ—©ï¼Œä¸éœ€è¦ä¸‹è½½
            if msg_date_str < current_date_str:
                log.info(f"æ¶ˆæ¯æ—¥æœŸ {msg_date_str} æ—©äºå½“å‰æ—¥æœŸ {current_date_str}ï¼Œè·³è¿‡ä¸‹è½½")
                return False
            
            # åŒä¸€å¤©çš„æƒ…å†µ - ä¸éœ€è¦ä¸‹è½½ï¼ˆå‡è®¾åŒä¸€å¤©ä¸ä¼šæœ‰å¤šä¸ªç‰ˆæœ¬ï¼‰
            log.info(f"åŒä¸€å¤©å‘å¸ƒçš„æ¶ˆæ¯ ({msg_date_str})ï¼Œç‰ˆæœ¬ç›¸åŒåˆ™è·³è¿‡")
            return False
        
        async def find_new_apks(client):
            log.info("è¿æ¥Telegram...")
            await client.connect()
            if not await client.is_user_authorized():
                log.error("é”™è¯¯: Telegramä¼šè¯æ— æ•ˆ")
                return None
            
            channel = os.environ.get('TELEGRAM_CHANNEL', 'tvb_ys')
            log.info(f"æ‰«æé¢‘é“: {channel}")
            entity = await client.get_entity(channel)
            
            # è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
            current_versions, version_file_exists = get_current_versions()
            updates = {}
            
            # è·å–é¢‘é“ä¸­æœ€æ–°çš„50æ¡æ¶ˆæ¯
            latest_msgs = {}
            async for msg in client.iter_messages(entity, limit=50):
                if msg.media and hasattr(msg.media, "document"):
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            if filename in APK_FILES:
                                # åªä¿ç•™æ¯ä¸ªæ–‡ä»¶çš„æœ€æ–°æ¶ˆæ¯
                                if filename not in latest_msgs or msg.date > latest_msgs[filename].date:
                                    latest_msgs[filename] = msg
            
            # å¤„ç†æ¯ä¸ªAPKæ–‡ä»¶
            for filename, msg in latest_msgs.items():
                # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸‹è½½
                if not should_download_apk(filename, msg.date, current_versions, version_file_exists):
                    continue
                
                # ä¸‹è½½APK
                apk_data = await download_apk(client, msg, filename)
                if not apk_data:
                    continue
                
                # æ£€æŸ¥å½“å‰ç‰ˆæœ¬
                current_value = current_versions.get(filename, "")
                if ',' in current_value:
                    current_version = current_value.split(',')[0]
                else:
                    current_version = current_value
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ–°ç‰ˆæœ¬
                if apk_data["version"] != current_version:
                    log.info(f"å‘ç°æ–°ç‰ˆæœ¬: {filename} ({current_version} â†’ {apk_data['version']})")
                    updates[filename] = apk_data
                else:
                    # å³ä½¿æ—¥æœŸä¸åŒä½†ç‰ˆæœ¬ç›¸åŒï¼Œè·³è¿‡æ›´æ–°
                    log.info(f"{filename} ç‰ˆæœ¬ç›¸åŒ ({current_version})ï¼Œè·³è¿‡æ›´æ–°")
            
            return updates if updates else None
        
        def main():
            log.info("="*50)
            log.info("APK åŒæ­¥å·¥å…·å¯åŠ¨")
            log.info("="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log.error(f"é”™è¯¯: ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                with client:
                    new_apks = client.loop.run_until_complete(find_new_apks(client))
            except Exception as e:
                log.error(f"Telegramé”™è¯¯: {str(e)}")
                return 3
            
            # è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
            current_versions, _ = get_current_versions()
            updated = False
            
            if new_apks:
                # å¤„ç†æ–°æ–‡ä»¶
                target_dir = os.path.join(GIT_DIR, APK_DIR)
                os.makedirs(target_dir, exist_ok=True)
                
                for filename, data in new_apks.items():
                    target_path = os.path.join(target_dir, filename)
                    shutil.copy2(data["path"], target_path)
                    
                    # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯ä¸º "ç‰ˆæœ¬å·,æ—¥æœŸ" æ ¼å¼ (YYYY-MM-DD)
                    new_value = f"{data['version']},{data['date_iso']}"
                    current_versions[filename] = new_value
                    log.info(f"å·²æ›´æ–°: {filename} (ç‰ˆæœ¬: {new_value})")
                    updated = True
                
                # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                update_versions(current_versions)
                
                # æäº¤æ›´æ”¹
                commit_msg = f"æ›´æ–°APK: {', '.join(new_apks.keys())}"
                if commit_and_push(commit_msg):
                    log.info(f"åŒæ­¥æˆåŠŸ! æ›´æ–°äº† {len(new_apks)} ä¸ªæ–‡ä»¶")
                else:
                    log.error("æäº¤å¤±è´¥")
                    return 4
            else:
                log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
            
            # æ£€æŸ¥APKæ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ˆä¼ ç»Ÿæ£€æŸ¥ï¼‰
            target_dir = os.path.join(GIT_DIR, APK_DIR)
            file_missing = False
            for filename in APK_FILES:
                file_path = os.path.join(target_dir, filename)
                if not os.path.exists(file_path):
                    log.error(f"é”™è¯¯: APKæ–‡ä»¶ä¸å­˜åœ¨: {filename}")
                    file_missing = True
            
            if file_missing and not updated:
                log.error("å…³é”®é”™è¯¯: ç¼ºå°‘APKæ–‡ä»¶ä¸”æœªæ›´æ–°")
                return 5
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log.info("ä¸´æ—¶ç›®å½•å·²æ¸…ç†")
            
            log.info("="*50)
            log.info("åŒæ­¥ä»»åŠ¡å®Œæˆ")
            log.info("="*50)
            return 0
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          const message = `ğŸš¨ Telegram APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          })

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}
