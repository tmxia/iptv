name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: Cache pip packages
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Cache Android SDK
      uses: actions/cache@v4
      with:
        path: |
          ~/.android/cache
          $ANDROID_HOME/build-tools
        key: ${{ runner.os }}-android-${{ hashFiles('**/version.txt') }}
        restore-keys: |
          ${{ runner.os }}-android-

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
        cache: 'pip'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl

    - name: Create requirements file
      run: |
        echo "telethon>=1.28.5" > requirements.txt
        echo "requests>=2.31.0" >> requirements.txt
        echo "pytz>=2023.3" >> requirements.txt

    - name: Install Python dependencies
      run: |
        pip install -r requirements.txt

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        import asyncio
        import socket
        from datetime import datetime, timedelta
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        WORK_DIR = "temp_apks"
        VERSION_FILE = "version.txt"
        
        # ç¡¬ç¼–ç çš„Telegramé¢‘é“
        TELEGRAM_CHANNELS = ["tvb_ys", "tvboxjk"]
        
        # è®¾ç½®ç®€åŒ–çš„æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%H:%M:%S'
        )
        logger = logging.getLogger()
        
        # DNSä¼˜åŒ– - ä¼˜å…ˆä½¿ç”¨IPv4
        original_getaddrinfo = socket.getaddrinfo
        def getaddrinfo_prefer_ipv4(host, port, family=0, type=0, proto=0, flags=0):
            try:
                return original_getaddrinfo(host, port, socket.AF_INET, type, proto, flags)
            except socket.gaierror:
                return original_getaddrinfo(host, port, family, type, proto, flags)
        socket.getaddrinfo = getaddrinfo_prefer_ipv4
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def git_setup():
            """é…ç½®Gitç”¨æˆ·ä¿¡æ¯"""
            actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
            email = f"{actor}@users.noreply.github.com"
            
            subprocess.run(["git", "config", "user.name", actor], check=True)
            subprocess.run(["git", "config", "user.email", email], check=True)
            
            # æ‹‰å–æœ€æ–°æ›´æ”¹
            subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
            return True
        
        def git_commit_push(message):
            """æäº¤å¹¶æ¨é€æ›´æ”¹"""
            try:
                # åªæ·»åŠ apkç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(
                    ["git", "status", "--porcelain", "--untracked-files=no"],
                    capture_output=True, text=True, check=True
                )
                if not status.stdout.strip():
                    logger.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                # ä½¿ç”¨Tokenæ¨é€
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                logger.info("æ¨é€æˆåŠŸ")
                return True
            except Exception as e:
                logger.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯"""
            if not os.path.exists(VERSION_FILE):
                return {}
            
            try:
                with open(VERSION_FILE, "r") as f:
                    versions = json.load(f)
                    if not isinstance(versions, dict):
                        logger.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼æ— æ•ˆï¼Œé‡ç½®ä¸ºç©ºå­—å…¸")
                        return {}
                    return versions
            except Exception as e:
                logger.error(f"ç‰ˆæœ¬æ–‡ä»¶è¯»å–å¤±è´¥: {str(e)}")
                return {}
        
        def update_versions(new_versions):
            """æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(VERSION_FILE, "w") as f:
                json.dump(versions, f, indent=2)
                
            for apk, ver in new_versions.items():
                logger.info(f"æ›´æ–°: {apk} => {ver}")
        
        def extract_apk_version(apk_path):
            """ä½¿ç”¨aapt2ä»APKæå–ç‰ˆæœ¬å·"""
            try:
                aapt2 = os.path.join(
                    os.environ['ANDROID_HOME'],
                    "build-tools/34.0.0/aapt2"
                )
                
                result = subprocess.run(
                    [aapt2, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # æŸ¥æ‰¾versionName
                match = re.search(r"versionName='([^']*)'", result.stdout)
                if match:
                    version = match.group(1)
                    return f"v{version}" if not version.startswith('v') else version
                return None
            except Exception as e:
                logger.error(f"æå–ç‰ˆæœ¬å·å¤±è´¥: {str(e)}")
                return None
        
        async def download_with_retry(client, message, target_filename, original_filename, channel_name, max_retries=2):
            """å¸¦é‡è¯•çš„ä¸‹è½½å‡½æ•°"""
            for attempt in range(1, max_retries + 1):
                try:
                    return await download_apk(client, message, target_filename, original_filename, channel_name)
                except Exception as e:
                    logger.warning(f"ä¸‹è½½å°è¯• {attempt}/{max_retries} å¤±è´¥: {str(e)}")
                    if attempt == max_retries:
                        raise e
                    await asyncio.sleep(3 * attempt)
        
        async def download_apk(client, message, target_filename, original_filename, channel_name):
            """ä¸‹è½½APKæ–‡ä»¶å¹¶æå–å…ƒæ•°æ®"""
            download_path = os.path.join(WORK_DIR, target_filename)
            total_size = message.document.size
            
            logger.info(f"ä¸‹è½½: {original_filename} ({format_size(total_size)})")
            
            start_time = time.time()
            await client.download_media(
                message, 
                file=download_path,
                progress_callback=None
            )
            
            elapsed = time.time() - start_time
            download_speed = total_size / elapsed / 1024 / 1024
            logger.info(f"ä¸‹è½½å®Œæˆ: {elapsed:.1f}ç§’ ({download_speed:.1f}MB/s)")
            
            if not os.path.exists(download_path):
                raise FileNotFoundError(f"æ–‡ä»¶ä¸‹è½½å¤±è´¥: {download_path}")
            
            # é’ˆå¯¹tvboxjké¢‘é“ä¼˜å…ˆä½¿ç”¨æ–‡ä»¶åä¸­çš„ç‰ˆæœ¬å·
            if channel_name == "tvboxjk":
                # ç²¾ç¡®åŒ¹é…ç‰ˆæœ¬å·æ ¼å¼
                ver_match = re.search(r'([\d.]+)\.apk$', original_filename)
                if ver_match:
                    version = f"v{ver_match.group(1)}"
                    return {
                        "path": download_path,
                        "version": version,
                        "date": message.date.strftime("%Y-%m-%d")
                    }
            
            # å…¶ä»–æƒ…å†µä½¿ç”¨aapt2æå–ç‰ˆæœ¬å·
            version = extract_apk_version(download_path)
            if not version:
                ver_match = re.search(r'([\d.]+)\.apk$', original_filename)
                if ver_match:
                    version = f"v{ver_match.group(1)}"
                else:
                    version = f"v{target_filename.split('.')[0]}-{message.date.strftime('%Y%m%d')}"
            
            return {
                "path": download_path,
                "version": version,
                "date": message.date.strftime("%Y-%m-%d")
            }
        
        def map_filename(original_name, channel_name):
            """å°†åŸå§‹æ–‡ä»¶åæ˜ å°„åˆ°æ ‡å‡†æ–‡ä»¶å - ç²¾ç¡®åŒ¹é…ç‰ˆæœ¬"""
            # ç²¾ç¡®æ’é™¤æ¨¡æ‹Ÿå™¨ä¸“ç‰ˆ
            if "æ¨¡æ‹Ÿå™¨" in original_name or "æ¨¡æ‹Ÿå™¨ä¸“ç‰ˆ" in original_name:
                return None
            
            # ç¬¬ä¸€ä¸ªé¢‘é“çš„ç›´æ¥åŒ¹é…
            if channel_name == "tvb_ys" and original_name in APK_FILES:
                return original_name
            
            # ç¬¬äºŒä¸ªé¢‘é“çš„ç²¾ç¡®æ–‡ä»¶ååŒ¹é…
            if channel_name == "tvboxjk":
                # ç²¾ç¡®åŒ¹é…OKå½±è§†Proç³»åˆ—æ–‡ä»¶å
                # åŒ¹é…æ ¼å¼: OKå½±è§†Proï¹£æ‰‹æœºç‰ˆï¹£-3.5.3.apk æˆ– OKå½±è§†Proï¹£ç”µè§†ç‰ˆï¹£3.5.3.apk
                if "OKå½±è§†Pro" in original_name:
                    if "æ‰‹æœºç‰ˆ" in original_name:
                        logger.info(f"ç²¾ç¡®åŒ¹é…æ‰‹æœºç‰ˆ: {original_name}")
                        return "mobile-pro.apk"
                    elif "ç”µè§†ç‰ˆ" in original_name:
                        logger.info(f"ç²¾ç¡®åŒ¹é…ç”µè§†ç‰ˆ: {original_name}")
                        return "leanback-pro.apk"
                
                # åŒæ—¶æ”¯æŒå¯èƒ½çš„å˜ä½“æ ¼å¼
                # ä¾‹å¦‚: OKå½±è§†Pro-æ‰‹æœºç‰ˆ-3.5.3.apk (ä½¿ç”¨åŠè§’å‡å·)
                if "OKå½±è§†Pro" in original_name:
                    if "æ‰‹æœºç‰ˆ" in original_name or "mobile" in original_name.lower():
                        logger.info(f"å˜ä½“åŒ¹é…æ‰‹æœºç‰ˆ: {original_name}")
                        return "mobile-pro.apk"
                    elif "ç”µè§†ç‰ˆ" in original_name or "tv" in original_name.lower() or "leanback" in original_name.lower():
                        logger.info(f"å˜ä½“åŒ¹é…ç”µè§†ç‰ˆ: {original_name}")
                        return "leanback-pro.apk"
            
            return None
        
        async def check_channel(client, channel_name, current_versions):
            """æ£€æŸ¥å•ä¸ªTelegramé¢‘é“ä¸­çš„æ–°APK"""
            logger.info(f"æ£€æŸ¥é¢‘é“: {channel_name}")
            
            try:
                entity = await client.get_entity(channel_name)
            except Exception as e:
                logger.error(f"è¿æ¥é¢‘é“å¤±è´¥: {str(e)}")
                return {}
            
            updates = {}
            processed_targets = set()
            
            message_count = 0
            async for msg in client.iter_messages(entity, limit=15):
                if message_count >= 10:
                    break
                    
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                        
                    original_name = attr.file_name
                    if not original_name.lower().endswith('.apk'):
                        continue
                        
                    target_name = map_filename(original_name, channel_name)
                    if not target_name or target_name in processed_targets:
                        continue
                    
                    processed_targets.add(target_name)
                    message_count += 1
                    
                    current = current_versions.get(target_name, "")
                    msg_date = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                    
                    skip_download = False
                    if current:
                        try:
                            stored_version, stored_date = current.split(',')
                            # å¯¹äºtvboxjké¢‘é“ï¼Œä½¿ç”¨æ–‡ä»¶åä¸­çš„ç‰ˆæœ¬å·è¿›è¡Œç²¾ç¡®æ¯”è¾ƒ
                            if channel_name == "tvboxjk":
                                ver_match = re.search(r'([\d.]+)\.apk$', original_name)
                                if ver_match:
                                    file_version = f"v{ver_match.group(1)}"
                                    if stored_version.strip() == file_version and msg_date <= stored_date.strip():
                                        logger.info(f"è·³è¿‡ç›¸åŒç‰ˆæœ¬: {target_name} ({file_version})")
                                        skip_download = True
                            else:
                                if msg_date <= stored_date.strip():
                                    skip_download = True
                        except (IndexError, ValueError):
                            pass
                    
                    if not skip_download:
                        try:
                            apk_data = await download_with_retry(client, msg, target_name, original_name, channel_name)
                            new_value = f"{apk_data['version']},{apk_data['date']}"
                            
                            if current != new_value:
                                updates[target_name] = new_value
                                logger.info(f"å‘ç°æ–°ç‰ˆæœ¬: {target_name} ({new_value})")
                            else:
                                logger.info(f"ç‰ˆæœ¬æœªå˜åŒ–: {target_name}")
                                os.remove(apk_data['path'])
                        except Exception as e:
                            logger.error(f"ä¸‹è½½å¤±è´¥: {original_name}, é”™è¯¯: {str(e)}")
                    
                    if len(processed_targets) >= 2:
                        break
            
            return updates
        
        async def main_async():
            """å¼‚æ­¥ä¸»å‡½æ•°"""
            logger.info("APKåŒæ­¥å¼€å§‹")
            
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                raise ValueError(f"ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
            
            start_time = time.time()
            git_setup()
            
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            current_versions = get_versions()
            logger.info(f"å½“å‰ç‰ˆæœ¬: {current_versions}")
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH'],
                connection_retries=3,
                retry_delay=2,
                auto_reconnect=True,
                timeout=120
            )
            
            all_updates = {}
            
            async with client:
                for channel in TELEGRAM_CHANNELS:
                    try:
                        updates = await check_channel(client, channel, current_versions)
                        if updates:
                            all_updates.update(updates)
                            current_versions.update(updates)
                            logger.info(f"é¢‘é“ {channel} å‘ç° {len(updates)} ä¸ªæ›´æ–°")
                        else:
                            logger.info(f"é¢‘é“ {channel} æ— æ›´æ–°")
                    except Exception as e:
                        logger.error(f"å¤„ç†é¢‘é“ {channel} æ—¶å‡ºé”™: {str(e)}")
            
            if all_updates:
                logger.info(f"æ€»å…±å‘ç° {len(all_updates)} ä¸ªæ›´æ–°")
                
                for apk in all_updates.keys():
                    src = os.path.join(WORK_DIR, apk)
                    if os.path.exists(src):
                        dst = os.path.join(APK_DIR, apk)
                        shutil.copy2(src, dst)
                        logger.info(f"å·²å¤åˆ¶: {apk}")
                
                update_versions(all_updates)
                
                commit_msg = f"æ›´æ–°APK: {', '.join(all_updates.keys())}"
                if git_commit_push(commit_msg):
                    logger.info("æ‰€æœ‰æ›´æ–°å·²æˆåŠŸæäº¤")
                else:
                    logger.error("æäº¤å¤±è´¥")
            else:
                logger.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
            
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            
            total_time = time.time() - start_time
            logger.info(f"åŒæ­¥ä»»åŠ¡å®Œæˆï¼Œæ€»è€—æ—¶: {total_time:.1f}ç§’")
            return 0
        
        if __name__ == "__main__":
            try:
                asyncio.run(main_async())
            except Exception as e:
                logging.error(f"ä¸¥é‡é”™è¯¯: {str(e)}")
                sys.exit(1)
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 5
          retain_days: 3
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}