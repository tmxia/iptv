name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock 🔒
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # 配置参数
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        WORK_DIR = "temp_apks"
        VERSION_FILE = "version.txt"
        
        # 硬编码的Telegram频道
        TELEGRAM_CHANNELS = ["tvb_ys", "tvboxjk"]
        
        # 设置日志
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        logger = logging.getLogger()
        
        def format_size(size):
            """将字节数转换为易读的格式"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def git_setup():
            """配置Git用户信息"""
            actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
            email = f"{actor}@users.noreply.github.com"
            
            subprocess.run(["git", "config", "user.name", actor], check=True)
            subprocess.run(["git", "config", "user.email", email], check=True)
            logger.info("Git配置完成")
            
            # 拉取最新更改
            logger.info("拉取远程最新更改...")
            subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
            return True
        
        def git_commit_push(message):
            """提交并推送更改"""
            try:
                # 只添加apk目录和版本文件
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], check=True)
                
                # 检查是否有更改（忽略未跟踪文件）
                status = subprocess.run(
                    ["git", "status", "--porcelain", "--untracked-files=no"],
                    capture_output=True, text=True, check=True
                )
                if not status.stdout.strip():
                    logger.info("没有更改需要提交")
                    return True
                
                # 提交更改
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                # 使用Token推送
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                logger.info("推送成功")
                return True
            except Exception as e:
                logger.error(f"Git操作失败: {str(e)}")
                return False
        
        def get_versions():
            """获取当前版本信息并验证键值结构"""
            if not os.path.exists(VERSION_FILE):
                return {}
            
            try:
                with open(VERSION_FILE, "r") as f:
                    versions = json.load(f)
                    # 验证是否为字典格式
                    if not isinstance(versions, dict):
                        logger.warning("版本文件格式无效，重置为空字典")
                        return {}
                    return versions
            except Exception as e:
                logger.error(f"版本文件读取失败: {str(e)}")
                return {}
        
        def update_versions(new_versions):
            """更新版本文件"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(VERSION_FILE, "w") as f:
                json.dump(versions, f, indent=2)
                logger.info("版本文件已更新")
                
                # 仅显示关心的键值版本信息
                for apk, ver in new_versions.items():
                    logger.info(f"版本更新: {apk} => {ver}")
        
        def extract_apk_version(apk_path):
            """使用aapt2从APK提取版本号"""
            try:
                aapt2 = os.path.join(
                    os.environ['ANDROID_HOME'],
                    "build-tools/34.0.0/aapt2"
                )
                
                result = subprocess.run(
                    [aapt2, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # 查找versionName
                match = re.search(r"versionName='([^']*)'", result.stdout)
                if match:
                    version = match.group(1)
                    return f"v{version}" if not version.startswith('v') else version
                return None
            except Exception as e:
                logger.error(f"提取版本号失败: {str(e)}")
                return None
        
        async def download_apk(client, message, target_filename, original_filename):
            """下载APK文件并提取元数据"""
            download_path = os.path.join(WORK_DIR, target_filename)
            total_size = message.document.size
            logger.info(f"开始下载: {original_filename} -> {target_filename} ({format_size(total_size)})")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            logger.info(f"下载完成: 耗时{elapsed:.1f}秒")
            
            # 验证文件是否成功下载
            if not os.path.exists(download_path):
                raise FileNotFoundError(f"文件下载失败: {download_path}")
            
            # 提取版本信息
            version = extract_apk_version(download_path)
            if not version:
                # 尝试从原始文件名提取版本号
                ver_match = re.search(r'[-﹣]([\d.]+)\.apk$', original_filename)
                if ver_match:
                    version = f"v{ver_match.group(1)}"
                    logger.info(f"从文件名提取版本号: {version}")
                else:
                    version = f"v{target_filename.split('.')[0]}-{message.date.strftime('%Y%m%d')}"
                    logger.info(f"使用后备版本号: {version}")
            
            return {
                "path": download_path,
                "version": version,
                "date": message.date.strftime("%Y-%m-%d")
            }
        
        def map_filename(original_name):
            """将原始文件名映射到标准文件名"""
            # 精确排除模拟器专版
            if "模拟器" in original_name or "模拟器专版" in original_name:
                return None
            
            # 第一个频道的直接匹配
            if original_name in APK_FILES:
                return original_name
            
            # 第二个频道的文件名映射规则
            if "电视版" in original_name or "leanback" in original_name.lower():
                return "leanback-pro.apk"
            elif "手机版" in original_name or "mobile" in original_name.lower():
                return "mobile-pro.apk"
            
            return None
        
        async def check_channel(client, channel_name, current_versions):
            """检查单个Telegram频道中的新APK"""
            logger.info(f"连接Telegram频道: {channel_name}")
            entity = await client.get_entity(channel_name)
            
            updates = {}
            processed_targets = set()
            
            # 第一遍扫描：仅收集消息ID和日期，不下载
            message_candidates = []
            async for msg in client.iter_messages(entity, limit=20):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                        
                    original_name = attr.file_name
                    target_name = map_filename(original_name)
                    
                    if not target_name:
                        continue
                    
                    # 避免重复处理同一目标文件
                    if target_name in processed_targets:
                        continue
                    processed_targets.add(target_name)
                    
                    # 检查是否需要下载
                    current = current_versions.get(target_name, "")
                    msg_date = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                    
                    # 版本对比逻辑 - 修复点：正确使用版本文件中的信息
                    skip = False
                    if current:
                        try:
                            # 正确解析版本文件中的信息
                            stored_version, stored_date = current.split(',')
                            stored_version = stored_version.strip()
                            stored_date = stored_date.strip()
                            
                            # 调试信息
                            logger.info(f"版本对比: {target_name} | 存储: {stored_version},{stored_date} | 消息日期: {msg_date}")
                            
                            # 严格版本对比
                            if msg_date < stored_date:
                                logger.info(f"跳过旧版本: {target_name} ({msg_date} < {stored_date})")
                                skip = True
                            elif msg_date == stored_date:
                                # 同一天版本需要进一步检查
                                logger.info(f"同一天版本: {target_name} ({msg_date})，等待进一步检查")
                        except (IndexError, ValueError) as e:
                            logger.warning(f"版本文件格式错误({current})，继续处理: {str(e)}")
                    
                    # 目标文件不存在时强制更新
                    target_path = os.path.join(APK_DIR, target_name)
                    if not os.path.exists(target_path):
                        logger.warning(f"目标文件不存在，强制更新: {target_name}")
                        skip = False
                    
                    if not skip:
                        message_candidates.append((msg, target_name, original_name))
                        logger.info(f"添加候选: {target_name} ({original_name})")
            
            # 第二遍处理：按时间倒序处理候选消息
            message_candidates.sort(key=lambda x: x[0].date, reverse=True)
            logger.info(f"频道 {channel_name} 共有 {len(message_candidates)} 个候选APK")
            
            # 处理候选消息
            for msg, target_name, original_name in message_candidates:
                try:
                    apk_data = await download_apk(client, msg, target_name, original_name)
                    new_value = f"{apk_data['version']},{apk_data['date']}"
                    
                    # 下载后再次验证版本
                    current_value = current_versions.get(target_name, "")
                    if current_value == new_value:
                        logger.info(f"跳过相同版本: {target_name} (当前: {current_value} == 新: {new_value})")
                        os.remove(apk_data['path'])  # 删除临时文件
                    else:
                        updates[target_name] = new_value
                        logger.info(f"发现新版本: {target_name} (当前: {current_value} → 新: {new_value})")
                        # 成功获取更新后不再处理同类型文件
                        processed_targets.add(target_name)
                except Exception as e:
                    logger.error(f"下载失败: {original_name} -> {target_name}, 错误: {str(e)}")
            
            return updates
        
        async def main_async():
            """异步主函数"""
            logger.info("="*50 + "\nAPK 同步工具启动\n" + "="*50)
            
            # 验证环境变量
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                raise ValueError(f"缺少环境变量: {', '.join(missing)}")
            
            git_setup()
            # 确保清理临时目录
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            # 获取当前版本
            current_versions = get_versions()
            logger.info(f"当前版本信息: {json.dumps(current_versions, indent=2)}")
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            all_updates = {}
            
            async with client:
                # 检查所有硬编码的频道
                for channel in TELEGRAM_CHANNELS:
                    try:
                        logger.info(f"开始检查频道: {channel}")
                        updates = await check_channel(client, channel, current_versions)
                        all_updates.update(updates)
                        
                        # 更新当前版本信息用于后续频道检查
                        current_versions.update(updates)
                        logger.info(f"频道 {channel} 检查完成，更新: {len(updates)} 个APK")
                    except Exception as e:
                        logger.error(f"处理频道 {channel} 时出错: {str(e)}")
                        # 继续处理下一个频道
            
            if all_updates:
                logger.info(f"发现 {len(all_updates)} 个APK需要更新")
                
                # 复制APK文件到仓库
                for apk in all_updates.keys():
                    src = os.path.join(WORK_DIR, apk)
                    if not os.path.exists(src):
                        logger.error(f"源文件不存在: {src}")
                        raise FileNotFoundError(f"APK文件未成功下载: {apk}")
                    
                    dst = os.path.join(APK_DIR, apk)
                    shutil.copy2(src, dst)
                    logger.info(f"已复制: {apk} 到 {dst}")
                
                # 更新版本文件
                update_versions(all_updates)
                
                # 提交更改
                commit_msg = f"更新APK: {', '.join(all_updates.keys())}"
                if not git_commit_push(commit_msg):
                    raise RuntimeError("提交失败")
                else:
                    logger.info("所有更新已成功提交")
            else:
                logger.info("没有需要更新的APK文件")
            
            # 清理临时目录
            logger.info("清理临时目录...")
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            
            logger.info("="*50 + "\n同步任务完成\n" + "="*50)
            return 0
        
        if __name__ == "__main__":
            try:
                from asyncio import run
                run(main_async())
            except Exception as e:
                logging.error(f"严重错误: {str(e)}")
                sys.exit(1)
        EOF

    - name: Release Repository Lock 🔓
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # 修复通知失败问题
    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            // 检查是否有有效的 issue number
            if (context.issue && context.issue.number) {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `🚨 Telegram APK同步失败！工作流运行详情: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            } else {
              // 没有关联的 issue，发送到仓库讨论
              const repo = context.repo;
              const discussionTitle = "工作流失败通知";
              
              // 检查是否已存在讨论
              const discussions = await github.rest.discussions.listForRepo({
                owner: repo.owner,
                repo: repo.repo,
                per_page: 1,
                direction: 'desc'
              });
              
              // 创建或更新讨论
              if (discussions.data.length > 0) {
                const discussion = discussions.data[0];
                await github.rest.discussions.updateComment({
                  owner: repo.owner,
                  repo: repo.repo,
                  discussion_number: discussion.number,
                  comment_number: discussion.comments[0]?.number || 0,
                  body: `### 🚨 工作流失败通知\n\n` +
                        `**工作流**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n` +
                        `**失败时间**: ${new Date().toISOString()}\n` +
                        `**原因**: APK同步失败\n\n` +
                        `请检查工作流日志以获取详细信息。`
                });
              } else {
                await github.rest.discussions.create({
                  owner: repo.owner,
                  repo: repo.repo,
                  title: discussionTitle,
                  body: `### 🚨 工作流失败通知\n\n` +
                        `**工作流**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n` +
                        `**失败时间**: ${new Date().toISOString()}\n` +
                        `**原因**: APK同步失败\n\n` +
                        `请检查工作流日志以获取详细信息。`,
                  category: "GENERAL"
                });
              }
            }
          } catch (error) {
            console.error('通知失败:', error);
            // 回退到基本日志输出
            core.warning('无法发送通知，请手动检查工作流失败情况');
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}