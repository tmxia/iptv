name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # 每3小时运行一次
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock 🔒
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "tvb_ys"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # 配置参数
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        WORK_DIR = "temp_apks"
        VERSION_FILE = "version.txt"
        
        # 设置日志
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        logger = logging.getLogger()
        
        def format_size(size):
            """将字节数转换为易读的格式"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def git_setup():
            """配置Git用户信息"""
            actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
            email = f"{actor}@users.noreply.github.com"
            
            subprocess.run(["git", "config", "user.name", actor], check=True)
            subprocess.run(["git", "config", "user.email", email], check=True)
            logger.info("Git配置完成")
            
            # 拉取最新更改
            logger.info("拉取远程最新更改...")
            subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
            return True
        
        def git_commit_push(message):
            """提交并推送更改"""
            try:
                # 只添加apk目录和版本文件
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], check=True)
                
                # 检查是否有更改
                status = subprocess.run(["git", "status", "--porcelain"], 
                                        capture_output=True, text=True)
                if not status.stdout.strip():
                    logger.info("没有更改需要提交")
                    return True
                
                # 提交更改
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                # 使用Token推送
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                logger.info("推送成功")
                return True
            except Exception as e:
                logger.error(f"Git操作失败: {str(e)}")
                return False
        
        def get_versions():
            """获取当前版本信息"""
            if not os.path.exists(VERSION_FILE):
                return {}
                
            try:
                with open(VERSION_FILE, "r") as f:
                    return json.load(f)
            except json.JSONDecodeError:
                logger.error("版本文件格式错误，重置为空白")
                return {}
        
        def update_versions(new_versions):
            """更新版本文件"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(VERSION_FILE, "w") as f:
                json.dump(versions, f, indent=2)
                logger.info("版本文件已更新")
                
                # 仅显示关心的键值版本信息
                for apk, ver in new_versions.items():
                    logger.info(f"版本更新: {apk} => {ver}")
        
        def extract_apk_version(apk_path):
            """使用aapt2从APK提取版本号"""
            try:
                aapt2 = os.path.join(
                    os.environ['ANDROID_HOME'],
                    "build-tools/34.0.0/aapt2"
                )
                
                result = subprocess.run(
                    [aapt2, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # 查找versionName
                match = re.search(r"versionName='([^']*)'", result.stdout)
                if match:
                    version = match.group(1)
                    return f"v{version}" if not version.startswith('v') else version
                return None
            except Exception as e:
                logger.error(f"提取版本号失败: {str(e)}")
                return None
        
        async def download_apk(client, message, filename):
            """下载APK文件并提取元数据"""
            download_path = os.path.join(WORK_DIR, filename)
            total_size = message.document.size
            logger.info(f"开始下载: {filename} ({format_size(total_size)})")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            logger.info(f"下载完成: 耗时{elapsed:.1f}秒")
            
            # 提取版本信息
            version = extract_apk_version(download_path)
            if not version:
                version = f"v{filename.split('.')[0]}-{message.date.strftime('%Y%m%d')}"
                logger.info(f"使用后备版本号: {version}")
            
            return {
                "path": download_path,
                "version": version,
                "date": message.date.strftime("%Y-%m-%d")
            }
        
        async def find_new_apks(client):
            """在Telegram频道中查找新APK"""
            logger.info("连接Telegram...")
            channel = os.environ.get('TELEGRAM_CHANNEL', 'tvb_ys')
            entity = await client.get_entity(channel)
            
            current_versions = get_versions()
            updates = {}
            
            async for msg in client.iter_messages(entity, limit=20):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                for attr in msg.media.document.attributes:
                    if isinstance(attr, DocumentAttributeFilename) and attr.file_name in APK_FILES:
                        filename = attr.file_name
                        
                        # 检查是否需要下载
                        current = current_versions.get(filename, "")
                        msg_date = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                        
                        if current and msg_date <= current.split(",")[-1]:
                            logger.info(f"跳过旧版本: {filename} ({msg_date})")
                            continue
                            
                        apk_data = await download_apk(client, msg, filename)
                        new_value = f"{apk_data['version']},{apk_data['date']}"
                        
                        if current != new_value:
                            updates[filename] = new_value
                            logger.info(f"发现新版本: {filename} ({current} → {new_value})")
                        break
            return updates
        
        async def main_async():
            """异步主函数"""
            logger.info("="*50 + "\nAPK 同步工具启动\n" + "="*50)
            
            # 验证环境变量
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                raise ValueError(f"缺少环境变量: {', '.join(missing)}")
            
            git_setup()
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            async with client:
                new_versions = await find_new_apks(client)
            
            if new_versions:
                # 复制APK文件到仓库
                for apk in new_versions.keys():
                    src = os.path.join(WORK_DIR, apk)
                    dst = os.path.join(APK_DIR, apk)
                    shutil.copy2(src, dst)
                    logger.info(f"已复制: {apk}")
                
                # 更新版本文件
                update_versions(new_versions)
                
                # 提交更改
                if git_commit_push(f"更新APK: {', '.join(new_versions.keys())}"):
                    logger.info("同步成功!")
                else:
                    raise RuntimeError("提交失败")
            else:
                logger.info("没有需要更新的APK文件")
            
            # 清理临时目录
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            logger.info("临时目录已清理")
            
            logger.info("="*50 + "\n同步任务完成\n" + "="*50)
            return 0
        
        if __name__ == "__main__":
            try:
                from asyncio import run
                run(main_async())
            except Exception as e:
                logging.error(f"严重错误: {str(e)}")
                sys.exit(1)
        EOF

    - name: Release Repository Lock 🔓
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `🚨 Telegram APK同步失败！工作流运行详情: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
          })

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}