name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock 🔒
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # 配置参数
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        WORK_DIR = "temp_apks"
        VERSION_FILE = "version.txt"
        
        # 硬编码的Telegram频道
        TELEGRAM_CHANNELS = ["tvboxjk"]
        
        # 设置日志
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        logger = logging.getLogger()
        
        def format_size(size):
            """将字节数转换为易读的格式"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def git_setup():
            """配置Git用户信息"""
            actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
            email = f"{actor}@users.noreply.github.com"
            
            subprocess.run(["git", "config", "user.name", actor], check=True)
            subprocess.run(["git", "config", "user.email", email], check=True)
            logger.info("Git配置完成")
            
            # 拉取最新更改
            logger.info("拉取远程最新更改...")
            subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
            return True
        
        def git_commit_push(message):
            """提交并推送更改"""
            try:
                # 关键修复：在提交前先拉取远程最新更改
                logger.info("提交前拉取远程最新更改...")
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
                
                # 只添加apk目录和版本文件
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], check=True)
                
                # 检查是否有更改（忽略未跟踪文件）
                status = subprocess.run(
                    ["git", "status", "--porcelain", "--untracked-files=no"],
                    capture_output=True, text=True, check=True
                )
                if not status.stdout.strip():
                    logger.info("没有更改需要提交")
                    return True
                
                # 提交更改
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                # 使用Token推送
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                logger.info("推送成功")
                return True
            except Exception as e:
                logger.error(f"Git操作失败: {str(e)}")
                return False
        
        def get_versions():
            """获取当前版本信息并验证键值结构"""
            if not os.path.exists(VERSION_FILE):
                return {}
            
            try:
                with open(VERSION_FILE, "r") as f:
                    versions = json.load(f)
                    # 验证是否为字典格式
                    if not isinstance(versions, dict):
                        logger.warning("版本文件格式无效，重置为空字典")
                        return {}
                    return versions
            except Exception as e:
                logger.error(f"版本文件读取失败: {str(e)}")
                return {}
        
        def update_versions(new_versions):
            """更新版本文件"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(VERSION_FILE, "w") as f:
                json.dump(versions, f, indent=2)
                logger.info("版本文件已更新")
                
                # 仅显示关心的键值版本信息
                for apk, ver in new_versions.items():
                    logger.info(f"版本更新: {apk} => {ver}")
        
        def extract_apk_version(apk_path):
            """使用aapt2从APK提取版本号"""
            try:
                aapt2 = os.path.join(
                    os.environ['ANDROID_HOME'],
                    "build-tools/34.0.0/aapt2"
                )
                
                result = subprocess.run(
                    [aapt2, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # 查找versionName
                match = re.search(r"versionName='([^']*)'", result.stdout)
                if match:
                    version = match.group(1)
                    return f"v{version}" if not version.startswith('v') else version
                return None
            except Exception as e:
                logger.error(f"提取版本号失败: {str(e)}")
                return None
        
        def extract_version_from_filename(filename):
            """从文件名中提取版本号"""
            # 简化版本号提取，匹配最后的版本号模式
            match = re.search(r'([\d.]+)\.apk$', filename)
            if match:
                version = match.group(1)
                if version and re.match(r'^\d+(\.\d+)*$', version):
                    return f"v{version}"
            return None
        
        def map_filename(original_name, channel_name):
            """简化的文件名映射函数"""
            # 首先排除模拟器版本
            if "模拟器" in original_name:
                return None
            
            # tvboxjk频道的简单匹配规则
            if channel_name == "tvboxjk":
                # 检查是否包含基本前缀
                if "OK影视Pro" not in original_name:
                    return None
                
                # 简单匹配手机版和电视版
                if "手机版" in original_name:
                    return "mobile-pro.apk"
                elif "电视版" in original_name:
                    return "leanback-pro.apk"
            
            return None
        
        async def download_apk(client, message, target_filename, original_filename, channel_name):
            """下载APK文件并提取元数据"""
            download_path = os.path.join(WORK_DIR, target_filename)
            total_size = message.document.size
            logger.info(f"开始下载: {original_filename} -> {target_filename} ({format_size(total_size)})")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            logger.info(f"下载完成: 耗时{elapsed:.1f}秒")
            
            # 验证文件是否成功下载
            if not os.path.exists(download_path):
                raise FileNotFoundError(f"文件下载失败: {download_path}")
            
            # 优先使用文件名中的版本号
            version = extract_version_from_filename(original_filename)
            if version:
                logger.info(f"使用文件名版本号: {version}")
            else:
                # 使用aapt2提取版本号
                version = extract_apk_version(download_path)
                if version:
                    logger.info(f"使用APK版本号: {version}")
                else:
                    version = f"v{target_filename.split('.')[0]}-{message.date.strftime('%Y%m%d')}"
                    logger.info(f"使用后备版本号: {version}")
            
            return {
                "path": download_path,
                "version": version,
                "date": message.date.strftime("%Y-%m-%d")
            }
        
        async def check_channel(client, channel_name, current_versions):
            """检查单个Telegram频道中的新APK"""
            logger.info(f"连接Telegram频道: {channel_name}")
            entity = await client.get_entity(channel_name)
            
            updates = {}
            processed_targets = set()
            
            # 扫描消息
            message_candidates = []
            
            async for msg in client.iter_messages(entity, limit=50):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                        
                    original_name = attr.file_name
                    target_name = map_filename(original_name, channel_name)
                    
                    if not target_name:
                        continue
                    
                    # 避免重复处理同一目标文件
                    if target_name in processed_targets:
                        continue
                    processed_targets.add(target_name)
                    
                    # 检查是否需要下载
                    current = current_versions.get(target_name, "")
                    msg_date = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                    
                    # 使用文件名中的版本号进行预检查
                    file_version = extract_version_from_filename(original_name)
                    if file_version and current:
                        try:
                            stored_version = current.split(',')[0].strip()
                            if stored_version == file_version:
                                continue  # 跳过下载
                        except Exception:
                            pass
                    
                    # 目标文件不存在时强制更新
                    target_path = os.path.join(APK_DIR, target_name)
                    if not os.path.exists(target_path):
                        message_candidates.append((msg, target_name, original_name))
                        continue
                    
                    # 常规版本对比逻辑
                    skip = False
                    if current:
                        try:
                            stored_version, stored_date = current.split(',')
                            stored_version = stored_version.strip()
                            stored_date = stored_date.strip()
                            
                            # 版本对比
                            if msg_date < stored_date:
                                skip = True
                        except (IndexError, ValueError):
                            pass
                    
                    if not skip:
                        message_candidates.append((msg, target_name, original_name))
            
            # 按时间倒序处理候选消息
            message_candidates.sort(key=lambda x: x[0].date, reverse=True)
            
            # 处理候选消息
            for msg, target_name, original_name in message_candidates:
                try:
                    apk_data = await download_apk(client, msg, target_name, original_name, channel_name)
                    new_value = f"{apk_data['version']},{apk_data['date']}"
                    
                    # 下载后再次验证版本
                    current_value = current_versions.get(target_name, "")
                    if current_value == new_value:
                        os.remove(apk_data['path'])  # 删除临时文件
                    else:
                        updates[target_name] = new_value
                        logger.info(f"发现新版本: {target_name} (当前: {current_value} → 新: {new_value})")
                        processed_targets.add(target_name)
                except Exception as e:
                    logger.error(f"下载失败: {original_name} -> {target_name}, 错误: {str(e)}")
            
            return updates
        
        async def main_async():
            """异步主函数"""
            logger.info("="*50 + "\nAPK 同步工具启动\n" + "="*50)
            
            # 验证环境变量
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                raise ValueError(f"缺少环境变量: {', '.join(missing)}")
            
            git_setup()
            # 确保清理临时目录
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            # 获取当前版本
            current_versions = get_versions()
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            all_updates = {}
            
            async with client:
                # 检查所有频道
                for channel in TELEGRAM_CHANNELS:
                    try:
                        logger.info(f"开始检查频道: {channel}")
                        updates = await check_channel(client, channel, current_versions)
                        all_updates.update(updates)
                        
                        # 更新当前版本信息用于后续频道检查
                        current_versions.update(updates)
                        logger.info(f"频道 {channel} 检查完成，更新: {len(updates)} 个APK")
                    except Exception as e:
                        logger.error(f"处理频道 {channel} 时出错: {str(e)}")
                        # 继续处理下一个频道
            
            if all_updates:
                logger.info(f"发现 {len(all_updates)} 个APK需要更新")
                
                # 复制APK文件到仓库
                for apk in all_updates.keys():
                    src = os.path.join(WORK_DIR, apk)
                    if not os.path.exists(src):
                        logger.error(f"源文件不存在: {src}")
                        raise FileNotFoundError(f"APK文件未成功下载: {apk}")
                    
                    dst = os.path.join(APK_DIR, apk)
                    shutil.copy2(src, dst)
                    logger.info(f"已复制: {apk} 到 {dst}")
                
                # 更新版本文件
                update_versions(all_updates)
                
                # 提交更改
                commit_msg = f"更新APK: {', '.join(all_updates.keys())}"
                if not git_commit_push(commit_msg):
                    raise RuntimeError("提交失败")
                else:
                    logger.info("所有更新已成功提交")
            else:
                logger.info("没有需要更新的APK文件")
            
            # 清理临时目录
            logger.info("清理临时目录...")
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            
            logger.info("="*50 + "\n同步任务完成\n" + "="*50)
            return 0
        
        if __name__ == "__main__":
            try:
                from asyncio import run
                run(main_async())
            except Exception as e:
                logging.error(f"严重错误: {str(e)}")
                sys.exit(1)
        EOF

    - name: Release Repository Lock 🔓
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            // 检查是否有有效的 issue number
            if (context.issue && context.issue.number) {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `🚨 Telegram APK同步失败！工作流运行详情: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            } else {
              // 没有关联的 issue，发送到仓库讨论
              const repo = context.repo;
              const discussionTitle = "工作流失败通知";
              
              // 检查是否已存在讨论
              const discussions = await github.rest.discussions.listForRepo({
                owner: repo.owner,
                repo: repo.repo,
                per_page: 1,
                direction: 'desc'
              });
              
              // 创建或更新讨论
              if (discussions.data.length > 0) {
                const discussion = discussions.data[0];
                await github.rest.discussions.updateComment({
                  owner: repo.owner,
                  repo: repo.repo,
                  discussion_number: discussion.number,
                  comment_number: discussion.comments[0]?.number || 0,
                  body: `### 🚨 工作流失败通知\n\n` +
                        `**工作流**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n` +
                        `**失败时间**: ${new Date().toISOString()}\n` +
                        `**原因**: APK同步失败\n\n` +
                        `请检查工作流日志以获取详细信息。`
                });
              } else {
                await github.rest.discussions.create({
                  owner: repo.owner,
                  repo: repo.repo,
                  title: discussionTitle,
                  body: `### 🚨 工作流失败通知\n\n` +
                        `**工作流**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n` +
                        `**失败时间**: ${new Date().toISOString()}\n` +
                        `**原因**: APK同步失败\n\n` +
                        `请检查工作流日志以获取详细信息。`,
                  category: "GENERAL"
                });
              }
            }
          } catch (error) {
            console.error('通知失败:', error);
            // 回退到基本日志输出
            core.warning('无法发送通知，请手动检查工作流失败情况');
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}