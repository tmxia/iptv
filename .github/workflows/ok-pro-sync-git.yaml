name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock 🔒
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Clean Telethon cache
      run: |
        find /home/runner -name "*.session" -delete 2>/dev/null || true
        find /home/runner -name "telethon_*" -type d -exec rm -rf {} + 2>/dev/null || true

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install --upgrade telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        import asyncio
        import socket
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # 配置参数
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        WORK_DIR = "temp_apks"
        VERSION_FILE = "version.txt"
        
        # 硬编码的Telegram频道
        TELEGRAM_CHANNELS = ["tvb_ys", "tvboxjk"]
        
        # 设置简化的日志
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%H:%M:%S'
        )
        logger = logging.getLogger()
        
        # DNS优化 - 优先使用IPv4
        original_getaddrinfo = socket.getaddrinfo
        def getaddrinfo_prefer_ipv4(host, port, family=0, type=0, proto=0, flags=0):
            try:
                return original_getaddrinfo(host, port, socket.AF_INET, type, proto, flags)
            except socket.gaierror:
                return original_getaddrinfo(host, port, family, type, proto, flags)
        socket.getaddrinfo = getaddrinfo_prefer_ipv4
        
        def format_size(size):
            """将字节数转换为易读的格式"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def git_setup():
            """配置Git用户信息"""
            actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
            email = f"{actor}@users.noreply.github.com"
            
            subprocess.run(["git", "config", "user.name", actor], check=True)
            subprocess.run(["git", "config", "user.email", email], check=True)
            
            # 拉取最新更改
            subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
            return True
        
        def git_commit_push(message):
            """提交并推送更改"""
            try:
                # 只添加apk目录和版本文件
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], check=True)
                
                # 检查是否有更改
                status = subprocess.run(
                    ["git", "status", "--porcelain", "--untracked-files=no"],
                    capture_output=True, text=True, check=True
                )
                if not status.stdout.strip():
                    logger.info("没有更改需要提交")
                    return True
                
                # 提交更改
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                # 使用Token推送
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                logger.info("推送成功")
                return True
            except Exception as e:
                logger.error(f"Git操作失败: {str(e)}")
                return False
        
        def get_versions():
            """获取当前版本信息"""
            if not os.path.exists(VERSION_FILE):
                return {}
            
            try:
                with open(VERSION_FILE, "r") as f:
                    versions = json.load(f)
                    if not isinstance(versions, dict):
                        logger.warning("版本文件格式无效，重置为空字典")
                        return {}
                    return versions
            except Exception as e:
                logger.error(f"版本文件读取失败: {str(e)}")
                return {}
        
        def update_versions(new_versions):
            """更新版本文件"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(VERSION_FILE, "w") as f:
                json.dump(versions, f, indent=2)
                
            for apk, ver in new_versions.items():
                logger.info(f"更新: {apk} => {ver}")
        
        def extract_apk_version(apk_path):
            """使用aapt2从APK提取版本号"""
            try:
                aapt2 = os.path.join(
                    os.environ['ANDROID_HOME'],
                    "build-tools/34.0.0/aapt2"
                )
                
                result = subprocess.run(
                    [aapt2, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # 查找versionName
                match = re.search(r"versionName='([^']*)'", result.stdout)
                if match:
                    version = match.group(1)
                    return f"v{version}" if not version.startswith('v') else version
                return None
            except Exception as e:
                logger.error(f"提取版本号失败: {str(e)}")
                return None
        
        async def download_with_retry(client, message, target_filename, original_filename, channel_name, max_retries=3):
            """带重试的下载函数"""
            for attempt in range(1, max_retries + 1):
                try:
                    return await download_apk(client, message, target_filename, original_filename, channel_name)
                except Exception as e:
                    logger.warning(f"下载尝试 {attempt}/{max_retries} 失败: {str(e)}")
                    if attempt == max_retries:
                        raise e
                    await asyncio.sleep(5 * attempt)
        
        async def download_apk(client, message, target_filename, original_filename, channel_name):
            """下载APK文件并提取元数据"""
            download_path = os.path.join(WORK_DIR, target_filename)
            total_size = message.document.size
            
            logger.info(f"下载: {original_filename} ({format_size(total_size)})")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            logger.info(f"下载完成: {elapsed:.1f}秒")
            
            # 验证文件是否成功下载
            if not os.path.exists(download_path):
                raise FileNotFoundError(f"文件下载失败: {download_path}")
            
            # 针对tvboxjk频道优先使用文件名中的版本号
            if channel_name == "tvboxjk":
                # 改进版本号提取，处理多种分隔符
                ver_match = re.search(r'[-﹣﹣—–\s]*([\d.]+)\.apk$', original_filename)
                if ver_match:
                    version = f"v{ver_match.group(1)}"
                    logger.info(f"从文件名提取版本: {version}")
                    return {
                        "path": download_path,
                        "version": version,
                        "date": message.date.strftime("%Y-%m-%d")
                    }
            
            # 其他情况使用aapt2提取版本号
            version = extract_apk_version(download_path)
            if not version:
                # 尝试从原始文件名提取版本号
                ver_match = re.search(r'[-﹣﹣—–\s]([\d.]+)\.apk$', original_filename)
                if ver_match:
                    version = f"v{ver_match.group(1)}"
                    logger.info(f"从文件名提取版本: {version}")
                else:
                    version = f"v{target_filename.split('.')[0]}-{message.date.strftime('%Y%m%d')}"
                    logger.info(f"使用后备版本: {version}")
            
            return {
                "path": download_path,
                "version": version,
                "date": message.date.strftime("%Y-%m-%d")
            }
        
        def map_filename(original_name, channel_name):
            """将原始文件名映射到标准文件名"""
            # 精确排除模拟器专版
            if "模拟器" in original_name or "模拟器专版" in original_name:
                return None
            
            # 第一个频道的直接匹配
            if channel_name == "tvb_ys" and original_name in APK_FILES:
                return original_name
            
            # 第二个频道的文件名映射规则 - 改进匹配逻辑
            if channel_name == "tvboxjk":
                # 放宽匹配条件，包含OK影视、OK、影视等关键词
                ok_keywords = ["ok影视", "ok", "影视"]
                if not any(keyword in original_name.lower() for keyword in ok_keywords):
                    return None
                
                # 调试日志
                logger.info(f"检查文件: {original_name}")
                
                # 改进电视版匹配
                tv_keywords = ["电视版", "tv版", "leanback", "电视", "大屏"]
                if any(keyword in original_name.lower() for keyword in tv_keywords):
                    logger.info(f"映射到电视版: {original_name} -> leanback-pro.apk")
                    return "leanback-pro.apk"
                
                # 改进手机版匹配  
                mobile_keywords = ["手机版", "mobile", "手机", "手持"]
                if any(keyword in original_name.lower() for keyword in mobile_keywords):
                    logger.info(f"映射到手机版: {original_name} -> mobile-pro.apk")
                    return "mobile-pro.apk"
                
                # 如果无法确定版本，根据文件名特征猜测
                if "pro" in original_name.lower():
                    if "tv" in original_name.lower() or "电视" in original_name:
                        logger.info(f"根据Pro+TV映射到电视版: {original_name}")
                        return "leanback-pro.apk"
                    else:
                        logger.info(f"根据Pro映射到手机版: {original_name}")
                        return "mobile-pro.apk"
            
            return None
        
        async def check_channel(client, channel_name, current_versions):
            """检查单个Telegram频道中的新APK"""
            logger.info(f"检查频道: {channel_name}")
            
            try:
                entity = await client.get_entity(channel_name)
            except Exception as e:
                logger.error(f"连接频道失败: {str(e)}")
                return {}
            
            updates = {}
            processed_targets = set()
            message_candidates = []
            
            # 增加消息获取数量以确保覆盖
            async for msg in client.iter_messages(entity, limit=30):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                        
                    original_name = attr.file_name
                    # 跳过非APK文件
                    if not original_name.lower().endswith('.apk'):
                        continue
                        
                    target_name = map_filename(original_name, channel_name)
                    
                    if not target_name:
                        continue
                        
                    if target_name in processed_targets:
                        continue
                    processed_targets.add(target_name)
                    
                    # 检查是否需要下载
                    current = current_versions.get(target_name, "")
                    msg_date = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                    
                    # 对于tvboxjk频道，优先使用文件名中的版本号进行预检查
                    if channel_name == "tvboxjk":
                        # 改进版本号提取，处理多种分隔符
                        ver_match = re.search(r'[-﹣﹣—–\s]*([\d.]+)\.apk$', original_name)
                        if ver_match:
                            file_version = f"v{ver_match.group(1)}"
                            if current:
                                try:
                                    stored_version = current.split(',')[0].strip()
                                    if stored_version == file_version:
                                        logger.info(f"跳过相同版本: {target_name} ({file_version})")
                                        continue
                                except Exception:
                                    pass
                    
                    # 目标文件不存在时强制更新
                    target_path = os.path.join(APK_DIR, target_name)
                    if not os.path.exists(target_path):
                        logger.info(f"目标文件不存在，强制更新: {target_name}")
                        message_candidates.append((msg, target_name, original_name))
                        continue
                    
                    # 常规版本对比逻辑
                    skip = False
                    if current:
                        try:
                            stored_version, stored_date = current.split(',')
                            stored_version = stored_version.strip()
                            stored_date = stored_date.strip()
                            
                            if msg_date < stored_date:
                                skip = True
                            elif msg_date == stored_date:
                                # 同一天可能有多个版本，继续处理
                                pass
                        except (IndexError, ValueError):
                            pass
                    
                    if not skip:
                        message_candidates.append((msg, target_name, original_name))
                        logger.info(f"添加候选: {target_name} (来源: {original_name})")
            
            # 按时间倒序处理候选消息
            message_candidates.sort(key=lambda x: x[0].date, reverse=True)
            logger.info(f"频道 {channel_name} 共有 {len(message_candidates)} 个候选APK")
            
            # 处理候选消息
            for msg, target_name, original_name in message_candidates:
                try:
                    apk_data = await download_with_retry(client, msg, target_name, original_name, channel_name)
                    new_value = f"{apk_data['version']},{apk_data['date']}"
                    
                    # 下载后再次验证版本
                    current_value = current_versions.get(target_name, "")
                    if current_value == new_value:
                        logger.info(f"跳过相同版本: {target_name}")
                        os.remove(apk_data['path'])
                    else:
                        updates[target_name] = new_value
                        logger.info(f"发现新版本: {target_name} ({new_value})")
                        processed_targets.add(target_name)
                except Exception as e:
                    logger.error(f"下载失败: {original_name}, 错误: {str(e)}")
            
            return updates
        
        async def main_async():
            """异步主函数"""
            logger.info("APK同步开始")
            
            # 验证环境变量
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                raise ValueError(f"缺少环境变量: {', '.join(missing)}")
            
            git_setup()
            # 清理临时目录
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            # 获取当前版本
            current_versions = get_versions()
            logger.info(f"当前版本: {current_versions}")
            
            # 创建Telegram客户端
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH'],
                connection_retries=5,
                retry_delay=3,
                auto_reconnect=True
            )
            
            all_updates = {}
            
            async with client:
                # 检查所有硬编码的频道
                for channel in TELEGRAM_CHANNELS:
                    try:
                        updates = await check_channel(client, channel, current_versions)
                        if updates:
                            all_updates.update(updates)
                            current_versions.update(updates)
                            logger.info(f"频道 {channel} 发现 {len(updates)} 个更新")
                        else:
                            logger.info(f"频道 {channel} 无更新")
                    except Exception as e:
                        logger.error(f"处理频道 {channel} 时出错: {str(e)}")
            
            if all_updates:
                logger.info(f"总共发现 {len(all_updates)} 个更新")
                
                # 复制APK文件到仓库
                for apk in all_updates.keys():
                    src = os.path.join(WORK_DIR, apk)
                    if not os.path.exists(src):
                        logger.error(f"源文件不存在: {src}")
                        raise FileNotFoundError(f"APK文件未成功下载: {apk}")
                    
                    dst = os.path.join(APK_DIR, apk)
                    shutil.copy2(src, dst)
                    logger.info(f"已复制: {apk}")
                
                # 更新版本文件
                update_versions(all_updates)
                
                # 提交更改
                commit_msg = f"更新APK: {', '.join(all_updates.keys())}"
                if not git_commit_push(commit_msg):
                    raise RuntimeError("提交失败")
                else:
                    logger.info("所有更新已成功提交")
            else:
                logger.info("没有需要更新的APK文件")
            
            # 清理临时目录
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            
            logger.info("同步任务完成")
            return 0
        
        if __name__ == "__main__":
            try:
                asyncio.run(main_async())
            except Exception as e:
                logging.error(f"严重错误: {str(e)}")
                sys.exit(1)
        EOF

    - name: Release Repository Lock 🔓
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `🚨 Telegram APK同步失败！工作流运行详情: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
          });

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}