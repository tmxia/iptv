name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "tvb_ys"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        WORK_DIR = "temp_apks"
        VERSION_FILE = "version.txt"
        
        # è®¾ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        logger = logging.getLogger()
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def git_setup():
            """é…ç½®Gitç”¨æˆ·ä¿¡æ¯"""
            actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
            email = f"{actor}@users.noreply.github.com"
            
            subprocess.run(["git", "config", "user.name", actor], check=True)
            subprocess.run(["git", "config", "user.email", email], check=True)
            logger.info("Gité…ç½®å®Œæˆ")
            
            # æ‹‰å–æœ€æ–°æ›´æ”¹
            logger.info("æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹...")
            subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
            return True
        
        def git_commit_push(message):
            """æäº¤å¹¶æ¨é€æ›´æ”¹"""
            try:
                # åªæ·»åŠ apkç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", APK_DIR, VERSION_FILE], check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], 
                                        capture_output=True, text=True)
                if not status.stdout.strip():
                    logger.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                # ä½¿ç”¨Tokenæ¨é€
                token = os.environ['GITHUB_TOKEN']
                repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                logger.info("æ¨é€æˆåŠŸ")
                return True
            except Exception as e:
                logger.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯å¹¶éªŒè¯é”®å€¼ç»“æ„"""
            if not os.path.exists(VERSION_FILE):
                return {}
            
            try:
                with open(VERSION_FILE, "r") as f:
                    versions = json.load(f)
                    # éªŒè¯æ˜¯å¦ä¸ºå­—å…¸æ ¼å¼
                    if not isinstance(versions, dict):
                        logger.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼æ— æ•ˆï¼Œé‡ç½®ä¸ºç©ºå­—å…¸")
                        return {}
                    return versions
            except Exception as e:
                logger.error(f"ç‰ˆæœ¬æ–‡ä»¶è¯»å–å¤±è´¥: {str(e)}")
                return {}
        
        def update_versions(new_versions):
            """æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(VERSION_FILE, "w") as f:
                json.dump(versions, f, indent=2)
                logger.info("ç‰ˆæœ¬æ–‡ä»¶å·²æ›´æ–°")
                
                # ä»…æ˜¾ç¤ºå…³å¿ƒçš„é”®å€¼ç‰ˆæœ¬ä¿¡æ¯
                for apk, ver in new_versions.items():
                    logger.info(f"ç‰ˆæœ¬æ›´æ–°: {apk} => {ver}")
        
        def extract_apk_version(apk_path):
            """ä½¿ç”¨aapt2ä»APKæå–ç‰ˆæœ¬å·"""
            try:
                aapt2 = os.path.join(
                    os.environ['ANDROID_HOME'],
                    "build-tools/34.0.0/aapt2"
                )
                
                result = subprocess.run(
                    [aapt2, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # æŸ¥æ‰¾versionName
                match = re.search(r"versionName='([^']*)'", result.stdout)
                if match:
                    version = match.group(1)
                    return f"v{version}" if not version.startswith('v') else version
                return None
            except Exception as e:
                logger.error(f"æå–ç‰ˆæœ¬å·å¤±è´¥: {str(e)}")
                return None
        
        async def download_apk(client, message, filename):
            """ä¸‹è½½APKæ–‡ä»¶å¹¶æå–å…ƒæ•°æ®"""
            download_path = os.path.join(WORK_DIR, filename)
            total_size = message.document.size
            logger.info(f"å¼€å§‹ä¸‹è½½: {filename} ({format_size(total_size)})")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            logger.info(f"ä¸‹è½½å®Œæˆ: è€—æ—¶{elapsed:.1f}ç§’")
            
            # éªŒè¯æ–‡ä»¶æ˜¯å¦æˆåŠŸä¸‹è½½
            if not os.path.exists(download_path):
                raise FileNotFoundError(f"æ–‡ä»¶ä¸‹è½½å¤±è´¥: {download_path}")
            
            # æå–ç‰ˆæœ¬ä¿¡æ¯
            version = extract_apk_version(download_path)
            if not version:
                version = f"v{filename.split('.')[0]}-{message.date.strftime('%Y%m%d')}"
                logger.info(f"ä½¿ç”¨åå¤‡ç‰ˆæœ¬å·: {version}")
            
            return {
                "path": download_path,
                "version": version,
                "date": message.date.strftime("%Y-%m-%d")
            }
        
        async def find_new_apks(client):
            """åœ¨Telegramé¢‘é“ä¸­æŸ¥æ‰¾æ–°APK"""
            logger.info("è¿æ¥Telegram...")
            channel = os.environ.get('TELEGRAM_CHANNEL', 'tvb_ys')
            entity = await client.get_entity(channel)
            
            current_versions = get_versions()
            updates = {}
            
            # å…³é”®ä¿®å¤ï¼šæ£€æŸ¥ç›®æ ‡æ–‡ä»¶å®é™…å­˜åœ¨æ€§
            missing_files = []
            for apk in APK_FILES:
                apk_path = os.path.join(APK_DIR, apk)
                if not os.path.exists(apk_path):
                    logger.warning(f"ç›®æ ‡æ–‡ä»¶ä¸å­˜åœ¨: {apk_path}")
                    missing_files.append(apk)
            
            async for msg in client.iter_messages(entity, limit=20):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                for attr in msg.media.document.attributes:
                    if isinstance(attr, DocumentAttributeFilename) and attr.file_name in APK_FILES:
                        filename = attr.file_name
                        
                        # å…³é”®ä¿®å¤ï¼šå¦‚æœæ–‡ä»¶å®é™…ä¸å­˜åœ¨ï¼Œå¼ºåˆ¶æ›´æ–°
                        if filename in missing_files:
                            logger.info(f"ç›®æ ‡æ–‡ä»¶ç¼ºå¤±ï¼Œå¼ºåˆ¶æ›´æ–°: {filename}")
                            apk_data = await download_apk(client, msg, filename)
                            new_value = f"{apk_data['version']},{apk_data['date']}"
                            updates[filename] = new_value
                            logger.info(f"æ–‡ä»¶ç¼ºå¤±è§¦å‘æ›´æ–°: {filename} => {new_value}")
                            break
                        
                        # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸‹è½½
                        current = current_versions.get(filename, "")
                        msg_date = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                        
                        # ç‰ˆæœ¬å¯¹æ¯”é€»è¾‘å¢å¼º
                        if current:
                            try:
                                # æå–å­˜å‚¨çš„æ—¥æœŸå¹¶éªŒè¯æ ¼å¼
                                stored_date = current.split(",")[-1]
                                datetime.strptime(stored_date, "%Y-%m-%d")
                                
                                # æ¯”è¾ƒæ—¥æœŸ
                                if msg_date <= stored_date:
                                    logger.info(f"è·³è¿‡æ—§ç‰ˆæœ¬: {filename} ({msg_date})")
                                    continue
                            except (IndexError, ValueError) as e:
                                logger.warning(f"ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯({current})ï¼Œå¼ºåˆ¶æ›´æ–°: {str(e)}")
                        
                        apk_data = await download_apk(client, msg, filename)
                        new_value = f"{apk_data['version']},{apk_data['date']}"
                        
                        if current != new_value:
                            updates[filename] = new_value
                            logger.info(f"å‘ç°æ–°ç‰ˆæœ¬: {filename} ({current} â†’ {new_value})")
                        break
            return updates
        
        async def main_async():
            """å¼‚æ­¥ä¸»å‡½æ•°"""
            logger.info("="*50 + "\nAPK åŒæ­¥å·¥å…·å¯åŠ¨\n" + "="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                raise ValueError(f"ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
            
            git_setup()
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            # å…³é”®ä¿®å¤ï¼šç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
            if not os.path.exists(APK_DIR):
                os.makedirs(APK_DIR)
                logger.info(f"åˆ›å»ºç›®æ ‡ç›®å½•: {APK_DIR}")
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            async with client:
                new_versions = await find_new_apks(client)
            
            if new_versions:
                # å¤åˆ¶APKæ–‡ä»¶åˆ°ä»“åº“ - å¢åŠ å­˜åœ¨æ€§æ£€æŸ¥
                for apk in new_versions.keys():
                    src = os.path.join(WORK_DIR, apk)
                    if not os.path.exists(src):
                        logger.error(f"ç›®æ ‡æ–‡ä»¶ä¸å­˜åœ¨: {src}")
                        raise FileNotFoundError(f"APKæ–‡ä»¶æœªæˆåŠŸä¸‹è½½: {apk}")
                    
                    dst = os.path.join(APK_DIR, apk)
                    shutil.copy2(src, dst)
                    logger.info(f"å·²å¤åˆ¶: {apk} åˆ° {dst}")
                    
                    # å…³é”®ä¿®å¤ï¼šéªŒè¯æ–‡ä»¶å·²æˆåŠŸå¤åˆ¶
                    if not os.path.exists(dst):
                        raise RuntimeError(f"æ–‡ä»¶å¤åˆ¶å¤±è´¥: {dst}")
                
                # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                update_versions(new_versions)
                
                # æäº¤æ›´æ”¹å¹¶éªŒè¯åŒæ­¥
                commit_msg = f"æ›´æ–°APK: {', '.join(new_versions.keys())}"
                if git_commit_push(commit_msg):
                    logger.info("æ¨é€æˆåŠŸï¼ŒéªŒè¯æ–‡ä»¶åŒæ­¥...")
                    # é—­ç¯éªŒè¯ï¼šæ£€æŸ¥æ–‡ä»¶æ˜¯å¦åŒæ­¥åˆ°ä»“åº“
                    for apk in new_versions.keys():
                        target_path = os.path.join(APK_DIR, apk)
                        if not os.path.exists(target_path):
                            raise RuntimeError(f"åŒæ­¥åæ–‡ä»¶ä¸å­˜åœ¨: {target_path}")
                    logger.info("æ‰€æœ‰æ–‡ä»¶å·²ç¡®è®¤åŒæ­¥è‡³ä»“åº“")
                else:
                    raise RuntimeError("æäº¤å¤±è´¥")
            else:
                logger.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
            
            # æ¸…ç†ä¸´æ—¶ç›®å½• - å¢åŠ æ¸…ç†éªŒè¯
            logger.info("æ¸…ç†ä¸´æ—¶ç›®å½•...")
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            
            # éªŒè¯ä¸´æ—¶ç›®å½•æ˜¯å¦æ¸…ç†æˆåŠŸ
            if os.path.exists(WORK_DIR):
                logger.error(f"ä¸´æ—¶ç›®å½•æ¸…ç†å¤±è´¥: {WORK_DIR}")
                raise RuntimeError("èµ„æºæ¸…ç†æœªå®Œæˆ")
            else:
                logger.info("ä¸´æ—¶ç›®å½•å·²ç¡®è®¤æ¸…ç†")
            
            logger.info("="*50 + "\nåŒæ­¥ä»»åŠ¡å®Œæˆ\n" + "="*50)
            return 0
        
        if __name__ == "__main__":
            try:
                from asyncio import run
                run(main_async())
            except Exception as e:
                logging.error(f"ä¸¥é‡é”™è¯¯: {str(e)}")
                sys.exit(1)
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `ğŸš¨ Telegram APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œè¯¦æƒ…: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
          })

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}