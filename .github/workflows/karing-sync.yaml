name: Karing Beta Sync from Source Repository

on:
  schedule:
    - cron: '0 */1 * * *'  # 每1小时运行一次
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout current repository
      uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl
        
    - name: Run sync script
      env:
        SOURCE_REPO: "KaringX/karing"
        TARGET_REPO: "${{ github.repository }}"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
        APK_PATTERN: "android_arm64-v8a.apk"
        WIN_PATTERN: "windows_x64.zip"
        ANDROID_TARGET_NAME: "karing.apk"
        WINDOWS_TARGET_NAME: "karing-win.zip"
      run: |
        # 目标文件路径
        ANDROID_TARGET_PATH="apk/$ANDROID_TARGET_NAME"
        WINDOWS_TARGET_PATH="apk/$WINDOWS_TARGET_NAME"
        
        # 创建临时工作目录
        WORK_DIR=$(mktemp -d)
        echo "创建临时目录: $WORK_DIR"
        trap 'rm -rf "$WORK_DIR"; echo "清理临时目录..."' EXIT

        # 验证令牌访问权限
        echo "验证GitHub令牌权限..."
        RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $TOKEN" \
                  "https://api.github.com/repos/$TARGET_REPO")
        if [ "$RESPONSE" != "200" ]; then
          echo "错误: 令牌无效 (HTTP $RESPONSE)"
          echo "请检查工作流权限设置"
          exit 1
        fi

        # 获取所有预发布版
        echo "获取预发布版本信息..."
        RELEASES_JSON=$(curl -sL "https://api.github.com/repos/$SOURCE_REPO/releases")
        if [ $? -ne 0 ]; then
          echo "错误: 无法获取发布信息"
          exit 1
        fi

        # 提取最新预发布版
        LATEST_PRE_RELEASE=$(echo "$RELEASES_JSON" | jq -r 'map(select(.prerelease == true)) | sort_by(.published_at) | reverse | .[0]')
        if [ -z "$LATEST_PRE_RELEASE" ] || [ "$LATEST_PRE_RELEASE" = "null" ]; then
          echo "错误: 未找到预发布版本"
          exit 1
        fi
        
        PRE_RELEASE_VERSION=$(echo "$LATEST_PRE_RELEASE" | jq -r '.tag_name')
        echo "源仓库最新预发布版: $PRE_RELEASE_VERSION"

        # 获取目标仓库当前版本
        echo "获取目标仓库当前版本文件..."
        TARGET_VERSION_JSON=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")

        # 初始化当前版本
        CURRENT_ANDROID_VERSION=""
        CURRENT_WINDOWS_VERSION=""
        
        if [ "$(echo "$TARGET_VERSION_JSON" | jq -r '.message')" != "Not Found" ]; then
          VERSION_CONTENT=$(echo "$TARGET_VERSION_JSON" | jq -r '.content' | base64 -d)
          
          # 解析版本文件
          if echo "$VERSION_CONTENT" | jq -e . >/dev/null 2>&1; then
            CURRENT_ANDROID_VERSION=$(echo "$VERSION_CONTENT" | jq -r ".android")
            CURRENT_WINDOWS_VERSION=$(echo "$VERSION_CONTENT" | jq -r ".windows")
          else
            echo "警告: 版本文件格式无效，将重置"
          fi
        fi
        
        echo "目标仓库当前Android版本: ${CURRENT_ANDROID_VERSION:-无}"
        echo "目标仓库当前Windows版本: ${CURRENT_WINDOWS_VERSION:-无}"

        # 检查是否需要更新
        need_update=false
        
        # 检查版本是否匹配
        if [ "$PRE_RELEASE_VERSION" != "$CURRENT_ANDROID_VERSION" ] || \
           [ "$PRE_RELEASE_VERSION" != "$CURRENT_WINDOWS_VERSION" ]; then
          echo "发现新版本: $PRE_RELEASE_VERSION (当前Android: $CURRENT_ANDROID_VERSION, Windows: $CURRENT_WINDOWS_VERSION)"
          need_update=true
        fi
        
        # 检查文件是否存在
        check_file_existence() {
          local file_path=$1
          local response=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: token $TOKEN" \
              "https://api.github.com/repos/$TARGET_REPO/contents/$file_path")
          [ "$response" -eq 200 ]
        }
        
        if ! check_file_existence "$ANDROID_TARGET_PATH"; then
          echo "目标仓库中不存在Android文件: $ANDROID_TARGET_PATH"
          need_update=true
        fi
        
        if ! check_file_existence "$WINDOWS_TARGET_PATH"; then
          echo "目标仓库中不存在Windows文件: $WINDOWS_TARGET_PATH"
          need_update=true
        fi
        
        if [ "$need_update" = false ]; then
          echo "版本相同且文件存在，无需更新"
          exit 0
        fi

        # 下载新版本文件
        echo "下载新版本文件..."
        
        # 查找Android APK文件
        apk_download_url=$(echo "$LATEST_PRE_RELEASE" | jq -r '.assets[] | select(.name | contains("'$APK_PATTERN'")) | .browser_download_url' | head -1)
        if [ -z "$apk_download_url" ]; then
          echo "错误: 未找到匹配的Android APK文件"
          exit 1
        fi
        
        # 查找Windows ZIP文件
        win_download_url=$(echo "$LATEST_PRE_RELEASE" | jq -r '.assets[] | select(.name | contains("'$WIN_PATTERN'")) | .browser_download_url' | head -1)
        if [ -z "$win_download_url" ]; then
          echo "错误: 未找到匹配的Windows ZIP文件"
          exit 1
        fi
        
        # 下载Android APK
        apk_source_name=$(basename "$apk_download_url")
        echo "下载Android APK: $apk_source_name"
        curl -sL "$apk_download_url" -o "$WORK_DIR/$apk_source_name"
        if [ ! -f "$WORK_DIR/$apk_source_name" ]; then
          echo "错误: Android APK下载失败"
          exit 1
        fi
        
        # 下载Windows ZIP
        win_source_name=$(basename "$win_download_url")
        echo "下载Windows ZIP: $win_source_name"
        curl -sL "$win_download_url" -o "$WORK_DIR/$win_source_name"
        if [ ! -f "$WORK_DIR/$win_source_name" ]; then
          echo "错误: Windows ZIP下载失败"
          exit 1
        fi
        
        # 重命名文件
        mv "$WORK_DIR/$apk_source_name" "$WORK_DIR/$ANDROID_TARGET_NAME"
        mv "$WORK_DIR/$win_source_name" "$WORK_DIR/$WINDOWS_TARGET_NAME"
        echo "文件已重命名: $ANDROID_TARGET_NAME, $WINDOWS_TARGET_NAME"

        # 上传文件函数
        upload_file() {
          local target_path=$1
          local source_file=$2
          local file_type=$3
          
          echo "上传$file_type文件: $target_path..."
          
          # 检查文件是否存在
          CONTENT_JSON=$(curl -s -H "Authorization: token $TOKEN" \
                          "https://api.github.com/repos/$TARGET_REPO/contents/$target_path")
          
          sha=""
          if [ "$(echo "$CONTENT_JSON" | jq -r '.message')" != "Not Found" ]; then
            sha=$(echo "$CONTENT_JSON" | jq -r '.sha')
          fi
          
          # 创建JSON请求
          json_file="$WORK_DIR/request_$file_type.json"
          {
            echo '{'
            echo "  \"message\": \"更新$file_type预发布版: $PRE_RELEASE_VERSION\","
            echo -n '  "content": "'
            base64 -w0 "$WORK_DIR/$source_file" | tr -d '\n'
            echo '",'
            echo "  \"sha\": \"$sha\""
            echo '}'
          } > "$json_file"
          
          # 上传文件
          RESPONSE_JSON=$(curl -s \
                -X PUT \
                -H "Authorization: token $TOKEN" \
                -H "Content-Type: application/json" \
                --data-binary "@$json_file" \
                "https://api.github.com/repos/$TARGET_REPO/contents/$target_path")
          
          # 检查错误
          error_message=$(echo "$RESPONSE_JSON" | jq -r '.message')
          if [ "$error_message" != "null" ] && [ ! -z "$error_message" ]; then
            echo "错误: $file_type文件上传失败 - $error_message"
            return 1
          else
            echo "上传成功: $target_path ($PRE_RELEASE_VERSION)"
            return 0
          fi
        }

        # 更新版本文件
        update_version() {
          echo "更新版本文件..."
          VERSION_JSON=$(curl -s -H "Authorization: token $TOKEN" \
                          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")

          # 创建新版本内容
          NEW_VERSION_DATA=$(jq -n \
            --arg android "$PRE_RELEASE_VERSION" \
            --arg windows "$PRE_RELEASE_VERSION" \
            '{android: $android, windows: $windows}')
          
          NEW_VERSION_CONTENT=$(echo "$NEW_VERSION_DATA" | jq .)

          # 检查文件是否存在
          SHA_VERSION=""
          if [ "$(echo "$VERSION_JSON" | jq -r '.message')" != "Not Found" ]; then
            SHA_VERSION=$(echo "$VERSION_JSON" | jq -r '.sha')
          fi

          # 创建JSON数据
          JSON_VERSION=$(jq -n \
              --arg msg "更新预发布版本: $PRE_RELEASE_VERSION" \
              --arg content "$(echo -n "$NEW_VERSION_CONTENT" | base64 -w0)" \
              --arg sha "$SHA_VERSION" \
              '{message: $msg, content: $content, sha: $sha}')

          # 上传版本文件
          VERSION_RESPONSE=$(curl -s \
                    -X PUT \
                    -H "Authorization: token $TOKEN" \
                    -H "Content-Type: application/json" \
                    -d "$JSON_VERSION" \
                    "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")

          # 检查错误
          ERROR_MESSAGE_VERSION=$(echo "$VERSION_RESPONSE" | jq -r '.message')
          if [ "$ERROR_MESSAGE_VERSION" != "null" ]; then
            echo "错误: 版本文件上传失败 - $ERROR_MESSAGE_VERSION"
            return 1
          fi
          return 0
        }

        # 上传文件
        upload_file "$ANDROID_TARGET_PATH" "$ANDROID_TARGET_NAME" "Android"
        if [ $? -ne 0 ]; then
          echo "错误: Android文件上传失败"
          exit 1
        fi
        
        upload_file "$WINDOWS_TARGET_PATH" "$WINDOWS_TARGET_NAME" "Windows"
        if [ $? -ne 0 ]; then
          echo "错误: Windows文件上传失败"
          exit 1
        fi
        
        # 更新版本文件
        update_version
        if [ $? -ne 0 ]; then
          echo "错误: 版本更新失败"
          exit 1
        fi

        echo "同步完成! 状态: 成功"
        echo "Android文件: $ANDROID_TARGET_PATH ($PRE_RELEASE_VERSION)"
        echo "Windows文件: $WINDOWS_TARGET_PATH ($PRE_RELEASE_VERSION)"
        exit 0

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Karing Beta Sync from Source Repository"
          repository: ${{ github.repository }}