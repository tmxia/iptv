name: OpenWrt Kernel Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # ÊØè3Â∞èÊó∂ËøêË°å‰∏ÄÊ¨°
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock üîí
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20ÂàÜÈíüË∂ÖÊó∂
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip zip
        pip install telethon requests pytz tqdm  # Ê∑ªÂä†tqdmÁî®‰∫éËøõÂ∫¶Êù°

    - name: Run Kernel Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "openwrt_flippy"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        import zipfile
        import asyncio
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename, Document
        import pytz
        from tqdm import tqdm
        
        # ÈÖçÁΩÆÂèÇÊï∞
        KERNEL_GROUPS = {
            "openwrt_flippy6.1": [
                "dtb-rockchip-.*\\.tar\\.gz",
                "dtb-amlogic-.*\\.tar\\.gz",
                "boot-.*\\.tar\\.gz",
                "modules-.*\\.tar\\.gz",
                "header-.*\\.tar\\.gz",
                "dtb-allwinner-.*\\.tar\\.gz"
            ],
            "openwrt_flippy6.12": [
                "dtb-amlogic-.*\\.tar\\.gz",
                "dtb-rockchip-.*\\.tar\\.gz",
                "boot-.*\\.tar\\.gz",
                "dtb-allwinner-.*\\.tar\\.gz",
                "header-.*\\.tar\\.gz",
                "modules-.*\\.tar\\.gz"
            ]
        }
        KERNEL_DIR = "kernels"
        
        # ÁéØÂ¢ÉÂèòÈáè
        WORK_DIR = os.path.join(os.getcwd(), "temp_kernels")
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # ÈÖçÁΩÆÊó•Âøó
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def format_size(size):
            """Â∞ÜÂ≠óËäÇÊï∞ËΩ¨Êç¢‰∏∫ÊòìËØªÁöÑÊ†ºÂºè"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # ÊãâÂèñÊúÄÊñ∞Êõ¥Êîπ
                log.info("ÊãâÂèñËøúÁ®ãÊúÄÊñ∞Êõ¥Êîπ...")
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                
                log.info("GitÈÖçÁΩÆÂÆåÊàê")
                return True
            except Exception as e:
                log.error(f"GitËÆæÁΩÆÂ§±Ë¥•: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # Ê∑ªÂä†ÂÜÖÊ†∏ÁõÆÂΩïÂíåÁâàÊú¨Êñá‰ª∂
                subprocess.run(["git", "add", KERNEL_DIR, "version.txt"], cwd=GIT_DIR, check=True)
                
                # Ê£ÄÊü•ÊòØÂê¶ÊúâÊõ¥Êîπ
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("Ê≤°ÊúâÊõ¥ÊîπÈúÄË¶ÅÊèê‰∫§")
                    return True
                
                # Êèê‰∫§Êõ¥Êîπ
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # ÈáçËØïÊú∫Âà∂
                max_attempts = 3
                for attempt in range(1, max_attempts + 1):
                    try:
                        log.info(f"Â∞ùËØï {attempt}/{max_attempts}: ÊãâÂèñËøúÁ®ãÊúÄÊñ∞Êõ¥ÊîπÂπ∂ÂèòÂü∫...")
                        subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                        
                        log.info(f"Â∞ùËØï {attempt}/{max_attempts}: Êé®ÈÄÅÊõ¥Êîπ...")
                        subprocess.run(
                            ["git", "push", repo_url, "HEAD:main"],
                            cwd=GIT_DIR,
                            check=True
                        )
                        log.info("Êé®ÈÄÅÊàêÂäü")
                        return True
                    except subprocess.CalledProcessError as e:
                        log.warning(f"Â∞ùËØï {attempt} Â§±Ë¥•: {str(e)}")
                        if attempt < max_attempts:
                            log.info("Á≠âÂæÖ10ÁßíÂêéÈáçËØï...")
                            time.sleep(10)
                        else:
                            log.error(f"ÁªèËøá{max_attempts}Ê¨°Â∞ùËØïÂêé‰ªçÊó†Ê≥ïÊé®ÈÄÅÊõ¥Êîπ")
                            return False
            except Exception as e:
                log.error(f"GitÊìç‰ΩúÂ§±Ë¥•: {str(e)}")
                return False
        
        def get_current_versions():
            """Ëé∑ÂèñÂΩìÂâçÁâàÊú¨‰ø°ÊÅØ"""
            version_path = os.path.join(GIT_DIR, "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f), True
                except json.JSONDecodeError:
                    log.warning("ÁâàÊú¨Êñá‰ª∂Ê†ºÂºèÈîôËØØÔºåÈáçÊñ∞ÂàùÂßãÂåñ")
                    return {}, True
                except Exception as e:
                    log.warning(f"ËØªÂèñÁâàÊú¨Êñá‰ª∂Â§±Ë¥•: {str(e)}ÔºåÈáçÊñ∞ÂàùÂßãÂåñ")
                    return {}, True
            return {}, False
        
        def update_versions(versions):
            version_path = os.path.join(GIT_DIR, "version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def pattern_match(filename, pattern):
            """‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÊ£ÄÊü•Êñá‰ª∂ÂêçÊòØÂê¶ÂåπÈÖçÊ®°Âºè"""
            pattern_regex = pattern.replace('.', r'\.').replace('*', r'.*')
            return re.fullmatch(pattern_regex, filename) is not None
        
        def find_matching_group(filename):
            """Êü•ÊâæÊñá‰ª∂ÂêçÂåπÈÖçÁöÑÂÜÖÊ†∏ÁªÑ"""
            for group, patterns in KERNEL_GROUPS.items():
                for pattern in patterns:
                    if pattern_match(filename, pattern):
                        return group
            return None
        
        def extract_kernel_info(filename):
            """‰ªéÊñá‰ª∂Âêç‰∏≠ÊèêÂèñÂÜÖÊ†∏ÁâàÊú¨ÂíåÊûÑÂª∫‰ø°ÊÅØ"""
            pattern = r'^(.*?)-(\d+\.\d+\.\d+)-flippy-(\d+\+[a-z]?)\.tar\.gz$'
            match = re.match(pattern, filename)
            if match:
                prefix = match.group(1)
                version = match.group(2)
                build = match.group(3)
                return {
                    "prefix": prefix,
                    "version": version,
                    "build": build,
                    "full_version": f"{version}-flippy-{build}"
                }
            return None
        
        async def download_file(client, document, download_path):
            """‰∏ãËΩΩÊñá‰ª∂Âπ∂ÊòæÁ§∫ËøõÂ∫¶Êù°"""
            filename = None
            for attr in document.attributes:
                if isinstance(attr, DocumentAttributeFilename):
                    filename = attr.file_name
                    break
            if not filename:
                return False
            
            total_size = document.size
            log.info(f"ÂºÄÂßã‰∏ãËΩΩ: {filename} ({format_size(total_size)})")
            
            # ÂàõÂª∫ËøõÂ∫¶Êù°
            progress_bar = tqdm(
                total=total_size,
                unit='B',
                unit_scale=True,
                desc=f"‰∏ãËΩΩ {filename}",
                bar_format='{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]'
            )
            
            last_downloaded = 0
            
            def progress_callback(current, total):
                nonlocal last_downloaded
                increment = current - last_downloaded
                if increment > 0:
                    progress_bar.update(increment)
                    last_downloaded = current
            
            try:
                await client.download_media(
                    document,
                    file=download_path,
                    progress_callback=progress_callback
                )
                progress_bar.close()
                log.info(f"‰∏ãËΩΩÂÆåÊàê: {filename}")
                return True
            except Exception as e:
                progress_bar.close()
                log.error(f"‰∏ãËΩΩÂ§±Ë¥•: {filename} - {str(e)}")
                return False
        
        async def process_group(client, group_name, files_to_download, group_dir):
            """Â§ÑÁêÜÂÆåÊï¥ÁöÑÂÜÖÊ†∏ÁªÑ"""
            os.makedirs(group_dir, exist_ok=True)
            download_results = {}
            file_info = {}
            
            # ‰∏ãËΩΩÁªÑÂÜÖÊâÄÊúâÊñá‰ª∂
            for filename, msg in files_to_download:
                download_path = os.path.join(group_dir, filename)
                success = await download_file(client, msg.media.document, download_path)
                download_results[filename] = success
                
                # ÊèêÂèñÊñá‰ª∂‰ø°ÊÅØ
                info = extract_kernel_info(filename)
                if info:
                    file_info = info
            
            # Ê£ÄÊü•‰∏ãËΩΩÁªìÊûú
            if not all(download_results.values()):
                log.error(f"ÁªÑ {group_name} ‰∏ãËΩΩÂ§±Ë¥•")
                return None
            
            # ÂàõÂª∫ZIPÊñá‰ª∂
            zip_filename = f"{group_name}_{file_info['full_version']}.zip"
            zip_path = os.path.join(WORK_DIR, zip_filename)
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                for root, _, files in os.walk(group_dir):
                    for file in files:
                        file_path = os.path.join(root, file)
                        zipf.write(file_path, os.path.basename(file_path))
            
            log.info(f"ÂàõÂª∫ZIPÊñá‰ª∂: {zip_filename}")
            
            # Ëé∑ÂèñÊúÄÊñ∞Êó•Êúü
            dates = [msg.date for _, msg in files_to_download]
            latest_date = max(dates)
            utc8 = pytz.timezone('Asia/Shanghai')
            date_utc8 = latest_date.astimezone(utc8).strftime("%Y-%m-%d")
            
            return {
                "zip_path": zip_path,
                "version": file_info['full_version'],
                "date_iso": date_utc8
            }
        
        def parse_version(version_str):
            """Â∞ÜÁâàÊú¨Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ÂèØÊØîËæÉÁöÑÂÖÉÁªÑ"""
            if not version_str:
                return (0, 0, 0)
            
            parts = version_str.split('.')
            if len(parts) != 3:
                return (0, 0, 0)
            
            try:
                return tuple(map(int, parts))
            except ValueError:
                return (0, 0, 0)
        
        async def find_new_kernels(client):
            log.info("ËøûÊé•Telegram...")
            await client.connect()
            if not await client.is_user_authorized():
                log.error("ÈîôËØØ: Telegram‰ºöËØùÊó†Êïà")
                return None
            
            channel = os.environ.get('TELEGRAM_CHANNEL', 'openwrt_flippy')
            log.info(f"Êâ´ÊèèÈ¢ëÈÅì: {channel}")
            entity = await client.get_entity(channel)
            
            # Ëé∑ÂèñÂΩìÂâçÁâàÊú¨‰ø°ÊÅØ
            current_versions, version_file_exists = get_current_versions()
            updates = {}
            
            # Â≠òÂÇ®ÊâæÂà∞ÁöÑÊñá‰ª∂ {group: {full_version: {filename: message}}}
            found_groups = {group: {} for group in KERNEL_GROUPS.keys()}
            
            # Ëé∑ÂèñÈ¢ëÈÅì‰∏≠ÊúÄÊñ∞ÁöÑ100Êù°Ê∂àÊÅØ
            async for msg in client.iter_messages(entity, limit=100):
                if msg.media and hasattr(msg.media, "document") and isinstance(msg.media.document, Document):
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            group = find_matching_group(filename)
                            if not group:
                                continue
                            
                            # ÊèêÂèñÂÜÖÊ†∏‰ø°ÊÅØ
                            kernel_info = extract_kernel_info(filename)
                            if not kernel_info:
                                continue
                            
                            full_version = kernel_info['full_version']
                            
                            # Âè™Â§ÑÁêÜÊØîÂΩìÂâçÁâàÊú¨È´òÁöÑÂÜÖÊ†∏
                            current_version_str = current_versions.get(group, "").split(",")[0] if group in current_versions else ""
                            current_version_tuple = parse_version(current_version_str.split('-')[0] if current_version_str else "")
                            new_version_tuple = parse_version(kernel_info['version'])
                            
                            if current_version_tuple and new_version_tuple <= current_version_tuple:
                                log.info(f"Ë∑≥ËøáÊóßÁâàÊú¨: {filename} (ÂΩìÂâç: {current_version_str}, Êñ∞: {full_version})")
                                continue
                            
                            if full_version not in found_groups[group]:
                                found_groups[group][full_version] = {}
                            
                            found_groups[group][full_version][filename] = msg
            
            # Ê£ÄÊü•ÊØè‰∏™ÁªÑÁöÑÂÆåÊï¥ÊÄß
            for group, versions in found_groups.items():
                for full_version, files in versions.items():
                    # Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÊâÄÊúâÂøÖÈúÄÁöÑÊñá‰ª∂
                    required_patterns = set(KERNEL_GROUPS[group])
                    existing_files = set(files.keys())
                    
                    # Ê£ÄÊü•ÊØè‰∏™ÂøÖÈúÄÊñá‰ª∂Ê®°ÂºèÊòØÂê¶Ëá≥Â∞ëÊúâ‰∏Ä‰∏™ÂåπÈÖçÁöÑÊñá‰ª∂
                    group_complete = True
                    for pattern in required_patterns:
                        if not any(pattern_match(f, pattern) for f in existing_files):
                            group_complete = False
                            log.info(f"ÁªÑ {group} ÁâàÊú¨ {full_version} Áº∫Â∞ëÂåπÈÖçÊ®°Âºè {pattern} ÁöÑÊñá‰ª∂")
                            break
                    
                    if group_complete:
                        log.info(f"ÁªÑ {group} ÁâàÊú¨ {full_version} ÂÆåÊï¥")
                        
                        # ÂáÜÂ§á‰∏ãËΩΩÊñá‰ª∂
                        files_to_download = [(f, msg) for f, msg in files.items()]
                        group_dir = os.path.join(WORK_DIR, f"group_{group}_{full_version.replace('.', '_').replace('+', '_')}")
                        
                        # Â§ÑÁêÜÁªÑ
                        result = await process_group(client, group, files_to_download, group_dir)
                        if result:
                            updates[group] = result
                        else:
                            log.error(f"Â§ÑÁêÜÁªÑ {group} Â§±Ë¥•")
            
            return updates if updates else None
        
        def main():
            log.info("="*50)
            log.info("OpenWrt ÂÜÖÊ†∏ÂêåÊ≠•Â∑•ÂÖ∑ÂêØÂä® (Â¢ûÂº∫Áâà)")
            log.info("="*50)
            
            # È™åËØÅÁéØÂ¢ÉÂèòÈáè
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log.error(f"ÈîôËØØ: Áº∫Â∞ëÁéØÂ¢ÉÂèòÈáè: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                with client:
                    new_kernels = client.loop.run_until_complete(find_new_kernels(client))
            except Exception as e:
                log.error(f"TelegramÈîôËØØ: {str(e)}")
                return 3
            
            # Ëé∑ÂèñÂΩìÂâçÁâàÊú¨‰ø°ÊÅØ
            current_versions, _ = get_current_versions()
            updated = False
            
            if new_kernels:
                # Â§ÑÁêÜÊñ∞ÂÜÖÊ†∏
                target_dir = os.path.join(GIT_DIR, KERNEL_DIR)
                os.makedirs(target_dir, exist_ok=True)
                
                for group, data in new_kernels.items():
                    # Â§çÂà∂ZIPÊñá‰ª∂Âà∞‰ªìÂ∫ì
                    target_path = os.path.join(target_dir, os.path.basename(data["zip_path"]))
                    shutil.copy2(data["zip_path"], target_path)
                    
                    # Êõ¥Êñ∞ÁâàÊú¨‰ø°ÊÅØ
                    current_versions[group] = f"{data['version']},{data['date_iso']}"
                    log.info(f"Â∑≤Êõ¥Êñ∞: {group} (ÁâàÊú¨: {data['version']}, Êó•Êúü: {data['date_iso']})")
                    updated = True
                
                # Êõ¥Êñ∞ÁâàÊú¨Êñá‰ª∂
                update_versions(current_versions)
                
                # Êèê‰∫§Êõ¥Êîπ
                group_versions = []
                for group, data in new_kernels.items():
                    group_versions.append(f"{group}@{data['version']}")
                
                commit_msg = f"Êõ¥Êñ∞OpenWrtÂÜÖÊ†∏: {', '.join(group_versions)}"
                if commit_and_push(commit_msg):
                    log.info(f"ÂêåÊ≠•ÊàêÂäü! Êõ¥Êñ∞‰∫Ü {len(new_kernels)} ‰∏™ÂÜÖÊ†∏ÁªÑ")
                else:
                    log.error("Êèê‰∫§Â§±Ë¥•")
                    return 4
            else:
                log.info("Ê≤°ÊúâÈúÄË¶ÅÊõ¥Êñ∞ÁöÑÂÜÖÊ†∏Êñá‰ª∂")
            
            # Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log.info("‰∏¥Êó∂ÁõÆÂΩïÂ∑≤Ê∏ÖÁêÜ")
            
            log.info("="*50)
            log.info("ÂêåÊ≠•‰ªªÂä°ÂÆåÊàê")
            log.info("="*50)
            return 0
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Release Repository Lock üîì
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            // Â∞ùËØïËé∑Âèñ‰ªìÂ∫ìÁöÑ open issues
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            
            // Êü•ÊâæÊ†áÈ¢ò‰∏∫"Â∑•‰ΩúÊµÅÈÄöÁü•"ÁöÑ issue
            const notificationIssue = issues.data.find(issue => 
              issue.title.includes('Â∑•‰ΩúÊµÅÈÄöÁü•')
            );
            
            let issueNumber;
            if (notificationIssue) {
              issueNumber = notificationIssue.number;
            } else {
              // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÔºåÂàõÂª∫Êñ∞ÁöÑ issue
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'Â∑•‰ΩúÊµÅÈÄöÁü•',
                body: 'Ê≠§ issue Áî®‰∫éÊé•Êî∂Â∑•‰ΩúÊµÅÂ§±Ë¥•ÈÄöÁü•'
              });
              issueNumber = newIssue.data.number;
            }
            
            const message = `üö® OpenWrtÂÜÖÊ†∏ÂêåÊ≠•Â§±Ë¥•ÔºÅÂ∑•‰ΩúÊµÅËøêË°å: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
            await github.rest.issues.createComment({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });
          } catch (error) {
            console.error('ÈÄöÁü•Â§±Ë¥•:', error);
            // ÂõûÈÄÄÂà∞ÁÆÄÂçïÁöÑÊó•ÂøóËæìÂá∫
            core.error(`üö® OpenWrtÂÜÖÊ†∏ÂêåÊ≠•Â§±Ë¥•ÔºÅËØ¶ÊÉÖËØ∑Êü•ÁúãËøêË°å: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`);
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OpenWrt Kernel Sync from TELEGRAM"
          repository: ${{ github.repository }}