name: OpenWrt Kernel Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20åˆ†é’Ÿè¶…æ—¶
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip zip
        pip install telethon requests pytz tqdm  # æ·»åŠ tqdmç”¨äºè¿›åº¦æ¡

    - name: Run Kernel Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "openwrt_flippy"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        import zipfile
        import asyncio
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename, Document
        import pytz
        from tqdm import tqdm
        
        # é…ç½®å‚æ•°
        KERNEL_GROUPS = {
            "openwrt_flippy6.1": [
                "dtb-rockchip-.*\\.tar\\.gz",
                "dtb-amlogic-.*\\.tar\\.gz",
                "boot-.*\\.tar\\.gz",
                "modules-.*\\.tar\\.gz",
                "header-.*\\.tar\\.gz",
                "dtb-allwinner-.*\\.tar\\.gz"
            ],
            "openwrt_flippy6.12": [
                "dtb-amlogic-.*\\.tar\\.gz",
                "dtb-rockchip-.*\\.tar\\.gz",
                "boot-.*\\.tar\\.gz",
                "dtb-allwinner-.*\\.tar\\.gz",
                "header-.*\\.tar\\.gz",
                "modules-.*\\.tar\\.gz"
            ]
        }
        KERNEL_DIR = "kernels"
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = os.path.join(os.getcwd(), "temp_kernels")
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹
                log.info("æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹...")
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                
                log.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # æ·»åŠ å†…æ ¸ç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", KERNEL_DIR, "version.txt"], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # é‡è¯•æœºåˆ¶
                max_attempts = 3
                for attempt in range(1, max_attempts + 1):
                    try:
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹å¹¶å˜åŸº...")
                        subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                        
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ¨é€æ›´æ”¹...")
                        subprocess.run(
                            ["git", "push", repo_url, "HEAD:main"],
                            cwd=GIT_DIR,
                            check=True
                        )
                        log.info("æ¨é€æˆåŠŸ")
                        return True
                    except subprocess.CalledProcessError as e:
                        log.warning(f"å°è¯• {attempt} å¤±è´¥: {str(e)}")
                        if attempt < max_attempts:
                            log.info("ç­‰å¾…10ç§’åé‡è¯•...")
                            time.sleep(10)
                        else:
                            log.error(f"ç»è¿‡{max_attempts}æ¬¡å°è¯•åä»æ— æ³•æ¨é€æ›´æ”¹")
                            return False
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_current_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯"""
            version_path = os.path.join(GIT_DIR, "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f), True
                except json.JSONDecodeError:
                    log.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œé‡æ–°åˆå§‹åŒ–")
                    return {}, True
                except Exception as e:
                    log.warning(f"è¯»å–ç‰ˆæœ¬æ–‡ä»¶å¤±è´¥: {str(e)}ï¼Œé‡æ–°åˆå§‹åŒ–")
                    return {}, True
            return {}, False
        
        def update_versions(versions):
            version_path = os.path.join(GIT_DIR, "version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def pattern_match(filename, pattern):
            """ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ¹é…æ¨¡å¼"""
            pattern_regex = pattern.replace('.', r'\.').replace('*', r'.*')
            return re.fullmatch(pattern_regex, filename) is not None
        
        def find_matching_group(filename):
            """æŸ¥æ‰¾æ–‡ä»¶ååŒ¹é…çš„å†…æ ¸ç»„"""
            for group, patterns in KERNEL_GROUPS.items():
                for pattern in patterns:
                    if pattern_match(filename, pattern):
                        return group
            return None
        
        def extract_kernel_info(filename):
            """ä»æ–‡ä»¶åä¸­æå–å†…æ ¸ç‰ˆæœ¬å’Œæ„å»ºä¿¡æ¯"""
            pattern = r'^(.*?)-(\d+\.\d+\.\d+)-flippy-(\d+\+[a-z]?)\.tar\.gz$'
            match = re.match(pattern, filename)
            if match:
                prefix = match.group(1)
                version = match.group(2)
                build = match.group(3)
                return {
                    "prefix": prefix,
                    "version": version,
                    "build": build,
                    "full_version": f"{version}-flippy-{build}"
                }
            return None
        
        async def download_file(client, document, download_path):
            """ä¸‹è½½æ–‡ä»¶å¹¶æ˜¾ç¤ºè¿›åº¦æ¡"""
            filename = None
            for attr in document.attributes:
                if isinstance(attr, DocumentAttributeFilename):
                    filename = attr.file_name
                    break
            if not filename:
                return False
            
            total_size = document.size
            log.info(f"å¼€å§‹ä¸‹è½½: {filename} ({format_size(total_size)})")
            
            # åˆ›å»ºè¿›åº¦æ¡
            progress_bar = tqdm(
                total=total_size,
                unit='B',
                unit_scale=True,
                desc=f"ä¸‹è½½ {filename}",
                bar_format='{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]'
            )
            
            last_downloaded = 0
            
            def progress_callback(current, total):
                nonlocal last_downloaded
                increment = current - last_downloaded
                if increment > 0:
                    progress_bar.update(increment)
                    last_downloaded = current
            
            try:
                await client.download_media(
                    document,
                    file=download_path,
                    progress_callback=progress_callback
                )
                progress_bar.close()
                log.info(f"ä¸‹è½½å®Œæˆ: {filename}")
                return True
            except Exception as e:
                progress_bar.close()
                log.error(f"ä¸‹è½½å¤±è´¥: {filename} - {str(e)}")
                return False
        
        async def process_group(client, group_name, files_to_download, group_dir):
            """å¤„ç†å®Œæ•´çš„å†…æ ¸ç»„"""
            os.makedirs(group_dir, exist_ok=True)
            download_results = {}
            file_info = {}
            
            # ä¸‹è½½ç»„å†…æ‰€æœ‰æ–‡ä»¶
            for filename, msg in files_to_download:
                download_path = os.path.join(group_dir, filename)
                success = await download_file(client, msg.media.document, download_path)
                download_results[filename] = success
                
                # æå–æ–‡ä»¶ä¿¡æ¯
                info = extract_kernel_info(filename)
                if info:
                    file_info = info
            
            # æ£€æŸ¥ä¸‹è½½ç»“æœ
            if not all(download_results.values()):
                log.error(f"ç»„ {group_name} ä¸‹è½½å¤±è´¥")
                return None
            
            # åˆ›å»ºZIPæ–‡ä»¶
            zip_filename = f"{group_name}_{file_info['full_version']}.zip"
            zip_path = os.path.join(WORK_DIR, zip_filename)
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                for root, _, files in os.walk(group_dir):
                    for file in files:
                        file_path = os.path.join(root, file)
                        zipf.write(file_path, os.path.basename(file_path))
            
            log.info(f"åˆ›å»ºZIPæ–‡ä»¶: {zip_filename}")
            
            # è·å–æœ€æ–°æ—¥æœŸ
            dates = [msg.date for _, msg in files_to_download]
            latest_date = max(dates)
            utc8 = pytz.timezone('Asia/Shanghai')
            date_utc8 = latest_date.astimezone(utc8).strftime("%Y-%m-%d")
            
            return {
                "zip_path": zip_path,
                "version": file_info['full_version'],
                "date_iso": date_utc8
            }
        
        def parse_version(version_str):
            """å°†ç‰ˆæœ¬å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¯æ¯”è¾ƒçš„å…ƒç»„"""
            if not version_str:
                return (0, 0, 0)
            
            parts = version_str.split('.')
            if len(parts) != 3:
                return (0, 0, 0)
            
            try:
                return tuple(map(int, parts))
            except ValueError:
                return (0, 0, 0)
        
        async def find_new_kernels(client):
            log.info("è¿æ¥Telegram...")
            await client.connect()
            if not await client.is_user_authorized():
                log.error("é”™è¯¯: Telegramä¼šè¯æ— æ•ˆ")
                return None
            
            channel = os.environ.get('TELEGRAM_CHANNEL', 'openwrt_flippy')
            log.info(f"æ‰«æé¢‘é“: {channel}")
            entity = await client.get_entity(channel)
            
            # è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
            current_versions, version_file_exists = get_current_versions()
            updates = {}
            
            # å­˜å‚¨æ‰¾åˆ°çš„æ–‡ä»¶ {group: {full_version: {filename: message}}}
            found_groups = {group: {} for group in KERNEL_GROUPS.keys()}
            
            # è·å–é¢‘é“ä¸­æœ€æ–°çš„100æ¡æ¶ˆæ¯
            async for msg in client.iter_messages(entity, limit=100):
                if msg.media and hasattr(msg.media, "document") and isinstance(msg.media.document, Document):
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            group = find_matching_group(filename)
                            if not group:
                                continue
                            
                            # æå–å†…æ ¸ä¿¡æ¯
                            kernel_info = extract_kernel_info(filename)
                            if not kernel_info:
                                continue
                            
                            full_version = kernel_info['full_version']
                            
                            # åªå¤„ç†æ¯”å½“å‰ç‰ˆæœ¬é«˜çš„å†…æ ¸
                            current_version_str = current_versions.get(group, "").split(",")[0] if group in current_versions else ""
                            current_version_tuple = parse_version(current_version_str.split('-')[0] if current_version_str else "")
                            new_version_tuple = parse_version(kernel_info['version'])
                            
                            if current_version_tuple and new_version_tuple <= current_version_tuple:
                                log.info(f"è·³è¿‡æ—§ç‰ˆæœ¬: {filename} (å½“å‰: {current_version_str}, æ–°: {full_version})")
                                continue
                            
                            if full_version not in found_groups[group]:
                                found_groups[group][full_version] = {}
                            
                            found_groups[group][full_version][filename] = msg
            
            # æ£€æŸ¥æ¯ä¸ªç»„çš„å®Œæ•´æ€§
            for group, versions in found_groups.items():
                for full_version, files in versions.items():
                    # æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰å¿…éœ€çš„æ–‡ä»¶
                    required_patterns = set(KERNEL_GROUPS[group])
                    existing_files = set(files.keys())
                    
                    # æ£€æŸ¥æ¯ä¸ªå¿…éœ€æ–‡ä»¶æ¨¡å¼æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªåŒ¹é…çš„æ–‡ä»¶
                    group_complete = True
                    for pattern in required_patterns:
                        if not any(pattern_match(f, pattern) for f in existing_files):
                            group_complete = False
                            log.info(f"ç»„ {group} ç‰ˆæœ¬ {full_version} ç¼ºå°‘åŒ¹é…æ¨¡å¼ {pattern} çš„æ–‡ä»¶")
                            break
                    
                    if group_complete:
                        log.info(f"ç»„ {group} ç‰ˆæœ¬ {full_version} å®Œæ•´")
                        
                        # å‡†å¤‡ä¸‹è½½æ–‡ä»¶
                        files_to_download = [(f, msg) for f, msg in files.items()]
                        group_dir = os.path.join(WORK_DIR, f"group_{group}_{full_version.replace('.', '_').replace('+', '_')}")
                        
                        # å¤„ç†ç»„
                        result = await process_group(client, group, files_to_download, group_dir)
                        if result:
                            updates[group] = result
                        else:
                            log.error(f"å¤„ç†ç»„ {group} å¤±è´¥")
            
            return updates if updates else None
        
        def main():
            log.info("="*50)
            log.info("OpenWrt å†…æ ¸åŒæ­¥å·¥å…·å¯åŠ¨ (å¢å¼ºç‰ˆ)")
            log.info("="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log.error(f"é”™è¯¯: ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                with client:
                    new_kernels = client.loop.run_until_complete(find_new_kernels(client))
            except Exception as e:
                log.error(f"Telegramé”™è¯¯: {str(e)}")
                return 3
            
            # è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
            current_versions, _ = get_current_versions()
            updated = False
            
            if new_kernels:
                # å¤„ç†æ–°å†…æ ¸
                target_dir = os.path.join(GIT_DIR, KERNEL_DIR)
                os.makedirs(target_dir, exist_ok=True)
                
                for group, data in new_kernels.items():
                    # å¤åˆ¶ZIPæ–‡ä»¶åˆ°ä»“åº“
                    target_path = os.path.join(target_dir, os.path.basename(data["zip_path"]))
                    shutil.copy2(data["zip_path"], target_path)
                    
                    # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                    current_versions[group] = f"{data['version']},{data['date_iso']}"
                    log.info(f"å·²æ›´æ–°: {group} (ç‰ˆæœ¬: {data['version']}, æ—¥æœŸ: {data['date_iso']})")
                    updated = True
                
                # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                update_versions(current_versions)
                
                # æäº¤æ›´æ”¹
                group_versions = []
                for group, data in new_kernels.items():
                    group_versions.append(f"{group}@{data['version']}")
                
                commit_msg = f"æ›´æ–°OpenWrtå†…æ ¸: {', '.join(group_versions)}"
                if commit_and_push(commit_msg):
                    log.info(f"åŒæ­¥æˆåŠŸ! æ›´æ–°äº† {len(new_kernels)} ä¸ªå†…æ ¸ç»„")
                else:
                    log.error("æäº¤å¤±è´¥")
                    return 4
            else:
                log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„å†…æ ¸æ–‡ä»¶")
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log.info("ä¸´æ—¶ç›®å½•å·²æ¸…ç†")
            
            log.info("="*50)
            log.info("åŒæ­¥ä»»åŠ¡å®Œæˆ")
            log.info("="*50)
            return 0
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            // å°è¯•è·å–ä»“åº“çš„ open issues
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            
            // æŸ¥æ‰¾æ ‡é¢˜ä¸º"å·¥ä½œæµé€šçŸ¥"çš„ issue
            const notificationIssue = issues.data.find(issue => 
              issue.title.includes('å·¥ä½œæµé€šçŸ¥')
            );
            
            let issueNumber;
            if (notificationIssue) {
              issueNumber = notificationIssue.number;
            } else {
              // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ›å»ºæ–°çš„ issue
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'å·¥ä½œæµé€šçŸ¥',
                body: 'æ­¤ issue ç”¨äºæ¥æ”¶å·¥ä½œæµå¤±è´¥é€šçŸ¥'
              });
              issueNumber = newIssue.data.number;
            }
            
            const message = `ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
            await github.rest.issues.createComment({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });
          } catch (error) {
            console.error('é€šçŸ¥å¤±è´¥:', error);
            // å›é€€åˆ°ç®€å•çš„æ—¥å¿—è¾“å‡º
            core.error(`ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼è¯¦æƒ…è¯·æŸ¥çœ‹è¿è¡Œ: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`);
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OpenWrt Kernel Sync from TELEGRAM"
          repository: ${{ github.repository }}