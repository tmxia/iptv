name: OpenWrt Kernel Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20åˆ†é’Ÿè¶…æ—¶
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip zip
        pip install telethon requests pytz

    - name: Run Kernel Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "openwrt_flippy"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        import zipfile
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        KERNEL_GROUPS = {
            "openwrt_flippy6.1": [
                "dtb-rockchip-6.1.*-flippy-93+*.tar.gz",
                "dtb-amlogic-6.1.*-flippy-93+*.tar.gz",
                "boot-6.1.*-flippy-93+*.tar.gz",
                "modules-6.1.*-flippy-93+*.tar.gz",
                "header-6.1.*-flippy-93+*.tar.gz",
                "dtb-allwinner-6.1.*-flippy-93+*.tar.gz"
            ],
            "openwrt_flippy6.12": [
                "dtb-amlogic-6.12.*-flippy-93+*.tar.gz",
                "dtb-rockchip-6.12.*-flippy-93+*.tar.gz",
                "boot-6.12.*-flippy-93+*.tar.gz",
                "dtb-allwinner-6.12.*-flippy-93+*.tar.gz",
                "header-6.12.*-flippy-93+*.tar.gz",
                "modules-6.12.*-flippy-93+*.tar.gz"
            ]
        }
        KERNEL_DIR = "kernels"
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = os.path.join(os.getcwd(), "temp_kernels")
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹
                log.info("æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹...")
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                
                log.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # æ·»åŠ å†…æ ¸ç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", KERNEL_DIR, "version.txt"], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # é‡è¯•æœºåˆ¶
                max_attempts = 3
                for attempt in range(1, max_attempts + 1):
                    try:
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹å¹¶å˜åŸº...")
                        subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                        
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ¨é€æ›´æ”¹...")
                        subprocess.run(
                            ["git", "push", repo_url, "HEAD:main"],
                            cwd=GIT_DIR,
                            check=True
                        )
                        log.info("æ¨é€æˆåŠŸ")
                        return True
                    except subprocess.CalledProcessError as e:
                        log.warning(f"å°è¯• {attempt} å¤±è´¥: {str(e)}")
                        if attempt < max_attempts:
                            log.info("ç­‰å¾…10ç§’åé‡è¯•...")
                            time.sleep(10)
                        else:
                            log.error(f"ç»è¿‡{max_attempts}æ¬¡å°è¯•åä»æ— æ³•æ¨é€æ›´æ”¹")
                            return False
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_current_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯"""
            version_path = os.path.join(GIT_DIR, "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f), True
                except json.JSONDecodeError:
                    log.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œé‡æ–°åˆå§‹åŒ–")
                    return {}, True
                except Exception as e:
                    log.warning(f"è¯»å–ç‰ˆæœ¬æ–‡ä»¶å¤±è´¥: {str(e)}ï¼Œé‡æ–°åˆå§‹åŒ–")
                    return {}, True
            return {}, False
        
        def update_versions(versions):
            version_path = os.path.join(GIT_DIR, "version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def pattern_match(filename, pattern):
            """ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ¹é…æ¨¡å¼"""
            pattern_regex = pattern.replace('.', r'\.').replace('*', r'.*')
            return re.fullmatch(pattern_regex, filename) is not None
        
        def find_matching_group(filename):
            """æŸ¥æ‰¾æ–‡ä»¶ååŒ¹é…çš„å†…æ ¸ç»„"""
            for group, patterns in KERNEL_GROUPS.items():
                for pattern in patterns:
                    if pattern_match(filename, pattern):
                        return group
            return None
        
        def extract_version_from_filename(filename):
            """ä»æ–‡ä»¶åä¸­æå–å®Œæ•´ç‰ˆæœ¬æ ‡è¯†"""
            # æå–å®Œæ•´çš„ç‰ˆæœ¬å­—ç¬¦ä¸² (e.g. 6.1.141-flippy-93+o)
            match = re.search(r'(\d+\.\d+\.\d+-flippy-\d+\+[a-z]*)', filename)
            return match.group(1) if match else None
        
        async def download_file(client, message, filename, download_path):
            total_size = message.document.size
            await client.download_media(message, file=download_path)
            return True
        
        def get_latest_date(messages):
            """è·å–ä¸€ç»„æ¶ˆæ¯ä¸­çš„æœ€æ–°æ—¥æœŸ"""
            latest_date = None
            for msg in messages:
                if latest_date is None or msg.date > latest_date:
                    latest_date = msg.date
            return latest_date
        
        async def process_group(client, group_name, version, files_to_download, group_dir):
            """å¤„ç†å®Œæ•´çš„å†…æ ¸ç»„"""
            # è·å–ç»„å†…æ‰€æœ‰æ¶ˆæ¯çš„æœ€æ–°æ—¥æœŸ
            all_messages = [msg for _, msg in files_to_download]
            latest_date = get_latest_date(all_messages)
            
            # è½¬æ¢ä¸ºUTC+8æ—¶åŒº
            utc8 = pytz.timezone('Asia/Shanghai')
            date_utc8 = latest_date.astimezone(utc8).strftime("%Y-%m-%d")
            
            log.info(f"å¼€å§‹ä¸‹è½½å†…æ ¸ç»„: {group_name} ç‰ˆæœ¬ {version} (å…± {len(files_to_download)} ä¸ªæ–‡ä»¶)")
            os.makedirs(group_dir, exist_ok=True)
            
            # ä¸‹è½½ç»„å†…æ‰€æœ‰æ–‡ä»¶
            for filename, msg in files_to_download:
                download_path = os.path.join(group_dir, filename)
                await download_file(client, msg, filename, download_path)
            
            log.info(f"ä¸‹è½½å®Œæˆ: {group_name} ç‰ˆæœ¬ {version}")
            
            # åˆ›å»ºZIPæ–‡ä»¶
            zip_filename = f"{group_name}_{version}.zip"
            zip_path = os.path.join(WORK_DIR, zip_filename)
            log.info(f"åˆ›å»ºZIPæ–‡ä»¶: {zip_filename}")
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                for root, _, files in os.walk(group_dir):
                    for file in files:
                        file_path = os.path.join(root, file)
                        zipf.write(file_path, os.path.basename(file_path))
            
            log.info(f"ZIPæ–‡ä»¶åˆ›å»ºå®Œæˆ: {zip_filename}")
            return zip_path, date_utc8
        
        def check_local_kernel_files(current_versions):
            """æ£€æŸ¥æœ¬åœ°å†…æ ¸æ–‡ä»¶æ˜¯å¦å­˜åœ¨"""
            for group, version_data in current_versions.items():
                if ',' in version_data:
                    version = version_data.split(',')[0]
                    zip_file = f"{group}_{version}.zip"
                    zip_path = os.path.join(GIT_DIR, KERNEL_DIR, zip_file)
                    
                    if not os.path.exists(zip_path):
                        log.warning(f"æœ¬åœ°å†…æ ¸æ–‡ä»¶ç¼ºå¤±: {zip_file}")
                        return False
            return True
        
        async def find_new_kernels(client, current_versions):
            log.info("è¿æ¥Telegram...")
            await client.connect()
            if not await client.is_user_authorized():
                log.error("é”™è¯¯: Telegramä¼šè¯æ— æ•ˆ")
                return None
            
            channel = os.environ.get('TELEGRAM_CHANNEL', 'openwrt_flippy')
            log.info(f"æ‰«æé¢‘é“: {channel} (æœ€è¿‘50æ¡æ¶ˆæ¯)")
            entity = await client.get_entity(channel)
            
            updates = {}
            
            # å­˜å‚¨æ‰¾åˆ°çš„æ–‡ä»¶ {group: {version: {filename: message}}}
            found_groups = {group: {} for group in KERNEL_GROUPS.keys()}
            
            # è·å–é¢‘é“ä¸­æœ€æ–°çš„50æ¡æ¶ˆæ¯
            async for msg in client.iter_messages(entity, limit=50):
                if msg.media and hasattr(msg.media, "document"):
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            group = find_matching_group(filename)
                            if group:
                                version = extract_version_from_filename(filename)
                                if not version:
                                    continue
                                
                                if version not in found_groups[group]:
                                    found_groups[group][version] = {}
                                
                                found_groups[group][version][filename] = msg
            
            # æ£€æŸ¥æ¯ä¸ªç»„çš„å®Œæ•´æ€§
            for group, versions in found_groups.items():
                # æŒ‰ç‰ˆæœ¬å·æ’åºï¼ˆä»æ–°åˆ°æ—§ï¼‰
                if not versions:
                    continue
                    
                sorted_versions = sorted(versions.keys(), reverse=True)
                for version in sorted_versions:
                    files = versions[version]
                    # æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰å¿…éœ€çš„æ–‡ä»¶
                    required_files = set(KERNEL_GROUPS[group])
                    existing_files = set(files.keys())
                    
                    # æ£€æŸ¥æ¯ä¸ªå¿…éœ€æ–‡ä»¶æ¨¡å¼æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªåŒ¹é…çš„æ–‡ä»¶
                    group_complete = True
                    for pattern in required_files:
                        if not any(pattern_match(f, pattern) for f in existing_files):
                            group_complete = False
                            break
                    
                    if group_complete:
                        log.info(f"å‘ç°å®Œæ•´å†…æ ¸ç»„: {group} ç‰ˆæœ¬ {version}")
                        
                        # æ£€æŸ¥å½“å‰ç‰ˆæœ¬ä¿¡æ¯
                        current_value = current_versions.get(group, "")
                        current_version = current_value.split(",")[0] if current_value else ""
                        current_date = current_value.split(",")[1] if "," in current_value else ""
                        
                        # è·å–ç»„å†…æ‰€æœ‰æ¶ˆæ¯çš„æœ€æ–°æ—¥æœŸ
                        all_messages = list(files.values())
                        latest_date = get_latest_date(all_messages)
                        
                        # è½¬æ¢ä¸ºæ—¥æœŸå­—ç¬¦ä¸²ï¼ˆYYYY-MM-DDï¼‰
                        utc8 = pytz.timezone('Asia/Shanghai')
                        date_utc8 = latest_date.astimezone(utc8).strftime("%Y-%m-%d")
                        
                        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                        version_updated = False
                        if not current_version:
                            version_updated = True
                            log.info(f"æ–°å†…æ ¸ç»„: {group} (é¦–æ¬¡æ·»åŠ )")
                        elif version != current_version:
                            version_updated = True
                            log.info(f"å‘ç°æ–°ç‰ˆæœ¬: {version} (å½“å‰: {current_version})")
                        elif date_utc8 > current_date:
                            version_updated = True
                            log.info(f"ç›¸åŒç‰ˆæœ¬ä½†æ›´æ–°æ—¥æœŸ: {date_utc8} > {current_date}")
                        
                        if version_updated:
                            # å‡†å¤‡ä¸‹è½½æ–‡ä»¶
                            files_to_download = [(f, msg) for f, msg in files.items()]
                            group_dir = os.path.join(WORK_DIR, f"group_{group}_{version}")
                            
                            zip_path, zip_date = await process_group(client, group, version, files_to_download, group_dir)
                            updates[group] = {
                                "version": version,
                                "date_iso": zip_date,
                                "zip_path": zip_path
                            }
                        
                        # åªå¤„ç†æœ€æ–°ç‰ˆæœ¬ï¼Œè·³è¿‡æ—§ç‰ˆæœ¬
                        break
            
            return updates if updates else None
        
        def main():
            log.info("="*50)
            log.info("OpenWrt å†…æ ¸åŒæ­¥å·¥å…·å¯åŠ¨")
            log.info("="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log.error(f"é”™è¯¯: ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            # 1. è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
            current_versions, version_file_exists = get_current_versions()
            log.info(f"å½“å‰ç‰ˆæœ¬ä¿¡æ¯: {json.dumps(current_versions, indent=2)}")
            
            # 2. æ£€æŸ¥æœ¬åœ°å†…æ ¸æ–‡ä»¶æ˜¯å¦å­˜åœ¨
            if version_file_exists and current_versions:
                local_files_ok = check_local_kernel_files(current_versions)
                if not local_files_ok:
                    log.error("é”™è¯¯: æœ¬åœ°å†…æ ¸æ–‡ä»¶ç¼ºå¤±ï¼Œè¯·æ‰‹åŠ¨ä¿®å¤")
                    return 5
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                with client:
                    # 3. è¿æ¥TelegramæŸ¥æ‰¾æ–°å†…æ ¸
                    new_kernels = client.loop.run_until_complete(
                        find_new_kernels(client, current_versions)
            except Exception as e:
                log.error(f"Telegramé”™è¯¯: {str(e)}")
                return 3
            
            updated = False
            
            if new_kernels:
                # 4. å¤„ç†æ–°å†…æ ¸
                target_dir = os.path.join(GIT_DIR, KERNEL_DIR)
                os.makedirs(target_dir, exist_ok=True)
                
                for group, data in new_kernels.items():
                    # å¤åˆ¶ZIPæ–‡ä»¶åˆ°ä»“åº“
                    target_path = os.path.join(target_dir, os.path.basename(data["zip_path"]))
                    shutil.copy2(data["zip_path"], target_path)
                    
                    # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                    current_versions[group] = f"{data['version']},{data['date_iso']}"
                    log.info(f"å·²æ›´æ–°: {group} (ç‰ˆæœ¬: {data['version']}, æ—¥æœŸ: {data['date_iso']})")
                    updated = True
                
                # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                update_versions(current_versions)
                
                # ç”Ÿæˆæäº¤ä¿¡æ¯
                group_versions = []
                for group, data in new_kernels.items():
                    group_versions.append(f"{group}@{data['version']}")
                
                commit_msg = f"æ›´æ–°OpenWrtå†…æ ¸: {', '.join(group_versions)}"
                if commit_and_push(commit_msg):
                    log.info(f"åŒæ­¥æˆåŠŸ! æ›´æ–°äº† {len(new_kernels)} ä¸ªå†…æ ¸ç»„")
                else:
                    log.error("æäº¤å¤±è´¥")
                    return 4
            else:
                log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„å†…æ ¸æ–‡ä»¶")
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log.info("ä¸´æ—¶ç›®å½•å·²æ¸…ç†")
            
            log.info("="*50)
            log.info("åŒæ­¥ä»»åŠ¡å®Œæˆ")
            log.info("="*50)
            return 0
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            const issue_number = context.issue.number;
            if (issue_number) {
              const message = `ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
              await github.rest.issues.createComment({
                issue_number: issue_number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: message
              });
            } else {
              // å½“æ²¡æœ‰issueä¸Šä¸‹æ–‡æ—¶ï¼Œåˆ›å»ºæ–°issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `å·¥ä½œæµå¤±è´¥é€šçŸ¥ - ${{ github.workflow }} #${{ github.run_number }}`,
                body: `ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
              console.log(`åˆ›å»ºäº†æ–°issue: ${issue.data.html_url}`);
            }
          } catch (error) {
            console.error('é€šçŸ¥å¤±è´¥:', error);
            core.error(`ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼è¯¦æƒ…è¯·æŸ¥çœ‹è¿è¡Œ: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`);
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OpenWrt Kernel Sync from TELEGRAM"
          repository: ${{ github.repository }}