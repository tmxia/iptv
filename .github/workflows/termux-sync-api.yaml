name: Termux APK Sync from Source Repository

# 使用原生并发控制
concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */24 * * *'  # 每24小时运行一次
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    # 基于缓存的锁机制（由concurrency配置实现）
    
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl
        
    - name: Run optimized APK sync
      env:
        SOURCE_REPO: "termux/termux-app"
        TARGET_REPO: "${{ github.repository }}"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
        STABLE_KEY_NAME: "termux.apk"
        PRE_RELEASE_KEY_NAME: "termux-beta.apk"
        STABLE_APK_PATTERN: "github-debug_arm64-v8a.apk"
        PRE_RELEASE_APK_PATTERN: "android-7-github-debug_arm64-v8a.apk"
      run: |
        #!/bin/bash
        set -euo pipefail
        
        # 创建临时工作目录
        WORK_DIR=$(mktemp -d)
        trap 'rm -rf "$WORK_DIR"; echo "清理临时目录..."' EXIT
        
        # 1. 获取源仓库发布信息
        echo "获取源仓库发布信息..."
        releases=$(curl -sL "https://api.github.com/repos/$SOURCE_REPO/releases")
        
        # 提取稳定版信息
        stable_release=$(echo "$releases" | jq -r '[.[] | select(.prerelease == false)] | sort_by(.published_at) | reverse | .[0]')
        stable_version=$(echo "$stable_release" | jq -r '.tag_name')
        stable_main_version=$(echo "$stable_version" | sed 's/-.*//')
        stable_date=$(echo "$stable_release" | jq -r '.published_at' | TZ=UTC date -f - +'%Y-%m-%d')
        echo "稳定版: $stable_main_version ($stable_date)"
        
        # 提取预发行版信息
        pre_release=$(echo "$releases" | jq -r '[.[] | select(.prerelease == true)] | sort_by(.published_at) | reverse | .[0]')
        if [ "$pre_release" = "null" ]; then
          echo "无预发行版可用"
          sync_pre_release=false
        else
          pre_version=$(echo "$pre_release" | jq -r '.tag_name')
          pre_main_version=$(echo "$pre_version" | sed 's/-.*//')
          pre_date=$(echo "$pre_release" | jq -r '.published_at' | TZ=UTC date -f - +'%Y-%m-%d')
          echo "预发行版: $pre_main_version ($pre_date)"
          sync_pre_release=true
        fi
        
        # 2. 获取目标仓库版本文件
        echo "获取目标仓库版本信息..."
        version_response=$(curl -s -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
        
        # 初始化版本数据
        if [ "$(echo "$version_response" | jq -r '.message')" != "Not Found" ]; then
          current_versions=$(echo "$version_response" | jq -r '.content' | base64 -d | jq -c .)
          echo "当前版本信息:"
          # 只显示的键值
          echo "$current_versions" | jq -r ".\"$STABLE_KEY_NAME\" // \"(未设置)\"" | awk -v key="$STABLE_KEY_NAME" '{print key ": " $0}'
          if [ "$sync_pre_release" = true ]; then
            echo "$current_versions" | jq -r ".\"$PRE_RELEASE_KEY_NAME\" // \"(未设置)\"" | awk -v key="$PRE_RELEASE_KEY_NAME" '{print key ": " $0}'
          fi
        else
          current_versions="{}"
          echo "无版本文件"
          echo "$STABLE_KEY_NAME: (未设置)"
          if [ "$sync_pre_release" = true ]; then
            echo "$PRE_RELEASE_KEY_NAME: (未设置)"
          fi
        fi
        
        # 3. 更新版本数据函数
        update_version_data() {
          local key=$1
          local version=$2
          local date=$3
          
          # 仅更新指定键值
          current_versions=$(echo "$current_versions" | jq \
            --arg key "$key" \
            --arg value "$version,$date" \
            '.[$key] = $value')
        }
        
        # 4. 增强文件存在性检测
        check_file_exists() {
          local key_name=$1
          local target_path="apk/$key_name"
          
          # 检查文件是否存在
          response=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target_path")
          
          if [ "$response" -eq 200 ]; then
            echo "文件存在: $target_path"
            return 0
          else
            echo "文件缺失: $target_path"
            return 1
          fi
        }
        
        # 5. 增强版本键值存在性检测
        check_key_exists() {
          local key_name=$1
          
          # 检查键值是否存在
          if echo "$current_versions" | jq -e "has(\"$key_name\")" >/dev/null; then
            echo "版本键值存在: $key_name"
            return 0
          else
            echo "版本键值缺失: $key_name"
            return 1
          fi
        }
        
        # 6. 检查并下载APK
        check_and_download() {
          local release_json=$1
          local key_name=$2
          local apk_pattern=$3
          local main_version=$4
          local date=$5
          
          # 获取目标文件名
          local target_filename="apk/$key_name"
          
          # 检查文件是否存在
          file_exists=$(check_file_exists "$key_name")
          file_missing=$?
          
          # 检查键值是否存在
          key_exists=$(check_key_exists "$key_name")
          key_missing=$?
          
          # 获取当前版本值
          local current_value=$(echo "$current_versions" | jq -r ".\"$key_name\" // \"\"")
          
          # 确定是否需要更新
          if [[ $file_missing -eq 1 || $key_missing -eq 1 || "$current_value" != "$main_version,$date" ]]; then
            # 下载APK
            download_url=$(echo "$release_json" | jq -r \
              ".assets[] | select(.name | contains(\"$apk_pattern\")) | .browser_download_url" | head -1)
            
            if [ -z "$download_url" ]; then
              echo "错误: 未找到匹配的APK文件: $apk_pattern"
              return 1
            fi
            
            echo "下载: $download_url"
            curl -sL "$download_url" -o "$WORK_DIR/$key_name"
            
            # 更新版本数据
            update_version_data "$key_name" "$main_version" "$date"
            return 0
          else
            echo "无需更新: $key_name ($current_value)"
            return 1
          fi
        }
        
        # 7. 上传文件函数
        upload_file() {
          local file_path=$1
          local target_path=$2
          local version=$3
          
          # 获取SHA（如果存在）
          response=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target_path")
          
          if [ "$(echo "$response" | jq -r '.message')" = "Not Found" ]; then
            sha=""
          else
            sha=$(echo "$response" | jq -r '.sha')
          fi
          
          # 准备上传数据
          content_base64=$(base64 -w0 "$file_path")
          commit_msg="更新: $target_path 到版本 $version"
          json_data=$(jq -n \
            --arg msg "$commit_msg" \
            --arg content "$content_base64" \
            --arg sha "$sha" \
            '{message: $msg, content: $content, sha: $sha}')
          
          # 上传文件
          echo "上传: $target_path"
          curl -s -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$json_data" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target_path" > /dev/null
        }
        
        # 8. 处理稳定版
        echo "处理稳定版..."
        if check_and_download "$stable_release" "$STABLE_KEY_NAME" \
          "$STABLE_APK_PATTERN" "$stable_main_version" "$stable_date"; then
          upload_file "$WORK_DIR/$STABLE_KEY_NAME" "apk/$STABLE_KEY_NAME" "$stable_main_version"
        fi
        
        # 9. 处理预发行版
        if [ "$sync_pre_release" = true ]; then
          echo "处理预发行版..."
          if check_and_download "$pre_release" "$PRE_RELEASE_KEY_NAME" \
            "$PRE_RELEASE_APK_PATTERN" "$pre_main_version" "$pre_date"; then
            upload_file "$WORK_DIR/$PRE_RELEASE_KEY_NAME" "apk/$PRE_RELEASE_KEY_NAME" "$pre_main_version"
          fi
        fi
        
        # 10. 更新版本文件
        echo "更新版本文件..."
        # 获取版本文件SHA
        if [ "$(echo "$version_response" | jq -r '.message')" = "Not Found" ]; then
          version_sha=""
        else
          version_sha=$(echo "$version_response" | jq -r '.sha')
        fi
        
        # 准备版本文件内容
        version_content=$(echo "$current_versions" | jq -c .)
        version_base64=$(echo -n "$version_content" | base64 -w0)
        
        version_json=$(jq -n \
          --arg msg "更新版本信息" \
          --arg content "$version_base64" \
          --arg sha "$version_sha" \
          '{message: $msg, content: $content, sha: $sha}')
        
        # 上传版本文件
        curl -s -X PUT \
          -H "Authorization: token $TOKEN" \
          -H "Content-Type: application/json" \
          -d "$version_json" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt" > /dev/null
        
        # 11. 显示最终当前的版本信息
        echo "同步完成! 当前版本信息:"
        # 只显示相应的键值
        echo "$current_versions" | jq -r ".\"$STABLE_KEY_NAME\" // \"(未设置)\"" | awk -v key="$STABLE_KEY_NAME" '{print key ": " $0}'
        if [ "$sync_pre_release" = true ]; then
          echo "$current_versions" | jq -r ".\"$PRE_RELEASE_KEY_NAME\" // \"(未设置)\"" | awk -v key="$PRE_RELEASE_KEY_NAME" '{print key ": " $0}'
        fi

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "Termux APK Sync from Source Repository"
          repository: ${{ github.repository }}