name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20åˆ†é’Ÿè¶…æ—¶
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install Android SDK for aapt2
      run: |
        SDK_TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-10406996_latest.zip"
        curl -sL "$SDK_TOOLS_URL" -o sdk-tools.zip
        unzip -q sdk-tools.zip -d android-sdk
        
        echo "ANDROID_SDK_ROOT=$GITHUB_WORKSPACE/android-sdk" >> $GITHUB_ENV
        echo "$GITHUB_WORKSPACE/android-sdk/cmdline-tools/bin" >> $GITHUB_PATH
        
        yes | android-sdk/cmdline-tools/bin/sdkmanager --sdk_root=$GITHUB_WORKSPACE/android-sdk "build-tools;34.0.0"
        echo "aapt2è·¯å¾„: $GITHUB_WORKSPACE/android-sdk/build-tools/34.0.0/aapt2"
        
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip
        pip install telethon requests

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL || 'tvb_ys' }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        
        # é…ç½®å‚æ•°
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = os.path.join(os.getcwd(), "temp_apks")
        GIT_DIR = os.getcwd()
        ANDROID_SDK_ROOT = os.environ.get('ANDROID_SDK_ROOT', '/usr/local/lib/android/sdk')
        AAPT2_PATH = f"{ANDROID_SDK_ROOT}/build-tools/34.0.0/aapt2"
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹ï¼ˆé˜²æ­¢å†²çªï¼‰
                log.info("æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹...")
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                
                log.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # åªæ·»åŠ apkç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", APK_DIR, "version.txt"], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # é‡è¯•æœºåˆ¶ï¼ˆæœ€å¤š3æ¬¡ï¼‰
                max_attempts = 3
                for attempt in range(1, max_attempts + 1):
                    try:
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹å¹¶å˜åŸº...")
                        subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                        
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ¨é€æ›´æ”¹...")
                        subprocess.run(
                            ["git", "push", repo_url, "HEAD:main"],
                            cwd=GIT_DIR,
                            check=True
                        )
                        log.info("æ¨é€æˆåŠŸ")
                        return True
                    except subprocess.CalledProcessError as e:
                        log.warning(f"å°è¯• {attempt} å¤±è´¥: {str(e)}")
                        if attempt < max_attempts:
                            log.info("ç­‰å¾…10ç§’åé‡è¯•...")
                            time.sleep(10)
                        else:
                            log.error(f"ç»è¿‡{max_attempts}æ¬¡å°è¯•åä»æ— æ³•æ¨é€æ›´æ”¹")
                            return False
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_current_versions():
            version_path = os.path.join(GIT_DIR, "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f)
                except:
                    log.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œé‡æ–°åˆå§‹åŒ–")
            return {}
        
        def update_versions(versions):
            version_path = os.path.join(GIT_DIR, "version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def extract_apk_version(apk_path):
            """ä½¿ç”¨aapt2ä»APKæå–ç‰ˆæœ¬å·"""
            try:
                log.info(f"ä»APKæå–ç‰ˆæœ¬å·: {apk_path}")
                result = subprocess.run(
                    [AAPT2_PATH, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # æŸ¥æ‰¾versionName
                for line in result.stdout.splitlines():
                    if "versionName" in line:
                        match = re.search(r"versionName='([^']*)'", line)
                        if match:
                            version = match.group(1)
                            # ç¡®ä¿ç‰ˆæœ¬å·ä»¥"v"å¼€å¤´
                            if not version.startswith('v'):
                                version = 'v' + version
                            log.info(f"æå–çš„ç‰ˆæœ¬å·: {version}")
                            return version
                
                log.warning(f"è­¦å‘Š: æ— æ³•ä» {apk_path} æå–ç‰ˆæœ¬å·")
                return None
            except Exception as e:
                log.error(f"æå–ç‰ˆæœ¬å·å¤±è´¥: {str(e)}")
                return None
        
        async def download_apk(client, message, filename):
            download_path = os.path.join(WORK_DIR, filename)
            
            total_size = message.document.size
            log.info(f"å¼€å§‹ä¸‹è½½: {filename} ({format_size(total_size)})")
            
            start_time = time.time()
            last_progress_time = start_time
            last_downloaded = 0
            
            def callback(current, total):
                nonlocal last_progress_time, last_downloaded
                current_time = time.time()
                
                # æ¯2ç§’æˆ–ä¸‹è½½å®Œæˆæ—¶æ›´æ–°ä¸€æ¬¡è¿›åº¦
                if current_time - last_progress_time > 2 or current == total:
                    elapsed = current_time - start_time
                    percent = int((current / total) * 100)
                    speed = (current - last_downloaded) / (current_time - last_progress_time)
                    
                    # æ›´æ–°æ—¥å¿—
                    log.info(f"ä¸‹è½½ä¸­: {filename} - {percent}% ({format_size(current)}/{format_size(total)}) "
                         f"[é€Ÿåº¦: {format_size(speed)}/s]")
                    
                    last_progress_time = current_time
                    last_downloaded = current
            
            await client.download_media(message, file=download_path, progress_callback=callback)
            
            # ä¸‹è½½å®Œæˆåæ˜¾ç¤ºæœ€ç»ˆä¿¡æ¯
            elapsed = time.time() - start_time
            avg_speed = total_size / elapsed if elapsed > 0 else 0
            log.info(f"ä¸‹è½½å®Œæˆ: {filename} - è€—æ—¶: {elapsed:.1f}ç§’, å¹³å‡é€Ÿåº¦: {format_size(avg_speed)}/s")
            
            # ä»APKæå–ç‰ˆæœ¬å·
            version = extract_apk_version(download_path)
            if not version:
                # å¦‚æœæ— æ³•æå–ç‰ˆæœ¬å·ï¼Œä½¿ç”¨æ—¥æœŸä½œä¸ºåå¤‡
                date_str = message.date.strftime("%Y%m%d")
                version = f"v{filename.split('.')[0]}-{date_str}"
                log.info(f"ä½¿ç”¨åå¤‡ç‰ˆæœ¬å·: {version}")
            
            # ISOæ ¼å¼æ—¥æœŸï¼ˆYYYY-MM-DDï¼‰
            date_iso = message.date.strftime("%Y-%m-%d")
            
            return {
                "path": download_path,
                "version": version,
                "date_iso": date_iso
            }
        
        async def find_new_apks(client):
            log.info("è¿æ¥Telegram...")
            await client.connect()
            if not await client.is_user_authorized():
                log.error("é”™è¯¯: Telegramä¼šè¯æ— æ•ˆ")
                return None
            
            channel = os.environ.get('TELEGRAM_CHANNEL', 'tvb_ys')
            log.info(f"æ‰«æé¢‘é“: {channel}")
            entity = await client.get_entity(channel)
            
            latest_msgs = {}
            async for msg in client.iter_messages(entity, limit=50):
                if msg.media and hasattr(msg.media, "document"):
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            if filename in APK_FILES:
                                if filename not in latest_msgs or msg.id > latest_msgs[filename].id:
                                    latest_msgs[filename] = msg
            
            current_versions = get_current_versions()
            updates = {}
            
            for filename, msg in latest_msgs.items():
                # å¤„ç†å½“å‰ç‰ˆæœ¬å€¼ï¼ˆå¯èƒ½æ˜¯æ—§æ ¼å¼æˆ–æ–°æ ¼å¼ï¼‰
                current_value = current_versions.get(filename, "")
                if ',' in current_value:
                    # å¦‚æœæ˜¯æ–°æ ¼å¼ "ç‰ˆæœ¬å·,æ—¥æœŸ"ï¼Œåˆ™æå–ç‰ˆæœ¬éƒ¨åˆ†
                    current_version = current_value.split(',')[0]
                else:
                    current_version = current_value
                
                # ä¸‹è½½APKå¹¶æå–ç‰ˆæœ¬å·
                apk_data = await download_apk(client, msg, filename)
                if not apk_data:
                    continue
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ–°ç‰ˆæœ¬
                if apk_data["version"] != current_version:
                    log.info(f"å‘ç°æ–°ç‰ˆæœ¬: {filename} ({current_version} â†’ {apk_data['version']})")
                    updates[filename] = apk_data
                else:
                    log.info(f"{filename} å·²æ˜¯æœ€æ–°ç‰ˆæœ¬: {current_version}")
            
            return updates if updates else None
        
        def main():
            log.info("="*50)
            log.info("APK åŒæ­¥å·¥å…·å¯åŠ¨")
            log.info("="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log.error(f"é”™è¯¯: ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                with client:
                    new_apks = client.loop.run_until_complete(find_new_apks(client))
            except Exception as e:
                log.error(f"Telegramé”™è¯¯: {str(e)}")
                return 3
            
            if not new_apks:
                log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
                return 0
            
            # å¤„ç†æ–°æ–‡ä»¶
            current_versions = get_current_versions()
            updated = {}
            target_dir = os.path.join(GIT_DIR, APK_DIR)
            os.makedirs(target_dir, exist_ok=True)
            
            for filename, data in new_apks.items():
                target_path = os.path.join(target_dir, filename)
                shutil.copy2(data["path"], target_path)
                
                # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯ä¸º "ç‰ˆæœ¬å·,æ—¥æœŸ" æ ¼å¼
                new_value = f"{data['version']},{data['date_iso']}"
                current_versions[filename] = new_value
                updated[filename] = new_value
                log.info(f"å·²æ›´æ–°: {filename} (ç‰ˆæœ¬: {new_value})")
            
            # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
            update_versions(current_versions)
            
            # æäº¤æ›´æ”¹
            commit_msg = f"æ›´æ–°APK: {', '.join([f'{k}={v}' for k, v in updated.items()])}"
            if commit_and_push(commit_msg):
                log.info(f"åŒæ­¥æˆåŠŸ! æ›´æ–°äº† {len(updated)} ä¸ªæ–‡ä»¶")
            else:
                log.error("æäº¤å¤±è´¥")
                return 4
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log.info("ä¸´æ—¶ç›®å½•å·²æ¸…ç†")
            
            log.info("="*50)
            log.info("åŒæ­¥ä»»åŠ¡å®Œæˆ")
            log.info("="*50)
            return 0
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          const message = `ğŸš¨ Telegram APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          })

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}