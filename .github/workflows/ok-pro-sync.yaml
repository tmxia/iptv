name: OK APK Sync from QuarkDrive (Enhanced)

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip
        pip install requests pycryptodome pytz

    - name: Run Enhanced Quark Drive Sync
      env:
        QUARK_CK: ${{ secrets.QUARK_CK }}  # å°†å¤¸å…‹ckå­˜å…¥GitHub Secrets
        SHARE_URL: https://pan.quark.cn/s/6fead79bddaf
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import re
        import time
        import requests
        from datetime import datetime
        from pathlib import Path
        import logging
        import hashlib
        import base64
        from Crypto.Cipher import AES
        import pytz
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
        log = logging.getLogger("quark_sync")
        
        # é…ç½®å‚æ•°
        WORK_DIR = "temp_apks"
        APK_DIR = "apk"
        PRO_FOLDER = "OKåˆ†äº«/OKå½±è§†Pro"
        STD_FOLDER = "OKåˆ†äº«/OKå½±è§†æ ‡å‡†ç‰ˆ"
        
        # ç²¾ç¡®çš„è·¯å¾„æ¨¡æ¿
        STD_PATH_TEMPLATES = {
            "leanback": STD_FOLDER + "/{version}/leanback-armeabi_v7a-{version_num}.apk",
            "mobile": STD_FOLDER + "/{version}/mobile-arm64_v8a-{version_num}.apk"
        }
        
        PRO_PATH_TEMPLATES = {
            "leanback": PRO_FOLDER + "/OKå½±è§†Proï¹£ç”µè§†ç‰ˆï¹£--{version_num}.apk",
            "mobile": PRO_FOLDER + "/OKå½±è§†Proï¹£æ‰‹æœºç‰ˆï¹£--{version_num}.apk"
        }
        
        # ç›®æ ‡é‡å‘½å
        RENAME_MAP = {
            "std_leanback": "leanback.apk",
            "std_mobile": "mobile.apk",
            "pro_leanback": "leanback-pro.apk",
            "pro_mobile": "mobile-pro.apk"
        }
        
        # åŒ—äº¬æ—¶åŒº
        TZ_BEIJING = pytz.timezone('Asia/Shanghai')
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = f"{actor}@users.noreply.github.com"
                
                subprocess.run(["git", "config", "user.name", actor], check=True)
                subprocess.run(["git", "config", "user.email", email], check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹é˜²æ­¢å†²çª
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
                
                log.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # åªæ·»åŠ APKç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", APK_DIR, "version.txt"], check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True)
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # é‡è¯•æœºåˆ¶
                max_attempts = 3
                for attempt in range(1, max_attempts + 1):
                    try:
                        log.info(f"å°è¯• {attempt}/{max_attempts}: æ¨é€æ›´æ”¹...")
                        # åœ¨æ¨é€å‰å†æ¬¡æ‹‰å–æœ€æ–°æ›´æ”¹
                        subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
                        subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                        log.info("æ¨é€æˆåŠŸ")
                        return True
                    except Exception as e:
                        log.warning(f"å°è¯• {attempt} å¤±è´¥: {str(e)}")
                        if attempt < max_attempts:
                            time.sleep(10)
                
                log.error(f"ç»è¿‡{max_attempts}æ¬¡å°è¯•åä»æ— æ³•æ¨é€æ›´æ”¹")
                return False
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def load_version_file():
            """å®‰å…¨åŠ è½½ç‰ˆæœ¬æ–‡ä»¶ï¼Œç¡®ä¿ä¸ä¼šæ¸…ç©º"""
            version_path = Path("version.txt")
            versions = {}
            if version_path.exists():
                try:
                    with open(version_path, "r") as f:
                        versions = json.load(f)
                except Exception:
                    log.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œä½†ä¸ä¼šæ¸…ç©º")
            return versions
        
        def save_version_file(versions):
            version_path = Path("version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def parse_cookies(cookie_str):
            cookies = {}
            for item in cookie_str.split(';'):
                item = item.strip()
                if not item:
                    continue
                if '=' in item:
                    key, value = item.split('=', 1)
                    cookies[key] = value
                else:
                    cookies[item] = None
            return cookies
        
        def decrypt_download_url(encrypted_url, file_key):
            """è§£å¯†å¤¸å…‹ç½‘ç›˜ä¸‹è½½URL"""
            # ç”ŸæˆAESå¯†é’¥
            aes_key = hashlib.md5(file_key.encode()).hexdigest().encode()
            iv = b"ef0e50a8a48afdac"
            
            # è§£å¯†
            cipher = AES.new(aes_key, AES.MODE_CBC, iv)
            encrypted_url = base64.b64decode(encrypted_url)
            decrypted = cipher.decrypt(encrypted_url)
            
            # ç§»é™¤PKCS7å¡«å……
            pad = decrypted[-1]
            if pad < 16:
                decrypted = decrypted[:-pad]
            
            return decrypted.decode('utf-8')
        
        def get_all_share_files(share_url, cookies):
            """è·å–åˆ†äº«é“¾æ¥ä¸‹çš„æ‰€æœ‰æ–‡ä»¶"""
            share_id = share_url.split("/s/")[-1]
            api_url = "https://drive-pc.quark.cn/1/clouddrive/share/sharepage/detail"
            
            headers = {
                "Referer": share_url,
                "Content-Type": "application/json"
            }
            
            all_files = []
            page = 1
            has_more = True
            
            while has_more:
                payload = {
                    "share_id": share_id,
                    "pdir_fid": "",
                    "page": page,
                    "per_page": 50,
                    "file_type": 0
                }
                
                response = requests.post(api_url, json=payload, headers=headers, cookies=cookies)
                data = response.json()
                
                if data.get("data", {}).get("list"):
                    all_files.extend(data["data"]["list"])
                
                has_more = data.get("data", {}).get("is_more", 0) == 1
                page += 1
                time.sleep(0.5)
            
            return all_files
        
        def find_files_by_template(files, templates):
            """é€šè¿‡ç²¾ç¡®è·¯å¾„æ¨¡æ¿æŸ¥æ‰¾æ–‡ä»¶"""
            found_files = {}
            
            for file in files:
                if not file.get("file_name") or not file.get("updated_at"):
                    continue
                
                path = file.get("path", "") + "/" + file["file_name"]
                
                # å°è¯•åŒ¹é…æ ‡å‡†ç‰ˆæ¨¡æ¿
                for file_type, template in templates.items():
                    # æ›¿æ¢ç‰ˆæœ¬å ä½ç¬¦ä¸ºåŒ¹é…é€šé…ç¬¦
                    pattern = re.escape(template).replace(re.escape("{version}"), r"([\d.]+)") \
                                                .replace(re.escape("{version_num}"), r"([\d.]+)")
                    
                    match = re.match(pattern, path)
                    if match:
                        version = match.group(1)
                        # ç‰ˆæœ¬å·ä¸­çš„ç‚¹éœ€è¦ä¿ç•™ä¸ºå­—ç¬¦ä¸²ç”¨äºåŒ¹é…
                        version_num = match.group(2)
                        
                        if not version_num.replace(".", "").isdigit():
                            continue
                            
                        if file_type not in found_files or version > found_files[file_type]["version"]:
                            found_files[file_type] = {
                                "fid": file["fid"],
                                "key": file["hash_name"],
                                "version": version,
                                "version_num": version_num,
                                "path": path,
                                "size": file["size"],
                                "timestamp": int(file["updated_at"]),
                                "file_name": file["file_name"]
                            }
                        break
            
            return found_files
        
        def should_update(versions, file_type, new_version, new_date):
            """åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°æ­¤æ–‡ä»¶"""
            # æ–‡ä»¶ç±»å‹åœ¨ç‰ˆæœ¬æ–‡ä»¶ä¸­çš„é”®å
            key = RENAME_MAP[file_type]
            
            # å¦‚æœç‰ˆæœ¬æ–‡ä»¶ä¸­ä¸å­˜åœ¨è®°å½•ï¼Œéœ€è¦æ›´æ–°
            if key not in versions:
                log.info(f"æ–°æ–‡ä»¶: {key}")
                return True
            
            current_val = versions[key]
            if ',' not in current_val:
                log.info(f"ç‰ˆæœ¬æ ¼å¼é”™è¯¯ï¼Œéœ€è¦æ›´æ–°: {key}")
                return True
            
            # è§£æå½“å‰è®°å½•çš„ç‰ˆæœ¬å’Œæ—¥æœŸ
            current_ver, current_date = current_val.split(',', 1)
            
            # ç‰ˆæœ¬å·æ¯”è¾ƒï¼ˆä½¿ç”¨æ•°å­—åˆ†å‰²æ¯”è¾ƒï¼‰
            def version_tuple(v):
                return tuple(map(int, v.split('.')))
            
            try:
                new_ver_tuple = version_tuple(new_version)
                current_ver_tuple = version_tuple(current_ver)
                
                # æ–°ç‰ˆæœ¬å·æ›´é«˜
                if new_ver_tuple > current_ver_tuple:
                    log.info(f"æ–°ç‰ˆæœ¬: {current_ver} â†’ {new_version} ({key})")
                    return True
                
                # ç‰ˆæœ¬ç›¸åŒä½†æ—¥æœŸæ›´æ–°
                if new_ver_tuple == current_ver_tuple and new_date > current_date:
                    log.info(f"ç›¸åŒç‰ˆæœ¬ä½†æ–°æ„å»º: {new_version} ({key})")
                    return True
                
                return False
            except ValueError:
                log.warning(f"ç‰ˆæœ¬å·æ ¼å¼æ— æ³•è§£æ: {new_version} vs {current_ver}")
                # å¦‚æœæ— æ³•è§£æç‰ˆæœ¬å·ï¼ŒæŒ‰å­—ç¬¦ä¸²æ¯”è¾ƒ
                return new_version > current_ver or (new_version == current_ver and new_date > current_date)
        
        def download_file(cookies, file_info, save_path):
            """ä¸‹è½½å•ä¸ªæ–‡ä»¶"""
            fid = file_info["fid"]
            file_name = file_info["file_name"]
            file_key = file_info["key"]
            
            # è·å–ä¸‹è½½é“¾æ¥
            api_url = f"https://drive-pc.quark.cn/1/clouddrive/file/download?fid={fid}"
            headers = {
                "Referer": "https://pan.quark.cn/",
                "Origin": "https://pan.quark.cn"
            }
            
            response = requests.get(api_url, cookies=cookies, headers=headers, allow_redirects=False)
            
            if response.status_code == 302:
                encrypted_url = response.headers.get("Location", "")
            elif response.json().get("data"):
                encrypted_url = response.json().get("data")
            else:
                log.error(f"æ— æ³•è·å–ä¸‹è½½URL: {file_name}")
                return False
            
            # è§£å¯†ä¸‹è½½URL
            try:
                download_url = decrypt_download_url(encrypted_url, file_key)
            except Exception as e:
                log.error(f"è§£å¯†URLå¤±è´¥: {file_name} - {str(e)}")
                return False
            
            # åˆ›å»ºä¿å­˜ç›®å½•
            save_dir = os.path.dirname(save_path)
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            
            # ä¸‹è½½æ–‡ä»¶
            start_time = time.time()
            try:
                with requests.get(download_url, stream=True) as r:
                    r.raise_for_status()
                    with open(save_path, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            if chunk:
                                f.write(chunk)
            except Exception as e:
                log.error(f"ä¸‹è½½å¤±è´¥: {file_name} - {str(e)}")
                return False
            
            # éªŒè¯æ–‡ä»¶å¤§å°
            downloaded_size = os.path.getsize(save_path)
            if downloaded_size != file_info["size"]:
                log.error(f"æ–‡ä»¶å¤§å°ä¸åŒ¹é…: {file_name} ({downloaded_size} vs {file_info['size']})")
                os.remove(save_path)
                return False
            
            elapsed = time.time() - start_time
            size_mb = downloaded_size / (1024 * 1024)
            speed = size_mb / elapsed if elapsed > 0 else 0
            log.info(f"ä¸‹è½½å®Œæˆ: {file_name} - {size_mb:.2f} MB, è€—æ—¶: {elapsed:.1f}s, é€Ÿåº¦: {speed:.2f} MB/s")
            return True
        
        def main():
            log.info("="*50)
            log.info("å¯åŠ¨å¤¸å…‹ç½‘ç›˜APKåŒæ­¥ (å¢å¼ºç‰ˆ)")
            log.info("="*50)
            
            # æ£€æŸ¥ç¯å¢ƒå˜é‡
            if not os.environ.get("QUARK_CK"):
                log.error("ç¼ºå°‘QUARK_CKç¯å¢ƒå˜é‡")
                return 1
            
            # è®¾ç½®Git
            if not setup_git():
                return 2
            
            # åˆ›å»ºä¸´æ—¶ç›®å½•
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            # åŠ è½½ç‰ˆæœ¬æ–‡ä»¶ (ä¿æŠ¤ç°æœ‰å†…å®¹)
            current_versions = load_version_file()
            log.info("å½“å‰ç‰ˆæœ¬æ–‡ä»¶å†…å®¹:\n" + json.dumps(current_versions, indent=2))
            
            # è§£æCookie
            cookies = parse_cookies(os.environ["QUARK_CK"])
            
            # è·å–æ‰€æœ‰åˆ†äº«æ–‡ä»¶
            share_url = os.environ.get("SHARE_URL", "https://pan.quark.cn/s/6fead79bddaf")
            log.info(f"è·å–åˆ†äº«æ–‡ä»¶åˆ—è¡¨: {share_url}")
            files = get_all_share_files(share_url, cookies)
            
            if not files:
                log.error("æ— æ³•è·å–æ–‡ä»¶åˆ—è¡¨æˆ–åˆ—è¡¨ä¸ºç©º")
                return 3
            log.info(f"æ‰¾åˆ° {len(files)} ä¸ªæ–‡ä»¶")
            
            # æŸ¥æ‰¾æ ‡å‡†ç‰ˆæ–‡ä»¶
            log.info("æ‰«ææ ‡å‡†ç‰ˆæ–‡ä»¶...")
            std_files = find_files_by_template(files, STD_PATH_TEMPLATES)
            if not std_files:
                log.error("æœªæ‰¾åˆ°æ ‡å‡†ç‰ˆæ–‡ä»¶")
            else:
                log.info(f"æ ‡å‡†ç‰ˆå‘ç°: {len(std_files)} ä¸ªæ–‡ä»¶")
                for name, info in std_files.items():
                    log.info(f"  {name}: v{info['version']} (æ–‡ä»¶å: {info['file_name']})")
            
            # æŸ¥æ‰¾ä¸“ä¸šç‰ˆæ–‡ä»¶
            log.info("æ‰«æä¸“ä¸šç‰ˆæ–‡ä»¶...")
            pro_files = find_files_by_template(files, PRO_PATH_TEMPLATES)
            if not pro_files:
                log.error("æœªæ‰¾åˆ°ä¸“ä¸šç‰ˆæ–‡ä»¶")
            else:
                log.info(f"ä¸“ä¸šç‰ˆå‘ç°: {len(pro_files)} ä¸ªæ–‡ä»¶")
                for name, info in pro_files.items():
                    log.info(f"  {name}: v{info['version_num']} (æ–‡ä»¶å: {info['file_name']})")
            
            # å¤„ç†æ›´æ–°
            needs_update = False
            update_log = []
            
            # å¤„ç†æ ‡å‡†ç‰ˆ
            if std_files:
                # å‡è®¾æ ‡å‡†ç‰ˆçš„æ‰€æœ‰æ–‡ä»¶å…±äº«åŒä¸€ç‰ˆæœ¬å·å’Œæ—¶é—´æˆ³
                sample_file = next(iter(std_files.values()))
                
                # è·å–åŒ—äº¬æ—¶é—´
                dt = datetime.fromtimestamp(sample_file["timestamp"]/1000)
                dt_beijing = dt.astimezone(TZ_BEIJING)
                date_str = dt_beijing.strftime("%Y-%m-%d")
                
                log.info(f"æ ‡å‡†ç‰ˆç‰ˆæœ¬: {sample_file['version']}, å‘å¸ƒæ—¶é—´: {date_str}")
                
                for file_type, file_info in std_files.items():
                    key_name = f"std_{file_type}"
                    version_key = RENAME_MAP[key_name]
                    
                    if should_update(current_versions, key_name, file_info["version"], date_str):
                        # ä¸‹è½½æ–‡ä»¶
                        temp_path = os.path.join(WORK_DIR, file_info["file_name"])
                        if download_file(cookies, file_info, temp_path):
                            # ç§»åŠ¨å¹¶é‡å‘½åæ–‡ä»¶
                            final_path = os.path.join(APK_DIR, RENAME_MAP[key_name])
                            os.rename(temp_path, final_path)
                            
                            # æ›´æ–°ç‰ˆæœ¬è®°å½•
                            current_versions[version_key] = f"{file_info['version']},{date_str}"
                            update_log.append(f"{version_key} -> v{file_info['version']}")
                            needs_update = True
                        else:
                            log.error(f"ä¸‹è½½å¤±è´¥: {version_key}")
            else:
                log.warning("è·³è¿‡æ ‡å‡†ç‰ˆï¼Œæ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶")
            
            # å¤„ç†ä¸“ä¸šç‰ˆ
            if pro_files:
                # å‡è®¾ä¸“ä¸šç‰ˆçš„æ‰€æœ‰æ–‡ä»¶å…±äº«åŒä¸€ç‰ˆæœ¬å·å’Œæ—¶é—´æˆ³
                sample_file = next(iter(pro_files.values()))
                
                # è·å–åŒ—äº¬æ—¶é—´
                dt = datetime.fromtimestamp(sample_file["timestamp"]/1000)
                dt_beijing = dt.astimezone(TZ_BEIJING)
                date_str = dt_beijing.strftime("%Y-%m-%d")
                
                log.info(f"ä¸“ä¸šç‰ˆç‰ˆæœ¬: {sample_file['version_num']}, å‘å¸ƒæ—¶é—´: {date_str}")
                
                for file_type, file_info in pro_files.items():
                    key_name = f"pro_{file_type}"
                    version_key = RENAME_MAP[key_name]
                    
                    if should_update(current_versions, key_name, file_info["version_num"], date_str):
                        # ä¸‹è½½æ–‡ä»¶
                        temp_path = os.path.join(WORK_DIR, file_info["file_name"])
                        if download_file(cookies, file_info, temp_path):
                            # ç§»åŠ¨å¹¶é‡å‘½åæ–‡ä»¶
                            final_path = os.path.join(APK_DIR, RENAME_MAP[key_name])
                            os.rename(temp_path, final_path)
                            
                            # æ›´æ–°ç‰ˆæœ¬è®°å½•
                            current_versions[version_key] = f"{file_info['version_num']},{date_str}"
                            update_log.append(f"{version_key} -> v{file_info['version_num']}")
                            needs_update = True
                        else:
                            log.error(f"ä¸‹è½½å¤±è´¥: {version_key}")
            else:
                log.warning("è·³è¿‡ä¸“ä¸šç‰ˆï¼Œæ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶")
            
            # æ£€æŸ¥å¼ºåˆ¶æ–‡ä»¶å­˜åœ¨
            if not needs_update:
                log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
                
                # æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ–‡ä»¶éƒ½å­˜åœ¨
                for key in RENAME_MAP.values():
                    file_path = os.path.join(APK_DIR, key)
                    if not os.path.exists(file_path):
                        log.error(f"å…³é”®æ–‡ä»¶ç¼ºå¤±: {key}")
                        return 4
            
            # ä¿å­˜ç‰ˆæœ¬æ–‡ä»¶
            if needs_update:
                log.info("æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶")
                save_version_file(current_versions)
                
                # æäº¤æ›´æ”¹
                commit_msg = "æ›´æ–°APK: " + ", ".join(update_log)
                if commit_and_push(commit_msg):
                    log.info("åŒæ­¥æˆåŠŸï¼")
                    return 0
                else:
                    log.error("æäº¤å¤±è´¥")
                    return 5
            else:
                log.info("æ‰€æœ‰æ–‡ä»¶å‡ä¸ºæœ€æ–°ç‰ˆæœ¬")
                return 0
        
        if __name__ == "__main__":
            import subprocess
            import sys
            sys.exit(main())
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          const message = `ğŸš¨ Quarkç½‘ç›˜APKåŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          })

  cleanup:
    runs-on: ubuntu-latest
    needs: sync
    if: always()
    steps:
      - name: Clean up workspace
        run: |
          # åˆ é™¤ä¸´æ—¶å·¥ä½œç›®å½•
          rm -rf temp_apks
          
          # æ¸…é™¤æœªè·Ÿè¸ªçš„æ–‡ä»¶
          git clean -f -d
