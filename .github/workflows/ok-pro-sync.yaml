name: OK PRO APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # 每3小时运行一次
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install Android SDK for aapt2
      run: |
        # 安装Android SDK命令行工具
        SDK_TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-10406996_latest.zip"
        curl -sL "$SDK_TOOLS_URL" -o sdk-tools.zip
        unzip -q sdk-tools.zip -d android-sdk
        
        # 设置环境变量
        echo "ANDROID_SDK_ROOT=$GITHUB_WORKSPACE/android-sdk" >> $GITHUB_ENV
        echo "$GITHUB_WORKSPACE/android-sdk/cmdline-tools/bin" >> $GITHUB_PATH
        
        # 接受许可并安装build-tools
        yes | android-sdk/cmdline-tools/bin/sdkmanager --sdk_root=$GITHUB_WORKSPACE/android-sdk "build-tools;34.0.0"
        echo "aapt2路径: $GITHUB_WORKSPACE/android-sdk/build-tools/34.0.0/aapt2"
        
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip
        pip install telethon requests

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL || 'tvb_ys' }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        
        # 配置参数
        APK_FILES = ["leanback-pro.apk", "mobile-pro.apk"]
        APK_DIR = "apk"
        
        # 环境变量
        WORK_DIR = os.path.join(os.getcwd(), "temp_apks")
        GIT_DIR = os.getcwd()
        ANDROID_SDK_ROOT = os.environ.get('ANDROID_SDK_ROOT', '/usr/local/lib/android/sdk')
        AAPT2_PATH = f"{ANDROID_SDK_ROOT}/build-tools/34.0.0/aapt2"
        os.makedirs(WORK_DIR, exist_ok=True)
        
        def log(message):
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {message}")
        
        def format_size(size):
            """将字节数转换为易读的格式"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "pull", "origin", "main"], cwd=GIT_DIR, check=True)
                log("Git配置完成")
                return True
            except Exception as e:
                log(f"Git设置失败: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # 只添加apk目录和版本文件
                subprocess.run(["git", "add", APK_DIR, "version.txt"], cwd=GIT_DIR, check=True)
                
                # 检查是否有更改
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    log("没有更改需要提交")
                    return True
                
                # 提交更改
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                # 拉取远程最新更改并变基
                log("拉取远程最新更改并变基...")
                subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                
                # 推送更改
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                result = subprocess.run(
                    ["git", "push", repo_url, "HEAD:main"],
                    cwd=GIT_DIR,
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    log("推送成功")
                    return True
                else:
                    # 如果推送失败，尝试强制推送
                    log(f"推送失败，尝试强制推送: {result.stderr.strip()}")
                    force_result = subprocess.run(
                        ["git", "push", "--force", repo_url, "HEAD:main"],
                        cwd=GIT_DIR,
                        capture_output=True,
                        text=True
                    )
                    if force_result.returncode == 0:
                        log("强制推送成功")
                        return True
                    else:
                        log(f"强制推送失败: {force_result.stderr.strip()}")
                        return False
            except Exception as e:
                log(f"Git操作失败: {str(e)}")
                return False
        
        def get_current_versions():
            version_path = os.path.join(GIT_DIR, "version.txt")
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f)
                except:
                    log("版本文件格式错误，重新初始化")
            return {}
        
        def update_versions(versions):
            version_path = os.path.join(GIT_DIR, "version.txt")
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def extract_apk_version(apk_path):
            """使用aapt2从APK提取版本号"""
            try:
                log(f"从APK提取版本号: {apk_path}")
                result = subprocess.run(
                    [AAPT2_PATH, "dump", "badging", apk_path],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # 查找versionName
                for line in result.stdout.splitlines():
                    if "versionName" in line:
                        match = re.search(r"versionName='([^']*)'", line)
                        if match:
                            version = match.group(1)
                            # 确保版本号以"v"开头
                            if not version.startswith('v'):
                                version = 'v' + version
                            log(f"提取的版本号: {version}")
                            return version
                
                log(f"警告: 无法从 {apk_path} 提取版本号")
                return None
            except Exception as e:
                log(f"提取版本号失败: {str(e)}")
                return None
        
        async def download_apk(client, message, filename):
            download_path = os.path.join(WORK_DIR, filename)
            
            total_size = message.document.size
            log(f"开始下载: {filename} ({format_size(total_size)})")
            
            start_time = time.time()
            last_progress_time = start_time
            last_downloaded = 0
            
            def callback(current, total):
                nonlocal last_progress_time, last_downloaded
                current_time = time.time()
                
                # 每2秒或下载完成时更新一次进度
                if current_time - last_progress_time > 2 or current == total:
                    elapsed = current_time - start_time
                    percent = int((current / total) * 100)
                    speed = (current - last_downloaded) / (current_time - last_progress_time)
                    
                    # 更新日志
                    log(f"下载中: {filename} - {percent}% ({format_size(current)}/{format_size(total)}) "
                         f"[速度: {format_size(speed)}/s]")
                    
                    last_progress_time = current_time
                    last_downloaded = current
            
            await client.download_media(message, file=download_path, progress_callback=callback)
            
            # 下载完成后显示最终信息
            elapsed = time.time() - start_time
            avg_speed = total_size / elapsed if elapsed > 0 else 0
            log(f"下载完成: {filename} - 耗时: {elapsed:.1f}秒, 平均速度: {format_size(avg_speed)}/s")
            
            # 从APK提取版本号
            version = extract_apk_version(download_path)
            if not version:
                # 如果无法提取版本号，使用日期作为后备
                date_str = message.date.strftime("%Y%m%d")
                version = f"v{filename.split('.')[0]}-{date_str}"
                log(f"使用后备版本号: {version}")
            
            # ISO格式日期（YYYY-MM-DD）
            date_iso = message.date.strftime("%Y-%m-%d")
            
            return {
                "path": download_path,
                "version": version,
                "date_iso": date_iso
            }
        
        async def find_new_apks(client):
            log("连接Telegram...")
            await client.connect()
            if not await client.is_user_authorized():
                log("错误: Telegram会话无效")
                return None
            
            channel = os.environ.get('TELEGRAM_CHANNEL', 'tvb_ys')
            log(f"扫描频道: {channel}")
            entity = await client.get_entity(channel)
            
            latest_msgs = {}
            async for msg in client.iter_messages(entity, limit=50):
                if msg.media and hasattr(msg.media, "document"):
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            if filename in APK_FILES:
                                if filename not in latest_msgs or msg.id > latest_msgs[filename].id:
                                    latest_msgs[filename] = msg
            
            current_versions = get_current_versions()
            updates = {}
            
            for filename, msg in latest_msgs.items():
                # 处理当前版本值（可能是旧格式或新格式）
                current_value = current_versions.get(filename, "")
                if ',' in current_value:
                    # 如果是新格式 "版本号,日期"，则提取版本部分
                    current_version = current_value.split(',')[0]
                else:
                    current_version = current_value
                
                # 下载APK并提取版本号
                apk_data = await download_apk(client, msg, filename)
                if not apk_data:
                    continue
                
                # 检查是否有新版本
                if apk_data["version"] != current_version:
                    log(f"发现新版本: {filename} ({current_version} → {apk_data['version']})")
                    updates[filename] = apk_data
                else:
                    log(f"{filename} 已是最新版本: {current_version}")
            
            return updates if updates else None
        
        def main():
            log("="*50)
            log("APK 同步工具启动")
            log("="*50)
            
            # 验证环境变量
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log(f"错误: 缺少环境变量: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                with client:
                    new_apks = client.loop.run_until_complete(find_new_apks(client))
            except Exception as e:
                log(f"Telegram错误: {str(e)}")
                return 3
            
            if not new_apks:
                log("没有需要更新的APK文件")
                return 0
            
            # 处理新文件
            current_versions = get_current_versions()
            updated = {}
            target_dir = os.path.join(GIT_DIR, APK_DIR)
            os.makedirs(target_dir, exist_ok=True)
            
            for filename, data in new_apks.items():
                target_path = os.path.join(target_dir, filename)
                shutil.copy2(data["path"], target_path)
                
                # 更新版本信息为 "版本号,日期" 格式
                new_value = f"{data['version']},{data['date_iso']}"
                current_versions[filename] = new_value
                updated[filename] = new_value
                log(f"已更新: {filename} (版本: {new_value})")
            
            # 更新版本文件
            update_versions(current_versions)
            
            # 提交更改
            commit_msg = f"更新APK: {', '.join([f'{k}={v}' for k, v in updated.items()])}"
            if commit_and_push(commit_msg):
                log(f"同步成功! 更新了 {len(updated)} 个文件")
            else:
                log("提交失败")
                return 4
            
            # 清理临时目录
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
                log("临时目录已清理")
            
            log("="*50)
            log("同步任务完成")
            log("="*50)
            return 0
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Cleanup
      run: echo "APK同步任务完成"

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK PRO APK Sync from TELEGRAM"
          repository: ${{ github.repository }}