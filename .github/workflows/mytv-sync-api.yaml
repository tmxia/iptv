name: MYTV APK Sync from Source Repository

on:
  schedule:
    - cron: '0 */2 * * *'  # 每2小时运行一次
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Install dependencies
      run: sudo apt-get update && sudo apt-get install -y jq curl
        
    - name: Run APK sync
      env:
        SOURCE_REPO: "mytv-android/mytv-android"
        TARGET_REPO: "${{ github.repository }}"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
        APK_PATTERN: "armeabi-v7a-sdk21-original.apk"
        STABLE_KEY_NAME: "mytv-tv.apk"
        PRE_RELEASE_KEY_NAME: "mytv-tv-beta.apk"
      run: |
        set -euo pipefail
        WORK_DIR=$(mktemp -d)
        trap 'rm -rf "$WORK_DIR"' EXIT
        
        # 验证令牌权限
        curl -s -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_REPO" | grep -q '"id"' || \
          { echo "错误: 令牌无效"; exit 1; }
        
        # 获取源仓库发布信息 (增加错误处理)
        RESPONSE=$(curl -sL -w "\n%{http_code}" "https://api.github.com/repos/$SOURCE_REPO/releases")
        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        RELEASES_JSON=$(echo "$RESPONSE" | sed '$d')
        
        if [ "$HTTP_STATUS" != "200" ]; then
          echo "错误: 获取发布信息失败 (状态码 $HTTP_STATUS)"
          echo "响应内容: $RELEASES_JSON"
          exit 1
        fi
        
        # 检查是否为空数组
        if [ "$(echo "$RELEASES_JSON" | jq 'length')" -eq 0 ]; then
          echo "错误: 源仓库无发布版本"
          exit 1
        fi
        
        # 函数：规范化版本号
        normalize_version() {
          echo "$1" | sed -E 's/^V/v/; s/^([^v])/v\1/'
        }
        
        # 函数：获取发布信息
        get_release_info() {
          local release_json="$1"
          local version=$(jq -r '.tag_name' <<< "$release_json")
          local date_utc8=$(jq -r '.published_at' <<< "$release_json" | TZ=UTC date -d - +'%Y-%m-%d')
          echo "$(normalize_version "$version") $date_utc8"
        }
        
        # 获取稳定版信息 (增加空值检查)
        LATEST_STABLE=$(jq -r 'map(select(.prerelease == false)) | sort_by(.published_at) | reverse | .[0] // empty' <<< "$RELEASES_JSON")
        if [ -z "$LATEST_STABLE" ]; then
          echo "警告: 未找到稳定版"
          SYNC_STABLE=false
        else
          read STABLE_VERSION STABLE_DATE <<< $(get_release_info "$LATEST_STABLE")
          echo "源仓库稳定版: $STABLE_VERSION ($STABLE_DATE)"
          SYNC_STABLE=true
        fi
        
        # 获取预发行版信息 (增加空值检查)
        LATEST_PRE=$(jq -r 'map(select(.prerelease == true)) | sort_by(.published_at) | reverse | .[0] // empty' <<< "$RELEASES_JSON")
        if [ -z "$LATEST_PRE" ]; then
          echo "警告: 未找到预发行版"
          SYNC_PRE_RELEASE=false
        else
          read PRE_RELEASE_VERSION PRE_RELEASE_DATE <<< $(get_release_info "$LATEST_PRE")
          echo "源仓库预发行版: $PRE_RELEASE_VERSION ($PRE_RELEASE_DATE)"
          SYNC_PRE_RELEASE=true
        fi
        
        # 如果两个版本都不存在则退出
        if ! $SYNC_STABLE && ! $SYNC_PRE_RELEASE; then
          echo "错误: 未找到任何有效版本"
          exit 1
        fi
        
        # 获取目标版本文件
        VERSION_FILE_RESPONSE=$(curl -s -w "\n%{http_code}" -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
        VERSION_FILE_HTTP_STATUS=$(echo "$VERSION_FILE_RESPONSE" | tail -n1)
        VERSION_FILE_CONTENT=$(echo "$VERSION_FILE_RESPONSE" | sed '$d')
        
        # 解析当前版本文件
        if [ "$VERSION_FILE_HTTP_STATUS" -eq 200 ]; then
          echo "目标版本文件存在"
          CONTENT=$(echo "$VERSION_FILE_CONTENT" | jq -r '.content' | base64 -d)
          SHA_VERSION=$(echo "$VERSION_FILE_CONTENT" | jq -r '.sha // empty')
          
          # 解析为JSON对象
          if CURRENT_VERSION_JSON=$(echo "$CONTENT" | jq . 2>/dev/null); then
            echo "版本文件解析成功"
          else
            echo "警告: 版本文件格式无效，重置为JSON格式"
            CURRENT_VERSION_JSON="{}"
          fi
        else
          echo "目标仓库无版本文件，将创建新文件"
          CURRENT_VERSION_JSON="{}"
          SHA_VERSION=""
        fi
        
        # 提取当前版本信息
        CURRENT_STABLE=""
        CURRENT_STABLE_DATE=""
        if [ "$(echo "$CURRENT_VERSION_JSON" | jq -e ".\"$STABLE_KEY_NAME\"" 2>/dev/null)" != "null" ]; then
          CURRENT_STABLE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$STABLE_KEY_NAME\" // \"\"" | cut -d, -f1)
          CURRENT_STABLE_DATE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$STABLE_KEY_NAME\" // \"\"" | cut -d, -f2)
        fi
        
        CURRENT_PRE=""
        CURRENT_PRE_DATE=""
        if [ "$(echo "$CURRENT_VERSION_JSON" | jq -e ".\"$PRE_RELEASE_KEY_NAME\"" 2>/dev/null)" != "null" ]; then
          CURRENT_PRE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$PRE_RELEASE_KEY_NAME\" // \"\"" | cut -d, -f1)
          CURRENT_PRE_DATE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$PRE_RELEASE_KEY_NAME\" // \"\"" | cut -d, -f2)
        fi
        
        echo "目标稳定版: ${CURRENT_STABLE:-无} (${CURRENT_STABLE_DATE:-无日期})"
        echo "目标预发行版: ${CURRENT_PRE:-无} (${CURRENT_PRE_DATE:-无日期})"
        
        # 函数：检查目标文件存在性
        check_target_file_existence() {
          local key="$1"
          local target="apk/$key"
          
          local response=$(curl -s -w "\n%{http_code}" -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target")
          local http_code=$(echo "$response" | tail -n1)
          local content=$(echo "$response" | sed '$d')
          
          if [ "$http_code" -eq 200 ]; then
            echo "目标文件存在: $key"
            return 0
          else
            echo "目标文件不存在: $key (HTTP $http_code)"
            return 1
          fi
        }
        
        # 函数：下载APK
        download_apk() {
          local release_json="$1"
          local key="$2"
          local current_version="$3"
          
          # 检查目标文件是否存在
          if ! check_target_file_existence "$key"; then
            echo "目标文件不存在，需要下载: $key"
            NEED_DOWNLOAD=true
          else
            # 检查版本是否匹配
            local latest_version=$(normalize_version "$(jq -r '.tag_name' <<< "$release_json")")
            if [ "$latest_version" != "$current_version" ]; then
              echo "版本不匹配，需要更新: $key ($current_version → $latest_version)"
              NEED_DOWNLOAD=true
            else
              echo "目标文件存在且版本匹配，无需更新: $key"
              NEED_DOWNLOAD=false
            fi
          fi
          
          if $NEED_DOWNLOAD; then
            # 获取下载URL
            local url=$(jq -r '.assets[] | select(.name | contains("'"$APK_PATTERN"'")) | .browser_download_url' <<< "$release_json" | head -1)
            if [ -z "$url" ]; then
              echo "错误: 未找到匹配的APK文件"
              return 1
            fi
            
            echo "下载: $(basename "$url")"
            curl -sL "$url" -o "$WORK_DIR/$key"
            return 0
          fi
          return 1
        }
        
        # 处理稳定版
        STABLE_NEED_UPDATE=false
        if $SYNC_STABLE && download_apk "$LATEST_STABLE" "$STABLE_KEY_NAME" "$CURRENT_STABLE"; then
          STABLE_NEED_UPDATE=true
          NEW_STABLE_VERSION="$STABLE_VERSION"
          NEW_STABLE_DATE="$STABLE_DATE"
        else
          NEW_STABLE_VERSION="$CURRENT_STABLE"
          NEW_STABLE_DATE="$CURRENT_STABLE_DATE"
        fi
        
        # 处理预发行版
        PRE_NEED_UPDATE=false
        if $SYNC_PRE_RELEASE && download_apk "$LATEST_PRE" "$PRE_RELEASE_KEY_NAME" "$CURRENT_PRE"; then
          PRE_NEED_UPDATE=true
          NEW_PRE_VERSION="$PRE_RELEASE_VERSION"
          NEW_PRE_DATE="$PRE_RELEASE_DATE"
        else
          NEW_PRE_VERSION="$CURRENT_PRE"
          NEW_PRE_DATE="$CURRENT_PRE_DATE"
        fi
        
        # 函数：上传APK（优化大文件处理）
        upload_apk() {
          local key="$1"
          local version="$2"
          local target="apk/$key"
          
          echo "准备上传: $key ($version)"
          
          # 获取当前文件的SHA（如果存在）
          local sha=""
          local response=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target")
          if [ "$(echo "$response" | jq -r '.message')" != "Not Found" ]; then
            sha=$(echo "$response" | jq -r '.sha // empty')
          fi
          
          # 生成临时文件避免命令行过长
          local json_file=$(mktemp)
          local content_file=$(mktemp)
          
          # 将APK内容base64编码后写入文件
          base64 -w0 "$WORK_DIR/$key" > "$content_file"
          
          # 构建JSON数据到临时文件
          jq -n \
            --arg msg "更新APK: $key ($version)" \
            --rawfile content "$content_file" \
            --arg sha "$sha" \
            '{message: $msg, content: $content, sha: $sha}' > "$json_file"
          
          # 捕获上传响应和状态码
          local upload_response=$(curl -s -w "\n%{http_code}" -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            --data-binary "@$json_file" \
            "https://api.github.com/repos/$TARGET_REPO/contents/$target")
          
          # 清理临时文件
          rm -f "$json_file" "$content_file"
          
          local http_code=$(echo "$upload_response" | tail -n1)
          if [ "$http_code" -ne 200 ] && [ "$http_code" -ne 201 ]; then
            echo "错误: 上传APK失败 - HTTP状态码 $http_code"
            echo "响应详情: $(echo "$upload_response" | sed '$d')"
            return 1
          fi
          echo "上传成功: $key"
          return 0
        }
        
        # 上传需要更新的APK（先于版本文件更新）
        UPLOAD_ERROR=false
        if $STABLE_NEED_UPDATE; then
          if ! upload_apk "$STABLE_KEY_NAME" "$NEW_STABLE_VERSION"; then
            UPLOAD_ERROR=true
          fi
        fi
        
        if $PRE_NEED_UPDATE; then
          if ! upload_apk "$PRE_RELEASE_KEY_NAME" "$NEW_PRE_VERSION"; then
            UPLOAD_ERROR=true
          fi
        fi
        
        if [ "$UPLOAD_ERROR" = true ]; then
          echo "错误: APK上传失败，跳过版本文件更新"
          exit 1
        fi
        
        # 更新版本数据 (保留所有现有键)
        UPDATED_VERSION_JSON=$(echo "$CURRENT_VERSION_JSON" | jq \
          --arg stable_key "$STABLE_KEY_NAME" \
          --arg stable_value "$NEW_STABLE_VERSION,$NEW_STABLE_DATE" \
          --arg pre_key "$PRE_RELEASE_KEY_NAME" \
          --arg pre_value "$NEW_PRE_VERSION,$NEW_PRE_DATE" \
          '.[$stable_key] = $stable_value | .[$pre_key] = $pre_value')
        
        # 检查版本内容是否有变化
        CURRENT_CONTENT_FOR_COMPARE=$(echo "$CURRENT_VERSION_JSON" | jq -S .)
        NEW_CONTENT_FOR_COMPARE=$(echo "$UPDATED_VERSION_JSON" | jq -S .)
        
        if [ "$CURRENT_CONTENT_FOR_COMPARE" = "$NEW_CONTENT_FOR_COMPARE" ]; then
          echo "版本文件内容无变化，跳过更新"
        else
          echo "更新版本文件内容"
          ENCODED_CONTENT=$(echo -n "$UPDATED_VERSION_JSON" | base64 -w0)
          
          # 上传版本文件（优化大文件处理）
          local version_json_file=$(mktemp)
          jq -n \
            --arg msg "更新版本文件" \
            --arg content "$ENCODED_CONTENT" \
            --arg sha "$SHA_VERSION" \
            '{message: $msg, content: $content, sha: $sha}' > "$version_json_file"
          
          response=$(curl -s -w "\n%{http_code}" -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            --data-binary "@$version_json_file" \
            "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
          
          rm -f "$version_json_file"
          
          http_code=$(echo "$response" | tail -n1)
          if [ "$http_code" -ne 200 ] && [ "$http_code" -ne 201 ]; then
            echo "错误: 版本文件更新失败 - HTTP状态码 $http_code"
            echo "响应详情: $(echo "$response" | sed '$d')"
            exit 1
          fi
          echo "版本文件更新成功"
        fi
        
        # 输出结果
        echo "同步完成!"
        $SYNC_STABLE && echo "稳定版: $NEW_STABLE_VERSION ($NEW_STABLE_DATE)"
        $SYNC_PRE_RELEASE && echo "预发行版: $NEW_PRE_VERSION ($NEW_PRE_DATE)"
        exit 0

  cleanup_self:
    name: Cleanup Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "MYTV APK Sync from Source Repository"
          repository: ${{ github.repository }}