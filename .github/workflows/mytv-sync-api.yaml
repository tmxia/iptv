name: MYTV APK Sync from Source Repository

on:
  schedule:
    - cron: '0 */2 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Install dependencies
      run: sudo apt-get update && sudo apt-get install -y jq curl
        
    - name: Run APK sync
      env:
        SOURCE_REPO: "mytv-android/mytv-android"
        TARGET_REPO: "${{ github.repository }}"
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
        APK_PATTERN: "armeabi-v7a-sdk21-original.apk"
        STABLE_KEY_NAME: "mytv-tv.apk"
        PRE_RELEASE_KEY_NAME: "mytv-tv-beta.apk"
      run: |
        set -e
        WORK_DIR=$(mktemp -d)
        
        # 获取源仓库发布信息
        RELEASES_JSON=$(curl -sL "https://api.github.com/repos/$SOURCE_REPO/releases")
        
        # 获取稳定版信息
        LATEST_STABLE=$(jq -r 'map(select(.prerelease == false)) | sort_by(.published_at) | reverse | .[0] // empty' <<< "$RELEASES_JSON")
        if [ -n "$LATEST_STABLE" ]; then
          STABLE_VERSION=$(jq -r '.tag_name' <<< "$LATEST_STABLE")
          STABLE_DATE=$(jq -r '.published_at' <<< "$LATEST_STABLE" | TZ=UTC date +'%Y-%m-%d')
          SYNC_STABLE=true
        else
          SYNC_STABLE=false
        fi
        
        # 获取预发行版信息
        LATEST_PRE=$(jq -r 'map(select(.prerelease == true)) | sort_by(.published_at) | reverse | .[0] // empty' <<< "$RELEASES_JSON")
        if [ -n "$LATEST_PRE" ]; then
          PRE_RELEASE_VERSION=$(jq -r '.tag_name' <<< "$LATEST_PRE")
          PRE_RELEASE_DATE=$(jq -r '.published_at' <<< "$LATEST_PRE" | TZ=UTC date +'%Y-%m-%d')
          SYNC_PRE_RELEASE=true
        else
          SYNC_PRE_RELEASE=false
        fi
        
        # 获取目标版本文件
        VERSION_FILE=$(curl -s -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt")
        
        # 解析当前版本文件
        if [ "$(jq -r '.message' <<< "$VERSION_FILE")" != "Not Found" ]; then
          CONTENT=$(jq -r '.content' <<< "$VERSION_FILE" | base64 -d)
          CURRENT_VERSION_JSON=$(echo "$CONTENT" | jq . 2>/dev/null || echo "{}")
        else
          CURRENT_VERSION_JSON="{}"
        fi
        
        # 提取当前版本信息
        CURRENT_STABLE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$STABLE_KEY_NAME\" // \"\"" | cut -d, -f1)
        CURRENT_PRE=$(echo "$CURRENT_VERSION_JSON" | jq -r ".\"$PRE_RELEASE_KEY_NAME\" // \"\"" | cut -d, -f1)
        
        # 函数：下载APK
        download_apk() {
          local release_json="$1"
          local key="$2"
          local current_version="$3"
          
          local latest_version=$(jq -r '.tag_name' <<< "$release_json")
          local status_code=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/apk/$key")
          
          if [ "$status_code" != "200" ] || [ "$latest_version" != "$current_version" ]; then
            local url=$(jq -r '.assets[] | select(.name | contains("'"$APK_PATTERN"'")) | .browser_download_url' <<< "$release_json" | head -1)
            curl -sL "$url" -o "$WORK_DIR/$key"
            return 0
          fi
          return 1
        }
        
        # 处理稳定版
        STABLE_NEED_UPDATE=false
        if $SYNC_STABLE && download_apk "$LATEST_STABLE" "$STABLE_KEY_NAME" "$CURRENT_STABLE"; then
          STABLE_NEED_UPDATE=true
        fi
        
        # 处理预发行版
        PRE_NEED_UPDATE=false
        if $SYNC_PRE_RELEASE && download_apk "$LATEST_PRE" "$PRE_RELEASE_KEY_NAME" "$CURRENT_PRE"; then
          PRE_NEED_UPDATE=true
        fi
        
        # 更新版本数据
        UPDATED_VERSION_JSON=$(echo "$CURRENT_VERSION_JSON" | jq \
          --arg stable_key "$STABLE_KEY_NAME" \
          --arg stable_value "$STABLE_VERSION,$STABLE_DATE" \
          --arg pre_key "$PRE_RELEASE_KEY_NAME" \
          --arg pre_value "$PRE_RELEASE_VERSION,$PRE_RELEASE_DATE" \
          '.[$stable_key] = $stable_value | .[$pre_key] = $pre_value')
        
        # 上传版本文件
        SHA_VERSION=$(jq -r '.sha // empty' <<< "$VERSION_FILE")
        ENCODED_CONTENT=$(echo -n "$UPDATED_VERSION_JSON" | base64 -w0)
        
        curl -s -X PUT \
          -H "Authorization: token $TOKEN" \
          -H "Content-Type: application/json" \
          -d "$(jq -n \
            --arg msg "更新版本文件" \
            --arg content "$ENCODED_CONTENT" \
            --arg sha "$SHA_VERSION" \
            '{message: $msg, content: $content, sha: $sha}')" \
          "https://api.github.com/repos/$TARGET_REPO/contents/version.txt" > /dev/null
        
        # 函数：上传APK
        upload_apk() {
          local key="$1"
          local sha=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$TARGET_REPO/contents/apk/$key" | jq -r '.sha // empty')
          
          curl -s -X PUT \
            -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
              --arg msg "更新APK: $key" \
              --arg content "$(base64 -w0 "$WORK_DIR/$key")" \
              --arg sha "$sha" \
              '{message: $msg, content: $content, sha: $sha}')" \
            "https://api.github.com/repos/$TARGET_REPO/contents/apk/$key" > /dev/null
        }
        
        # 上传需要更新的APK
        $STABLE_NEED_UPDATE && upload_apk "$STABLE_KEY_NAME"
        $PRE_NEED_UPDATE && upload_apk "$PRE_RELEASE_KEY_NAME"
        
        rm -rf "$WORK_DIR"
        exit 0

  cleanup_self:
    name: Cleanup Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: always()
    steps:
      - name: Delete old runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "MYTV APK Sync from Source Repository"
          repository: ${{ github.repository }}