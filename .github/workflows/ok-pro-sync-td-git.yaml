name: OK APK Sync from ThunderDrive

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */3 * * *'  # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          python3-pip
        pip install requests pycryptodome
        
    - name: Run Thunder Drive Sync
      env:
        THUNDER_USER: ${{ secrets.THUNDER_USER }}
        THUNDER_PASSWORD: ${{ secrets.THUNDER_PASSWORD }}
        SHARE_URL: https://pan.xunlei.com/s/VOOlHjZarK69yZ7BxcLd1WrsA1
        SHARE_PASSWORD: ckit  # åˆ†äº«å¯†ç 
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import re
        import time
        import requests
        import hashlib
        import logging
        import subprocess
        import sys
        import random
        from Crypto.Cipher import AES
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s][%(levelname)-8s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger("thunder_sync")
        log.setLevel(logging.INFO)
        
        # é…ç½®å‚æ•°
        WORK_DIR = "temp_apks"
        APK_DIR = "apk"
        
        # æ–‡ä»¶åŒ¹é…è§„åˆ™ - æŒ‰éœ€ä¿®æ”¹
        FILE_PATTERNS = {
            "leanback": r"leanback.*\.apk",
            "mobile": r"mobile.*\.apk",
            "pro_leanback": r"leanback-pro.*\.apk",
            "pro_mobile": r"mobile-pro.*\.apk"
        }
        
        # ç›®æ ‡æ–‡ä»¶å
        TARGET_FILES = {
            "leanback": "leanback.apk",
            "mobile": "mobile.apk",
            "pro_leanback": "leanback-pro.apk",
            "pro_mobile": "mobile-pro.apk"
        }
        
        def setup_git():
            try:
                log.info(">>> é…ç½®Gitç¯å¢ƒ")
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = f"{actor}@users.noreply.github.com"
                
                subprocess.run(["git", "config", "user.name", actor], check=True)
                subprocess.run(["git", "config", "user.email", email], check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹é˜²æ­¢å†²çª
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
                
                log.info("Gité…ç½®å®Œæˆ")
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                log.info(f">>> å‡†å¤‡æäº¤æ›´æ–°: {message}")
                subprocess.run(["git", "add", APK_DIR, "version.txt"], check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(
                    ["git", "status", "--porcelain"], 
                    capture_output=True, 
                    text=True,
                    check=True
                )
                
                if not status.stdout.strip():
                    log.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                    return True
                
                subprocess.run(["git", "commit", "-m", message], check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
                subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                log.info("âœ… æ¨é€æˆåŠŸ")
                return True
            except Exception as e:
                log.error(f"Gitæäº¤å¤±è´¥: {str(e)}")
                return False
        
        def load_version_file():
            version_path = "version.txt"
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        return json.load(f)
                except:
                    return {}
            return {}
        
        def save_version_file(versions):
            with open("version.txt", "w") as f:
                json.dump(versions, f, indent=2)
        
        def thunder_login(username, password):
            """æ¨¡æ‹Ÿè¿…é›·è´¦å·ç™»å½•ï¼Œè·å–Cookie"""
            try:
                log.info("ğŸ” æ­£åœ¨ç™»å½•è¿…é›·è´¦å·...")
                
                # è·å–ç™»å½•åŠ å¯†å¯†é’¥
                key_url = "https://login.xunlei.com/risk"
                headers = {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
                    "Referer": "https://pan.xunlei.com/"
                }
                key_res = requests.get(key_url, headers=headers)
                key_data = key_res.json()
                public_key = key_data["publickey"]
                seq = key_data["seq"]
                
                # åŠ å¯†å¯†ç 
                cipher = AES.new(public_key.encode('utf-8'), AES.MODE_ECB)
                padded_password = password + (16 - len(password) % 16) * '\0'
                encrypted_pwd = cipher.encrypt(padded_password.encode('utf-8'))
                encrypted_pwd = encrypted_pwd.hex().upper()
                
                # æ„é€ ç™»å½•è¯·æ±‚
                login_url = "https://login.xunlei.com/sec2login/"
                login_data = {
                    "userid": username,
                    "pwd": encrypted_pwd,
                    "rsa_pwd": "",  # ç•™ç©ºä½¿ç”¨AESåŠ å¯†ç»“æœ
                    "login_enable": "0",
                    "business_type": "113",
                    "vcode": "",
                    "seq": seq,
                    "session_type": "simple",
                    "captcha_code": ""
                }
                
                # å‘é€ç™»å½•è¯·æ±‚
                session = requests.Session()
                response = session.post(login_url, data=login_data, headers=headers)
                
                if response.status_code != 200:
                    log.error(f"ç™»å½•å¤±è´¥: HTTP {response.status_code}")
                    return None
                
                # æ£€æŸ¥ç™»å½•ç»“æœ
                login_result = response.json()
                if login_result.get("message") != "success":
                    log.error(f"ç™»å½•å¤±è´¥: {login_result.get('message')}")
                    return None
                
                # æå–Cookies
                cookies = "; ".join([f"{name}={value}" for name, value in session.cookies.items()])
                log.info("âœ… ç™»å½•æˆåŠŸï¼Œè·å–åˆ°Cookie")
                return cookies
                
            except Exception as e:
                log.error(f"ç™»å½•è¿‡ç¨‹ä¸­å‡ºé”™: {str(e)}")
                return None
        
        def decrypt_download_link(encrypted_url):
            """è§£å¯†è¿…é›·ä¸‹è½½é“¾æ¥ï¼ˆå¦‚æœéœ€è¦ï¼‰"""
            # é€šå¸¸è¿…é›·çš„ä¸‹è½½é“¾æ¥ä¸éœ€è¦è§£å¯†ï¼Œä½†å¦‚æœåŠ å¯†å¯ä»¥åœ¨è¿™é‡Œå¤„ç†
            return encrypted_url
        
        def get_share_file_list(share_url, share_password, cookies):
            """è·å–åˆ†äº«é“¾æ¥ä¸‹çš„æ–‡ä»¶åˆ—è¡¨"""
            log.info(f"è·å–åˆ†äº«æ–‡ä»¶åˆ—è¡¨: {share_url}")
            
            # è§£æåˆ†äº«ID
            share_id = ""
            if "/s/" in share_url:
                share_id = share_url.split("/s/")[-1].split("/")[0]
                share_id = share_id.split("?")[0]
            
            if not share_id:
                log.error("åˆ†äº«é“¾æ¥æ ¼å¼é”™è¯¯")
                return []
            
            # å‡†å¤‡è¯·æ±‚å¤´
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
                "Cookie": cookies,
                "Referer": "https://pan.xunlei.com/"
            }
            
            # æ„é€ APIå‚æ•°
            params = {
                "s": share_id,
                "pwd": share_password,
                "t": str(int(time.time() * 1000)),
                "sign": hashlib.md5(f"{share_id}{share_password}".encode()).hexdigest()[:16]
            }
            
            api_url = "https://pan.xunlei.com/api/share/download"
            
            try:
                response = requests.post(api_url, headers=headers, data=params, timeout=30)
                response.raise_for_status()
                data = response.json()
                
                if data.get("status") != "success":
                    log.error(f"è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥: {data.get('msg')}")
                    return []
                
                # æå–æ–‡ä»¶ä¿¡æ¯
                files = []
                for file in data["data"]:
                    download_url = decrypt_download_link(file["download_url"])
                    if not download_url:
                        log.warning(f"æ— æ³•è§£æä¸‹è½½é“¾æ¥: {file['name']}")
                        continue
                        
                    files.append({
                        "name": file["name"],
                        "size": file["size"],
                        "download_url": download_url,
                        "sha1": file["hash"]
                    })
                
                log.info(f"è·å–åˆ° {len(files)} ä¸ªæ–‡ä»¶")
                return files
            except Exception as e:
                log.error(f"è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥: {str(e)}")
                return []
        
        def download_file(file_info, save_path, cookies):
            """ä¸‹è½½æ–‡ä»¶"""
            file_name = file_info["name"]
            file_url = file_info["download_url"]
            file_size = file_info["size"]
            
            log.info(f"å¼€å§‹ä¸‹è½½: {file_name} ({file_size/1024/1024:.2f} MB)")
            
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
                "Cookie": cookies,
                "Referer": "https://pan.xunlei.com/"
            }
            
            try:
                # ä¸‹è½½æ–‡ä»¶
                response = requests.get(file_url, headers=headers, stream=True, timeout=300)
                response.raise_for_status()
                
                # åˆ›å»ºä¿å­˜ç›®å½•
                os.makedirs(os.path.dirname(save_path), exist_ok=True)
                
                # å†™å…¥æ–‡ä»¶
                with open(save_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)
                
                # éªŒè¯æ–‡ä»¶å¤§å°
                downloaded_size = os.path.getsize(save_path)
                if file_size > 0 and downloaded_size != file_size:
                    log.error(f"æ–‡ä»¶å¤§å°ä¸åŒ¹é…: {downloaded_size} vs {file_size}")
                    return False
                
                log.info(f"âœ… ä¸‹è½½å®Œæˆ: {file_name}")
                return True
            except Exception as e:
                log.error(f"ä¸‹è½½å¤±è´¥: {file_name} - {str(e)}")
                return False
        
        def find_matching_files(files):
            """åŒ¹é…æ‰€éœ€æ–‡ä»¶"""
            matched = {}
            
            for key, pattern in FILE_PATTERNS.items():
                regex = re.compile(pattern, re.IGNORECASE)
                for file_info in files:
                    if regex.search(file_info["name"]):
                        # è·å–æ–‡ä»¶SHA1ä½œä¸ºç‰ˆæœ¬æ ‡è¯†
                        file_version = file_info["sha1"]
                        
                        # è®°å½•æ–‡ä»¶ä¿¡æ¯
                        if key not in matched:
                            matched[key] = {
                                "file_info": file_info,
                                "version": file_version
                            }
                        break
            
            return matched
        
        def main():
            log.info("ğŸš€ å¯åŠ¨è¿…é›·ç½‘ç›˜APKåŒæ­¥")
            
            # è®¾ç½®Git
            if not setup_git():
                return 1
                
            # åˆ›å»ºç›®å½•
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            # åŠ è½½ç‰ˆæœ¬æ–‡ä»¶
            current_versions = load_version_file()
            
            # è·å–ç¯å¢ƒå˜é‡
            username = os.environ.get("THUNDER_USER")
            password = os.environ.get("THUNDER_PASSWORD")
            share_url = os.environ.get("SHARE_URL")
            share_password = os.environ.get("SHARE_PASSWORD", "")
            
            if not username or not password:
                log.error("ç¼ºå°‘è¿…é›·è´¦å·æˆ–å¯†ç ")
                return 2
                
            # ç™»å½•è·å–Cookie
            cookies = thunder_login(username, password)
            if not cookies:
                log.error("æ— æ³•è·å–è¿…é›·Cookie")
                return 3
                
            # è·å–æ–‡ä»¶åˆ—è¡¨
            files = get_share_file_list(share_url, share_password, cookies)
            
            if not files:
                log.error("æ— æ³•è·å–æ–‡ä»¶åˆ—è¡¨")
                return 4
                
            # åŒ¹é…æ‰€éœ€æ–‡ä»¶
            matched_files = find_matching_files(files)
            
            # å¤„ç†æ›´æ–°
            needs_update = False
            update_log = []
            
            for key, match in matched_files.items():
                target_name = TARGET_FILES[key]
                target_path = os.path.join(APK_DIR, target_name)
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                if key in current_versions:
                    if current_versions[key]["version"] == match["version"]:
                        log.info(f"â†ªï¸ è·³è¿‡ {target_name} (ç‰ˆæœ¬ç›¸åŒ)")
                        continue
                
                # ä¸‹è½½æ–‡ä»¶
                temp_path = os.path.join(WORK_DIR, match["file_info"]["name"])
                if download_file(match["file_info"], temp_path, cookies):
                    # ç§»åŠ¨æ–‡ä»¶
                    if os.path.exists(target_path):
                        os.remove(target_path)
                    os.rename(temp_path, target_path)
                    
                    # æ›´æ–°ç‰ˆæœ¬è®°å½•
                    current_versions[key] = {
                        "version": match["version"],
                        "timestamp": int(time.time())
                    }
                    update_log.append(target_name)
                    needs_update = True
            
            # å¦‚æœæœ‰æ›´æ–°ï¼Œæäº¤æ›´æ”¹
            if needs_update:
                log.info("ğŸ’¾ ä¿å­˜ç‰ˆæœ¬æ–‡ä»¶")
                save_version_file(current_versions)
                
                if commit_and_push("æ›´æ–°APK: " + ", ".join(update_log)):
                    log.info("âœ… åŒæ­¥æˆåŠŸ!")
                    return 0
                else:
                    log.error("âŒ æäº¤å¤±è´¥")
                    return 5
            else:
                log.info("âœ… æ‰€æœ‰æ–‡ä»¶å‡ä¸ºæœ€æ–°ç‰ˆæœ¬")
                return 0
        
        if __name__ == "__main__":
            try:
                exit_code = main()
                log.info(f"ğŸ å·¥ä½œæµç»“æŸ (ä»£ç : {exit_code})")
                sys.exit(exit_code)
            except Exception as e:
                log.error(f"æœªæ•è·çš„å¼‚å¸¸: {str(e)}")
                sys.exit(99)
        EOF
        
    - name: Upload logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: sync-logs
        path: thunder_sync.log

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  cleanup:
    runs-on: ubuntu-latest
    needs: sync
    if: always()
    steps:
      - name: Clean up workspace
        run: |
          # åˆ é™¤ä¸´æ—¶å·¥ä½œç›®å½•
          rm -rf temp_apks
          # æ¸…é™¤æœªè·Ÿè¸ªæ–‡ä»¶
          git clean -f -d
          # ä¿ç•™æ—¥å¿—æ–‡ä»¶
          rm -f thunder_sync.log
