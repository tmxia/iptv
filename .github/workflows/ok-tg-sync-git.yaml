name: OK APK Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v3
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        fetch-depth: 1

    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get install -y jq
        pip install telethon requests pytz

    - name: Run APK Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        APK_FILES = ["leanback.apk", "mobile.apk"]
        APK_DIR = "apk"
        WORK_DIR = "temp_apks"
        VERSION_FILE = "version.txt"
        
        # å•ä¸ªTelegramé¢‘é“
        TELEGRAM_CHANNEL = "tvboxjk"
        
        # è®¾ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        logger = logging.getLogger()
        
        def format_size(size):
            """å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºæ˜“è¯»çš„æ ¼å¼"""
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f}{unit}"
                size /= 1024.0
            return f"{size:.1f}GB"
        
        def git_setup():
            """é…ç½®Gitç”¨æˆ·ä¿¡æ¯"""
            actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
            email = f"{actor}@users.noreply.github.com"
            
            subprocess.run(["git", "config", "user.name", actor], check=True)
            subprocess.run(["git", "config", "user.email", email], check=True)
            logger.info("Gité…ç½®å®Œæˆ")
            
            # æ‹‰å–æœ€æ–°æ›´æ”¹
            logger.info("æ‹‰å–è¿œç¨‹æœ€æ–°æ›´æ”¹...")
            subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
            return True
        
        def git_commit_push_with_retry(message, max_retries=3):
            """æäº¤å¹¶æ¨é€æ›´æ”¹ï¼Œå¸¦é‡è¯•æœºåˆ¶"""
            for attempt in range(max_retries):
                try:
                    # æ¸…ç†æœªè·Ÿè¸ªæ–‡ä»¶
                    subprocess.run(["git", "clean", "-fd"], check=True)
                    
                    # å…ˆæ·»åŠ æ–‡ä»¶
                    subprocess.run(["git", "add", APK_DIR, VERSION_FILE], check=True)
                    
                    # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                    status = subprocess.run(
                        ["git", "status", "--porcelain"],
                        capture_output=True, text=True, check=True
                    )
                    if not status.stdout.strip():
                        logger.info("æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤")
                        return True
                    
                    logger.info(f"ç¬¬ {attempt + 1} æ¬¡å°è¯•æäº¤ï¼Œæ£€æŸ¥åˆ°ä»¥ä¸‹æ›´æ”¹:")
                    logger.info(status.stdout)
                    
                    # æäº¤æ›´æ”¹
                    subprocess.run(["git", "commit", "-m", message], check=True)
                    logger.info("æäº¤æˆåŠŸ")
                    
                    # ä½¿ç”¨Tokenæ¨é€
                    token = os.environ['GITHUB_TOKEN']
                    repo_url = f"https://x-access-token:{token}@github.com/{os.environ['GITHUB_REPOSITORY']}.git"
                    
                    # ä½¿ç”¨å¼ºåˆ¶æ¨é€ï¼Œä½†å…ˆæ‹‰å–æœ€æ–°æ›´æ”¹
                    logger.info("æ‹‰å–æœ€æ–°è¿œç¨‹æ›´æ”¹...")
                    subprocess.run(["git", "pull", "--rebase", repo_url, "main"], check=True)
                    
                    logger.info("æ¨é€æ›´æ”¹åˆ°è¿œç¨‹...")
                    subprocess.run(["git", "push", repo_url, "HEAD:main"], check=True)
                    logger.info("æ¨é€æˆåŠŸ")
                    return True
                    
                except subprocess.CalledProcessError as e:
                    logger.error(f"ç¬¬ {attempt + 1} æ¬¡å°è¯•å¤±è´¥: {e}")
                    if attempt < max_retries - 1:
                        wait_time = (attempt + 1) * 10  # é€’å¢ç­‰å¾…æ—¶é—´
                        logger.info(f"{wait_time}ç§’åé‡è¯•...")
                        time.sleep(wait_time)
                        
                        # é‡ç½®çŠ¶æ€
                        subprocess.run(["git", "reset", "--hard", "HEAD"], check=True)
                        subprocess.run(["git", "clean", "-fd"], check=True)
                        subprocess.run(["git", "pull", "origin", "main", "--rebase"], check=True)
                    else:
                        logger.error("æ‰€æœ‰é‡è¯•å°è¯•å‡å¤±è´¥")
                        return False
                except Exception as e:
                    logger.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                    if attempt < max_retries - 1:
                        wait_time = (attempt + 1) * 10
                        logger.info(f"{wait_time}ç§’åé‡è¯•...")
                        time.sleep(wait_time)
                    else:
                        return False
            return False
        
        def get_versions():
            """è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯å¹¶éªŒè¯é”®å€¼ç»“æ„"""
            if not os.path.exists(VERSION_FILE):
                return {}
            
            try:
                with open(VERSION_FILE, "r") as f:
                    versions = json.load(f)
                    # éªŒè¯æ˜¯å¦ä¸ºå­—å…¸æ ¼å¼
                    if not isinstance(versions, dict):
                        logger.warning("ç‰ˆæœ¬æ–‡ä»¶æ ¼å¼æ— æ•ˆï¼Œé‡ç½®ä¸ºç©ºå­—å…¸")
                        return {}
                    return versions
            except Exception as e:
                logger.error(f"ç‰ˆæœ¬æ–‡ä»¶è¯»å–å¤±è´¥: {str(e)}")
                return {}
        
        def update_versions(new_versions):
            """æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶"""
            versions = get_versions()
            versions.update(new_versions)
            
            with open(VERSION_FILE, "w") as f:
                json.dump(versions, f, indent=2)
                logger.info("ç‰ˆæœ¬æ–‡ä»¶å·²æ›´æ–°")
                
                # ä»…æ˜¾ç¤ºå…³å¿ƒçš„é”®å€¼ç‰ˆæœ¬ä¿¡æ¯
                for apk, ver in new_versions.items():
                    logger.info(f"ç‰ˆæœ¬æ›´æ–°: {apk} => {ver}")
        
        def extract_version_from_filename(filename):
            """ä»æ–‡ä»¶åä¸­æå–ç‰ˆæœ¬å· - é€‚é…OKæ–‡ä»¶åæ ¼å¼"""
            # é€‚é…OKæ–‡ä»¶åæ ¼å¼ï¼šOKç”µè§†ç‰ˆï¼¿3.1.5(32ä½ï¼‰.apk
            match = re.search(r'OK(?:ç”µè§†ç‰ˆ|æ‰‹æœºç‰ˆ)[ï¼¿_]?(\d+\.\d+\.\d+)', filename)
            if match:
                version = match.group(1)
                if version and re.match(r'^\d+(\.\d+)*$', version):
                    return f"v{version}"
            
            # å¤‡ç”¨åŒ¹é…ï¼šé€šç”¨ç‰ˆæœ¬å·æ¨¡å¼
            match = re.search(r'([\d.]+)\.apk$', filename)
            if match:
                version = match.group(1)
                if version and re.match(r'^\d+(\.\d+)*$', version):
                    return f"v{version}"
            return None
        
        def map_filename(original_name):
            """æ–‡ä»¶åæ˜ å°„å‡½æ•° - é€‚é…OKæ–‡ä»¶åæ ¼å¼å¹¶æ’é™¤ç‰¹å®šç‰ˆæœ¬"""
            # æ’é™¤ç‰¹å®šç‰ˆæœ¬ï¼šX5å†…æ ¸å’Œæµ·ä¿¡ç‰ˆæœ¬
            exclude_patterns = ["X5å†…æ ¸", "æµ·ä¿¡"]
            for pattern in exclude_patterns:
                if pattern in original_name:
                    logger.info(f"æ’é™¤ç‰¹å®šç‰ˆæœ¬: {original_name} (åŒ…å« {pattern})")
                    return None
            
            # OKæ–‡ä»¶ååŒ¹é…è§„åˆ™
            if "OKç”µè§†ç‰ˆ" in original_name and "32ä½" in original_name:
                return "leanback.apk"
            elif "OKæ‰‹æœºç‰ˆ" in original_name and "64ä½" in original_name:
                return "mobile.apk"
            
            return None
        
        def compare_versions(current_version, new_version_info):
            """æ¯”è¾ƒç‰ˆæœ¬ä¿¡æ¯ï¼Œå†³å®šæ˜¯å¦éœ€è¦æ›´æ–°"""
            if not current_version:
                logger.info("å½“å‰æ— ç‰ˆæœ¬è®°å½•ï¼Œéœ€è¦æ›´æ–°")
                return True
            
            try:
                # è§£æå½“å‰ç‰ˆæœ¬ä¿¡æ¯
                current_parts = current_version.split(',')
                current_ver = current_parts[0] if len(current_parts) > 0 else ""
                current_date = current_parts[1] if len(current_parts) > 1 else ""
                
                new_ver = new_version_info['version']
                new_date = new_version_info['date']
                
                logger.info(f"ç‰ˆæœ¬æ¯”è¾ƒ: {current_ver} ({current_date}) vs {new_ver} ({new_date})")
                
                # é¦–å…ˆæ¯”è¾ƒç‰ˆæœ¬å·
                if current_ver and new_ver:
                    # æå–çº¯æ•°å­—ç‰ˆæœ¬è¿›è¡Œæ¯”è¾ƒ
                    current_num = re.findall(r'\d+', current_ver)
                    new_num = re.findall(r'\d+', new_ver)
                    
                    if current_num and new_num:
                        # é€çº§æ¯”è¾ƒç‰ˆæœ¬å·
                        for i in range(min(len(current_num), len(new_num))):
                            if int(new_num[i]) > int(current_num[i]):
                                logger.info(f"ç‰ˆæœ¬å·æ›´æ–°: {current_ver} -> {new_ver}")
                                return True
                            elif int(new_num[i]) < int(current_num[i]):
                                logger.info(f"ç‰ˆæœ¬å·è¾ƒæ—§: {current_ver} -> {new_ver}")
                                return False
                        # å¦‚æœå‰å‡ ä½ç›¸åŒï¼Œé•¿åº¦æ›´é•¿çš„ç‰ˆæœ¬å·æ›´æ–°
                        if len(new_num) > len(current_num):
                            logger.info(f"ç‰ˆæœ¬å·æ›´è¯¦ç»†: {current_ver} -> {new_ver}")
                            return True
                
                # ç‰ˆæœ¬å·ç›¸åŒï¼Œæ¯”è¾ƒæ—¥æœŸ
                if current_date and new_date:
                    if new_date > current_date:
                        logger.info(f"ç›¸åŒç‰ˆæœ¬ä½†æ—¥æœŸæ›´æ–°: {current_date} -> {new_date}")
                        return True
                    elif new_date < current_date:
                        logger.info(f"ç›¸åŒç‰ˆæœ¬ä½†æ—¥æœŸè¾ƒæ—§: {current_date} -> {new_date}")
                        return False
                
                # å®Œå…¨ç›¸åŒçš„ç‰ˆæœ¬
                logger.info(f"ç‰ˆæœ¬ç›¸åŒï¼Œæ— éœ€æ›´æ–°: {current_version}")
                return False
                
            except Exception as e:
                logger.error(f"ç‰ˆæœ¬æ¯”è¾ƒå‡ºé”™: {str(e)}")
                # å‡ºé”™æ—¶ä¿å®ˆç­–ç•¥ï¼Œä¸æ›´æ–°
                return False
        
        async def download_apk(client, message, target_filename, original_filename):
            """ä¸‹è½½APKæ–‡ä»¶å¹¶æå–å…ƒæ•°æ®"""
            download_path = os.path.join(WORK_DIR, target_filename)
            total_size = message.document.size
            logger.info(f"å¼€å§‹ä¸‹è½½: {original_filename} -> {target_filename} ({format_size(total_size)})")
            
            start_time = time.time()
            await client.download_media(message, file=download_path)
            
            elapsed = time.time() - start_time
            logger.info(f"ä¸‹è½½å®Œæˆ: è€—æ—¶{elapsed:.1f}ç§’")
            
            # éªŒè¯æ–‡ä»¶æ˜¯å¦æˆåŠŸä¸‹è½½
            if not os.path.exists(download_path):
                raise FileNotFoundError(f"æ–‡ä»¶ä¸‹è½½å¤±è´¥: {download_path}")
            
            # ä»æ–‡ä»¶åä¸­æå–ç‰ˆæœ¬å·
            version = extract_version_from_filename(original_filename)
            if version:
                logger.info(f"ä½¿ç”¨æ–‡ä»¶åç‰ˆæœ¬å·: {version}")
            else:
                # å¦‚æœæ— æ³•ä»æ–‡ä»¶åæå–ç‰ˆæœ¬å·ï¼Œä½¿ç”¨åå¤‡æ–¹æ¡ˆ
                version = f"v{target_filename.split('.')[0]}-{message.date.strftime('%Y%m%d')}"
                logger.info(f"ä½¿ç”¨åå¤‡ç‰ˆæœ¬å·: {version}")
            
            return {
                "path": download_path,
                "version": version,
                "date": message.date.strftime("%Y-%m-%d")
            }
        
        async def check_channel(client, current_versions):
            """æ£€æŸ¥Telegramé¢‘é“ä¸­çš„æ–°APK"""
            logger.info(f"è¿æ¥Telegramé¢‘é“: {TELEGRAM_CHANNEL}")
            entity = await client.get_entity(TELEGRAM_CHANNEL)
            
            updates = {}
            processed_targets = set()
            
            # æ‰«ææ¶ˆæ¯
            message_candidates = []
            
            async for msg in client.iter_messages(entity, limit=50):
                if not (msg.media and hasattr(msg.media, "document")):
                    continue
                    
                for attr in msg.media.document.attributes:
                    if not isinstance(attr, DocumentAttributeFilename):
                        continue
                        
                    original_name = attr.file_name
                    target_name = map_filename(original_name)
                    
                    if not target_name:
                        continue
                    
                    # é¿å…é‡å¤å¤„ç†åŒä¸€ç›®æ ‡æ–‡ä»¶
                    if target_name in processed_targets:
                        continue
                    processed_targets.add(target_name)
                    
                    # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸‹è½½
                    current_version = current_versions.get(target_name, "")
                    msg_date = msg.date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                    
                    # æ„å»ºæ–°ç‰ˆæœ¬ä¿¡æ¯
                    file_version = extract_version_from_filename(original_name)
                    if not file_version:
                        file_version = f"v{target_name.split('.')[0]}-{msg_date.replace('-', '')}"
                    
                    new_version_info = {
                        "version": file_version,
                        "date": msg_date
                    }
                    
                    # ä¸å½“å‰ç‰ˆæœ¬å¯¹æ¯”
                    if compare_versions(current_version, new_version_info):
                        message_candidates.append((msg, target_name, original_name, new_version_info))
                        logger.info(f"éœ€è¦æ›´æ–°: {target_name} (å½“å‰: {current_version}, æ–°: {file_version},{msg_date})")
                    else:
                        logger.info(f"è·³è¿‡æ›´æ–°: {target_name} (å½“å‰ç‰ˆæœ¬å·²æ˜¯æœ€æ–°)")
            
            # æŒ‰æ—¶é—´å€’åºå¤„ç†å€™é€‰æ¶ˆæ¯
            message_candidates.sort(key=lambda x: x[0].date, reverse=True)
            
            # å¤„ç†å€™é€‰æ¶ˆæ¯
            for msg, target_name, original_name, version_info in message_candidates:
                try:
                    apk_data = await download_apk(client, msg, target_name, original_name)
                    new_value = f"{version_info['version']},{version_info['date']}"
                    
                    # æœ€ç»ˆéªŒè¯ï¼šç¡®ä¿ä¸‹è½½çš„æ–‡ä»¶ç¡®å®æ¯”å½“å‰æ–‡ä»¶æ–°
                    current_value = current_versions.get(target_name, "")
                    if current_value == new_value:
                        logger.warning(f"ç‰ˆæœ¬æœªå˜åŒ–ï¼Œåˆ é™¤ä¸´æ—¶æ–‡ä»¶: {target_name}")
                        os.remove(apk_data['path'])  # åˆ é™¤ä¸´æ—¶æ–‡ä»¶
                    else:
                        updates[target_name] = new_value
                        logger.info(f"ç¡®è®¤æ›´æ–°: {target_name} (å½“å‰: {current_value} â†’ æ–°: {new_value})")
                        processed_targets.add(target_name)
                except Exception as e:
                    logger.error(f"ä¸‹è½½å¤±è´¥: {original_name} -> {target_name}, é”™è¯¯: {str(e)}")
            
            return updates
        
        async def main_async():
            """å¼‚æ­¥ä¸»å‡½æ•°"""
            logger.info("="*50 + "\nOK APK åŒæ­¥å·¥å…·å¯åŠ¨\n" + "="*50)
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION']
            if missing := [var for var in required if not os.environ.get(var)]:
                raise ValueError(f"ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
            
            git_setup()
            # ç¡®ä¿æ¸…ç†ä¸´æ—¶ç›®å½•
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            os.makedirs(WORK_DIR, exist_ok=True)
            os.makedirs(APK_DIR, exist_ok=True)
            
            # è·å–å½“å‰ç‰ˆæœ¬
            current_versions = get_versions()
            logger.info(f"å½“å‰ç‰ˆæœ¬ä¿¡æ¯: {current_versions}")
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            async with client:
                logger.info(f"å¼€å§‹æ£€æŸ¥é¢‘é“: {TELEGRAM_CHANNEL}")
                updates = await check_channel(client, current_versions)
                logger.info(f"é¢‘é“æ£€æŸ¥å®Œæˆï¼Œæ›´æ–°: {len(updates)} ä¸ªAPK")
            
            if updates:
                logger.info(f"å‘ç° {len(updates)} ä¸ªAPKéœ€è¦æ›´æ–°")
                
                # å¤åˆ¶APKæ–‡ä»¶åˆ°ä»“åº“
                for apk in updates.keys():
                    src = os.path.join(WORK_DIR, apk)
                    if not os.path.exists(src):
                        logger.error(f"æºæ–‡ä»¶ä¸å­˜åœ¨: {src}")
                        raise FileNotFoundError(f"APKæ–‡ä»¶æœªæˆåŠŸä¸‹è½½: {apk}")
                    
                    dst = os.path.join(APK_DIR, apk)
                    shutil.copy2(src, dst)
                    logger.info(f"å·²å¤åˆ¶: {apk} åˆ° {dst}")
                
                # æ›´æ–°ç‰ˆæœ¬æ–‡ä»¶
                update_versions(updates)
                
                # æäº¤æ›´æ”¹
                commit_msg = f"æ›´æ–°OK APK: {', '.join(updates.keys())}"
                if not git_commit_push_with_retry(commit_msg):
                    # å¦‚æœæ¨é€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä½†ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œé¿å…å·¥ä½œæµå®Œå…¨å¤±è´¥
                    logger.error("Gitæ¨é€å¤±è´¥ï¼Œä½†å·¥ä½œæµå°†ç»§ç»­å®Œæˆ")
                else:
                    logger.info("æ‰€æœ‰æ›´æ–°å·²æˆåŠŸæäº¤")
            else:
                logger.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„APKæ–‡ä»¶")
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            logger.info("æ¸…ç†ä¸´æ—¶ç›®å½•...")
            shutil.rmtree(WORK_DIR, ignore_errors=True)
            
            logger.info("="*50 + "\nOK APK åŒæ­¥ä»»åŠ¡å®Œæˆ\n" + "="*50)
            return 0
        
        if __name__ == "__main__":
            try:
                from asyncio import run
                run(main_async())
            except Exception as e:
                logging.error(f"ä¸¥é‡é”™è¯¯: {str(e)}")
                sys.exit(1)
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2.0.6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OK APK Sync from TELEGRAM"
          repository: ${{ github.repository }}
