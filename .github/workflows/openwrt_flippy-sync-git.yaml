name: OpenWrt Kernel Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 18 * * 1' # å‘¨ä¸€å‡Œæ™¨2ç‚¹ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰  
    - cron: '0 11 * * 1' # å‘¨ä¸€ä¸‹åˆ7ç‚¹ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200  # 20åˆ†é’Ÿè¶…æ—¶
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip zip
        pip install telethon requests pytz

    - name: Run Kernel Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "openwrt_flippy"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import time
        import re
        import logging
        import zipfile
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        KERNEL_GROUPS = {
            "openwrt_flippy6.1": [
                r"dtb-rockchip-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-amlogic-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.1\..*-flippy-\d+\+.*\.tar\.gz"
            ],
            "openwrt_flippy6.6": [
                r"dtb-rockchip-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-amlogic-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.6\..*-flippy-\d+\+.*\.tar\.gz"
            ],
            "openwrt_flippy6.12": [
                r"dtb-amlogic-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-rockchip-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.12\..*-flippy-\d+\+.*\.tar\.gz"
            ]
        }
        REQUIRED_FILE_COUNT = 6
        
        KERNEL_DIR = "kernels"
        KERNEL_VERSION_FILE = "kernel_versions.json"
        
        # ç¯å¢ƒå˜é‡
        WORK_DIR = os.path.join(os.getcwd(), "temp_kernels")
        GIT_DIR = os.getcwd()
        os.makedirs(WORK_DIR, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        def setup_git():
            try:
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                email = os.environ.get('GITHUB_EMAIL', f'{actor}@users.noreply.github.com')
                
                subprocess.run(["git", "config", "user.name", actor], cwd=GIT_DIR, check=True)
                subprocess.run(["git", "config", "user.email", email], cwd=GIT_DIR, check=True)
                
                # æ‹‰å–æœ€æ–°æ›´æ”¹
                subprocess.run(["git", "pull", "origin", "main", "--rebase"], cwd=GIT_DIR, check=True)
                return True
            except Exception as e:
                log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                return False
        
        def commit_and_push(message):
            try:
                # æ·»åŠ å†…æ ¸ç›®å½•å’Œç‰ˆæœ¬æ–‡ä»¶
                subprocess.run(["git", "add", KERNEL_DIR, KERNEL_VERSION_FILE], cwd=GIT_DIR, check=True)
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                status = subprocess.run(["git", "status", "--porcelain"], cwd=GIT_DIR, capture_output=True, text=True)
                if not status.stdout.strip():
                    return True
                
                # æäº¤æ›´æ”¹
                subprocess.run(["git", "commit", "-m", message], cwd=GIT_DIR, check=True)
                
                token = os.environ['GITHUB_TOKEN']
                actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                repo = os.environ['TARGET_REPO']
                repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                
                # é‡è¯•æœºåˆ¶
                max_attempts = 3
                for attempt in range(1, max_attempts + 1):
                    try:
                        subprocess.run(["git", "pull", "--rebase", "origin", "main"], cwd=GIT_DIR, check=True)
                        subprocess.run(
                            ["git", "push", repo_url, "HEAD:main"],
                            cwd=GIT_DIR,
                            check=True
                        )
                        return True
                    except subprocess.CalledProcessError:
                        if attempt < max_attempts:
                            time.sleep(10)
                        else:
                            log.error(f"æ¨é€æ›´æ”¹å¤±è´¥")
                            return False
            except Exception as e:
                log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                return False
        
        def get_kernel_versions():
            """è·å–å†…æ ¸ç‰ˆæœ¬ä¿¡æ¯ï¼Œç¡®ä¿åŒ…å«æ‰€æœ‰ç»„"""
            version_path = os.path.join(GIT_DIR, KERNEL_VERSION_FILE)
            default_versions = {group: {"version": "", "date": ""} for group in KERNEL_GROUPS}
            
            if os.path.exists(version_path):
                try:
                    with open(version_path, "r") as f:
                        versions = json.load(f)
                        # ç¡®ä¿æ‰€æœ‰ç»„éƒ½å­˜åœ¨
                        for group in KERNEL_GROUPS:
                            if group not in versions:
                                versions[group] = {"version": "", "date": ""}
                        return versions
                except:
                    return default_versions
            return default_versions
        
        def save_kernel_versions(versions):
            version_path = os.path.join(GIT_DIR, KERNEL_VERSION_FILE)
            with open(version_path, "w") as f:
                json.dump(versions, f, indent=2)
        
        def pattern_match(filename, pattern):
            return re.match(pattern, filename) is not None
        
        def find_matching_group(filename):
            for group, patterns in KERNEL_GROUPS.items():
                for pattern in patterns:
                    if pattern_match(filename, pattern):
                        return group
            return None
        
        def extract_version_from_filename(filename):
            # æ‰©å±•ç‰ˆæœ¬åŒ¹é…æ¨¡å¼ï¼Œæ”¯æŒ6.6.93-flippy-93+æ ¼å¼
            match = re.search(r'(\d+\.\d+\.\d+-flippy-\d+\+[a-z]*)', filename)
            if not match:
                # å°è¯•åŒ¹é…æ²¡æœ‰åç¼€å­—æ¯çš„ç‰ˆæœ¬ï¼ˆå¦‚6.6.93-flippy-93+ï¼‰
                match = re.search(r'(\d+\.\d+\.\d+-flippy-\d+\+)', filename)
            return match.group(1) if match else None
        
        async def download_file(client, message, filename, download_path):
            await client.download_media(message, file=download_path)
            return True
        
        def get_latest_date(messages):
            latest_date = None
            for msg in messages:
                if latest_date is None or msg.date > latest_date:
                    latest_date = msg.date
            return latest_date
        
        async def process_group(client, group_name, version, files_to_download, group_dir):
            # è·å–ç»„å†…æ‰€æœ‰æ¶ˆæ¯çš„æœ€æ–°æ—¥æœŸ
            all_messages = [msg for _, msg in files_to_download]
            latest_date = get_latest_date(all_messages)
            
            # è½¬æ¢ä¸ºUTC+8æ—¶åŒº
            utc8 = pytz.timezone('Asia/Shanghai')
            date_utc8 = latest_date.astimezone(utc8).strftime("%Y-%m-%d")
            
            os.makedirs(group_dir, exist_ok=True)
            
            # ä¸‹è½½ç»„å†…æ‰€æœ‰æ–‡ä»¶
            for filename, msg in files_to_download:
                download_path = os.path.join(group_dir, filename)
                await download_file(client, msg, filename, download_path)
            
            # åˆ›å»ºZIPæ–‡ä»¶
            zip_filename = f"{group_name}_{version}.zip"
            zip_path = os.path.join(WORK_DIR, zip_filename)
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                for root, _, files in os.walk(group_dir):
                    for file in files:
                        file_path = os.path.join(root, file)
                        zipf.write(file_path, os.path.basename(file_path))
            
            return zip_path, date_utc8
        
        async def find_new_kernels(client, kernel_versions):
            log.info("è¿æ¥Telegramé¢‘é“")
            try:
                await client.connect()
                if not await client.is_user_authorized():
                    log.error("Telegramä¼šè¯æ— æ•ˆ")
                    return None
                
                channel = os.environ.get('TELEGRAM_CHANNEL', 'openwrt_flippy')
                entity = await client.get_entity(channel)
                
                updates = {}
                
                # å­˜å‚¨æ‰¾åˆ°çš„æ–‡ä»¶
                found_groups = {group: {} for group in KERNEL_GROUPS.keys()}
                
                # è·å–é¢‘é“ä¸­æœ€æ–°çš„50æ¡æ¶ˆæ¯
                async for msg in client.iter_messages(entity, limit=50):
                    if msg.media and hasattr(msg.media, "document"):
                        for attr in msg.media.document.attributes:
                            if isinstance(attr, DocumentAttributeFilename):
                                filename = attr.file_name
                                group = find_matching_group(filename)
                                if group:
                                    version = extract_version_from_filename(filename)
                                    if not version:
                                        continue
                                    
                                    if version not in found_groups[group]:
                                        found_groups[group][version] = {}
                                    
                                    found_groups[group][version][filename] = msg
                
                # æ£€æŸ¥æ¯ä¸ªç»„çš„å®Œæ•´æ€§
                for group, versions in found_groups.items():
                    if not versions:
                        continue
                        
                    sorted_versions = sorted(versions.keys(), reverse=True)
                    for version in sorted_versions:
                        files = versions[version]
                        
                        # æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰å¿…éœ€çš„æ–‡ä»¶
                        required_patterns = KERNEL_GROUPS[group]
                        matched_files = {}
                        
                        for pattern in required_patterns:
                            for filename in files.keys():
                                if pattern_match(filename, pattern):
                                    matched_files[pattern] = filename
                                    break
                        
                        if len(matched_files) == REQUIRED_FILE_COUNT:
                            log.info(f"å‘ç°å®Œæ•´å†…æ ¸ç»„: {group}@{version}")
                            
                            # è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
                            current_version = kernel_versions.get(group, {}).get("version", "")
                            current_date = kernel_versions.get(group, {}).get("date", "")
                            
                            # è·å–ç»„å†…æ‰€æœ‰æ¶ˆæ¯çš„æœ€æ–°æ—¥æœŸ
                            all_messages = list(files.values())
                            latest_date = get_latest_date(all_messages)
                            
                            # è½¬æ¢ä¸ºæ—¥æœŸå­—ç¬¦ä¸²
                            utc8 = pytz.timezone('Asia/Shanghai')
                            date_utc8 = latest_date.astimezone(utc8).strftime("%Y-%m-%d")
                            
                            # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                            version_updated = False
                            if not current_version:
                                version_updated = True
                                log.info(f"é¦–æ¬¡æ·»åŠ æ–°å†…æ ¸ç»„: {group}")
                            elif version != current_version:
                                version_updated = True
                                log.info(f"å‘ç°æ–°ç‰ˆæœ¬: {version} (å½“å‰: {current_version})")
                            elif date_utc8 > current_date:
                                version_updated = True
                                log.info(f"ç›¸åŒç‰ˆæœ¬ä½†æ›´æ–°æ—¥æœŸ: {date_utc8} > {current_date}")
                            
                            if version_updated:
                                try:
                                    files_to_download = [(filename, msg) for filename, msg in files.items()]
                                    group_dir = os.path.join(WORK_DIR, f"group_{group}_{version}")
                                    
                                    zip_path, zip_date = await process_group(client, group, version, files_to_download, group_dir)
                                    updates[group] = {
                                        "version": version,
                                        "date": zip_date,
                                        "zip_path": zip_path
                                    }
                                except Exception as e:
                                    log.error(f"å¤„ç†{group}æ—¶å‡ºé”™: {str(e)}")
                            
                            # åªå¤„ç†æœ€æ–°ç‰ˆæœ¬
                            break
                
                return updates if updates else None
            finally:
                # ç¡®ä¿è¿æ¥å…³é—­
                await client.disconnect()
        
        def delete_old_kernel_versions(group, current_version):
            target_dir = os.path.join(GIT_DIR, KERNEL_DIR)
            if not os.path.exists(target_dir):
                return []
            
            # æŸ¥æ‰¾æ‰€æœ‰åŒç»„æ–‡ä»¶
            group_files = []
            for filename in os.listdir(target_dir):
                if filename.startswith(f"{group}_") and filename.endswith(".zip"):
                    group_files.append(filename)
            
            if not group_files:
                return []
            
            # åˆ é™¤æ—§ç‰ˆæœ¬æ–‡ä»¶
            deleted = []
            for filename in group_files:
                if current_version in filename:
                    continue
                
                file_path = os.path.join(target_dir, filename)
                os.remove(file_path)
                deleted.append(filename)
            
            return deleted
        
        def main():
            log.info("OpenWrt å†…æ ¸åŒæ­¥å·¥å…·å¯åŠ¨")
            
            # éªŒè¯ç¯å¢ƒå˜é‡
            required = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
            missing = [var for var in required if not os.environ.get(var)]
            if missing:
                log.error(f"ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                return 1
            
            if not setup_git():
                return 2
            
            # è·å–å†…æ ¸ç‰ˆæœ¬ä¿¡æ¯
            kernel_versions = get_kernel_versions()
            
            client = TelegramClient(
                StringSession(os.environ['TELEGRAM_SESSION']),
                int(os.environ['TELEGRAM_API_ID']),
                os.environ['TELEGRAM_API_HASH']
            )
            
            try:
                # ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨ç¡®ä¿è¿æ¥æ­£ç¡®å…³é—­
                with client:
                    new_kernels = client.loop.run_until_complete(
                        find_new_kernels(client, kernel_versions))
            except Exception as e:
                log.error(f"Telegramæ“ä½œé”™è¯¯: {str(e)}")
                return 3
            
            updated = False
            deleted_count = 0
            
            if new_kernels:
                target_dir = os.path.join(GIT_DIR, KERNEL_DIR)
                os.makedirs(target_dir, exist_ok=True)
                
                for group, data in new_kernels.items():
                    try:
                        # å¤åˆ¶ZIPæ–‡ä»¶åˆ°ä»“åº“
                        target_path = os.path.join(target_dir, os.path.basename(data["zip_path"]))
                        shutil.copy2(data["zip_path"], target_path)
                        
                        # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                        kernel_versions[group] = {
                            "version": data["version"],
                            "date": data["date"]
                        }
                        log.info(f"å·²æ›´æ–°: {group}@{data['version']}")
                        
                        # åˆ é™¤æ—§ç‰ˆæœ¬
                        deleted = delete_old_kernel_versions(group, data["version"])
                        deleted_count += len(deleted)
                        
                        updated = True
                    except Exception as e:
                        log.error(f"æ›´æ–°{group}æ—¶å‡ºé”™: {str(e)}")
                
                if updated:
                    # ä¿å­˜å†…æ ¸ç‰ˆæœ¬ä¿¡æ¯
                    save_kernel_versions(kernel_versions)
                    
                    # ç”Ÿæˆæäº¤ä¿¡æ¯
                    group_versions = []
                    for group, data in new_kernels.items():
                        group_versions.append(f"{group}@{data['version']}")
                    
                    commit_msg = f"æ›´æ–°OpenWrtå†…æ ¸: {', '.join(group_versions)}"
                    if deleted_count:
                        commit_msg += f"\nåˆ é™¤ {deleted_count} ä¸ªæ—§ç‰ˆæœ¬"
                    
                    if commit_and_push(commit_msg):
                        log.info(f"åŒæ­¥æˆåŠŸ! æ›´æ–° {len(new_kernels)} ç»„, åˆ é™¤ {deleted_count} æ—§ç‰ˆæœ¬")
                    else:
                        log.error("æäº¤å¤±è´¥")
                        return 4
                else:
                    log.info("æ‰€æœ‰æ›´æ–°å°è¯•å¤±è´¥")
            else:
                log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„å†…æ ¸æ–‡ä»¶")
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if os.path.exists(WORK_DIR):
                shutil.rmtree(WORK_DIR)
            
            log.info("åŒæ­¥ä»»åŠ¡å®Œæˆ")
            return 0
        
        if __name__ == "__main__":
            sys.exit(main())
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            const issue_number = context.issue.number;
            if (issue_number) {
              await github.rest.issues.createComment({
                issue_number: issue_number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `å·¥ä½œæµå¤±è´¥é€šçŸ¥ - ${{ github.workflow }} #${{ github.run_number }}`,
                body: `ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            }
          } catch (error) {
            core.error(`ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼è¯¦æƒ…è¯·æŸ¥çœ‹è¿è¡Œ: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`);
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 0
          retain_days: 0
          delete_workflow_pattern: "OpenWrt Kernel Sync from TELEGRAM"
          repository: ${{ github.repository }}