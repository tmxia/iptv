name: OpenWrt Kernel Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 18 * * 1' # å‘¨ä¸€å‡Œæ™¨2ç‚¹ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰
    - cron: '0 11 * * 1' # å‘¨ä¸€ä¸‹åˆ7ç‚¹ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock ğŸ”’
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update > /dev/null
        sudo apt-get install -y jq curl unzip zip > /dev/null
        pip install telethon requests pytz > /dev/null

    - name: Run Kernel Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "openwrt_flippy"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import re
        import logging
        import zipfile
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # é…ç½®å‚æ•°
        KERNEL_GROUPS = {
            "openwrt_flippy6.1": [
                r"dtb-rockchip-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-amlogic-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.1\..*-flippy-\d+\+.*\.tar\.gz"
            ],
            "openwrt_flippy6.6": [
                r"dtb-rockchip-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-amlogic-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.6\..*-flippy-\d+\+.*\.tar\.gz"
            ],
            "openwrt_flippy6.12": [
                r"dtb-amlogic-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-rockchip-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.12\..*-flippy-\d+\+.*\.tar\.gz"
            ]
        }
        REQUIRED_FILE_COUNT = 6
        
        KERNEL_DIR = "kernels"
        KERNEL_VERSION_FILE = "kernel_versions.json"
        WORK_DIR = "temp_kernels"
        
        # æ—¥å¿—é…ç½®
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        class KernelSyncer:
            def __init__(self):
                self.git_dir = os.getcwd()
                self.work_dir = os.path.join(self.git_dir, WORK_DIR)
                self.kernel_dir = os.path.join(self.git_dir, KERNEL_DIR)
                self.version_file = os.path.join(self.git_dir, KERNEL_VERSION_FILE)
                self.versions = self.load_versions()
                
            def load_versions(self):
                """åŠ è½½ç‰ˆæœ¬æ–‡ä»¶ï¼Œç¡®ä¿åŒ…å«æ‰€æœ‰ç»„"""
                if os.path.exists(self.version_file):
                    try:
                        with open(self.version_file, "r") as f:
                            versions = json.load(f)
                    except:
                        versions = {}
                else:
                    versions = {}
                
                # ç¡®ä¿æ‰€æœ‰ç»„éƒ½å­˜åœ¨
                for group in KERNEL_GROUPS:
                    if group not in versions:
                        versions[group] = {"version": "", "date": ""}
                return versions
            
            def save_versions(self):
                """ä¿å­˜ç‰ˆæœ¬æ–‡ä»¶ï¼Œä¿ç•™å…¶ä»–ç»„ä¿¡æ¯"""
                with open(self.version_file, "w") as f:
                    json.dump(self.versions, f, indent=2)
            
            def setup_git(self):
                """é…ç½®Gitç”¨æˆ·ä¿¡æ¯å¹¶æ‹‰å–æœ€æ–°ä»£ç """
                try:
                    actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                    email = f'{actor}@users.noreply.github.com'
                    
                    subprocess.run(["git", "config", "user.name", actor], 
                                   cwd=self.git_dir, check=True, 
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    subprocess.run(["git", "config", "user.email", email], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    
                    # æ‹‰å–æœ€æ–°æ›´æ”¹
                    subprocess.run(["git", "pull", "origin", "main", "--rebase"], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    return True
                except Exception as e:
                    log.error(f"Gitè®¾ç½®å¤±è´¥: {str(e)}")
                    return False
            
            def commit_and_push(self, message):
                """æäº¤æ›´æ”¹å¹¶æ¨é€åˆ°ä»“åº“"""
                try:
                    # æ·»åŠ æ›´æ”¹
                    subprocess.run(["git", "add", KERNEL_DIR, KERNEL_VERSION_FILE], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    
                    # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
                    status = subprocess.run(["git", "status", "--porcelain"], 
                                            cwd=self.git_dir, capture_output=True, text=True)
                    if not status.stdout.strip():
                        log.info("æ— æ›´æ”¹éœ€è¦æäº¤")
                        return True
                    
                    # æäº¤æ›´æ”¹
                    subprocess.run(["git", "commit", "-m", message], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    
                    # æ¨é€æ›´æ”¹
                    token = os.environ['GITHUB_TOKEN']
                    actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                    repo = os.environ['TARGET_REPO']
                    repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                    
                    subprocess.run(["git", "pull", "--rebase", "origin", "main"], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    subprocess.run(["git", "push", repo_url, "HEAD:main"], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    return True
                except Exception as e:
                    log.error(f"Gitæ“ä½œå¤±è´¥: {str(e)}")
                    return False
            
            def pattern_match(self, filename, pattern):
                """æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ¹é…æ¨¡å¼"""
                return re.match(pattern, filename) is not None
            
            def find_matching_group(self, filename):
                """æŸ¥æ‰¾åŒ¹é…çš„å†…æ ¸ç»„"""
                for group, patterns in KERNEL_GROUPS.items():
                    if any(self.pattern_match(filename, p) for p in patterns):
                        return group
                return None
            
            def extract_version(self, filename):
                """ä»æ–‡ä»¶åæå–ç‰ˆæœ¬å·"""
                match = re.search(r'(\d+\.\d+\.\d+-flippy-\d+\+[a-z]*)', filename) or \
                       re.search(r'(\d+\.\d+\.\d+-flippy-\d+\+)', filename)
                return match.group(1) if match else None
            
            async def download_file(self, client, message, path):
                """ä¸‹è½½æ–‡ä»¶åˆ°æŒ‡å®šè·¯å¾„"""
                await client.download_media(message, file=path)
                return True
            
            def get_latest_date(self, messages):
                """è·å–æ¶ˆæ¯åˆ—è¡¨ä¸­çš„æœ€æ–°æ—¥æœŸ"""
                return max(msg.date for msg in messages) if messages else None
            
            async def process_group(self, client, group, version, files, group_dir):
                """å¤„ç†å®Œæ•´çš„å†…æ ¸ç»„"""
                os.makedirs(group_dir, exist_ok=True)
                messages = [msg for _, msg in files]
                
                # ä¸‹è½½æ‰€æœ‰æ–‡ä»¶
                for filename, msg in files:
                    await self.download_file(client, msg, os.path.join(group_dir, filename))
                
                # åˆ›å»ºZIPæ–‡ä»¶
                zip_filename = f"{group}_{version}.zip"
                zip_path = os.path.join(self.work_dir, zip_filename)
                with zipfile.ZipFile(zip_path, 'w') as zipf:
                    for filename in os.listdir(group_dir):
                        file_path = os.path.join(group_dir, filename)
                        zipf.write(file_path, arcname=filename)
                
                # è·å–æœ€æ–°æ—¥æœŸï¼ˆUTC+8ï¼‰
                latest_date = self.get_latest_date(messages)
                date_str = latest_date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                
                return zip_path, date_str
            
            def needs_update(self, group, new_version, new_date):
                """æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°"""
                current = self.versions.get(group, {"version": "", "date": ""})
                return (new_version != current["version"]) or \
                       (new_version == current["version"] and new_date > current["date"])
            
            def cleanup_group(self, group, keep_version):
                """æ¸…ç†æ—§ç‰ˆæœ¬çš„å†…æ ¸æ–‡ä»¶"""
                if not os.path.exists(self.kernel_dir):
                    return 0
                
                deleted = 0
                for filename in os.listdir(self.kernel_dir):
                    if filename.startswith(f"{group}_") and filename != f"{group}_{keep_version}.zip":
                        os.remove(os.path.join(self.kernel_dir, filename))
                        deleted += 1
                return deleted
            
            async def find_new_kernels(self, client):
                """åœ¨Telegramé¢‘é“æŸ¥æ‰¾æ–°å†…æ ¸"""
                channel = os.environ.get('TELEGRAM_CHANNEL', 'openwrt_flippy')
                entity = await client.get_entity(channel)
                
                # å­˜å‚¨æ‰¾åˆ°çš„æ–‡ä»¶ {group: {version: {filename: message}}}
                found = {group: {} for group in KERNEL_GROUPS}
                
                # æ‰«ææœ€æ–°çš„50æ¡æ¶ˆæ¯
                async for msg in client.iter_messages(entity, limit=50):
                    if not (msg.media and hasattr(msg.media, "document")):
                        continue
                    
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            group = self.find_matching_group(filename)
                            if not group:
                                continue
                            
                            version = self.extract_version(filename)
                            if not version:
                                continue
                            
                            # æ·»åŠ åˆ°foundç»“æ„
                            if version not in found[group]:
                                found[group][version] = {}
                            found[group][version][filename] = msg
                
                updates = {}
                for group, versions in found.items():
                    if not versions:
                        continue
                    
                    # æŒ‰ç‰ˆæœ¬å·é™åºæ’åº
                    for version in sorted(versions.keys(), reverse=True):
                        files = versions[version]
                        patterns = KERNEL_GROUPS[group]
                        
                        # æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰å¿…éœ€æ–‡ä»¶
                        if sum(1 for p in patterns if any(self.pattern_match(f, p) for f in files)) < REQUIRED_FILE_COUNT:
                            continue
                        
                        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                        latest_date = self.get_latest_date(list(files.values()))
                        if not latest_date:
                            continue
                        
                        date_str = latest_date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                        if not self.needs_update(group, version, date_str):
                            log.info(f"{group}@{version} å·²æ˜¯æœ€æ–°ç‰ˆæœ¬")
                            break
                        
                        # å¤„ç†æ›´æ–°
                        group_dir = os.path.join(self.work_dir, f"{group}_{version}")
                        try:
                            zip_path, zip_date = await self.process_group(client, group, version, 
                                                                        list(files.items()), group_dir)
                            updates[group] = {
                                "version": version,
                                "date": zip_date,
                                "zip_path": zip_path
                            }
                            log.info(f"å‡†å¤‡æ›´æ–° {group}@{version} ({zip_date})")
                        except Exception as e:
                            log.error(f"å¤„ç†{group}å¤±è´¥: {str(e)}")
                        break
                return updates
            
            async def sync_kernels(self):
                """æ‰§è¡ŒåŒæ­¥ä¸»æµç¨‹"""
                # éªŒè¯ç¯å¢ƒå˜é‡
                required_vars = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
                missing = [v for v in required_vars if not os.environ.get(v)]
                if missing:
                    log.error(f"ç¼ºå°‘ç¯å¢ƒå˜é‡: {', '.join(missing)}")
                    return 1
                
                if not self.setup_git():
                    return 2
                
                # åˆ›å»ºä¸´æ—¶ç›®å½•
                os.makedirs(self.work_dir, exist_ok=True)
                os.makedirs(self.kernel_dir, exist_ok=True)
                
                # åˆå§‹åŒ–Telegramå®¢æˆ·ç«¯
                client = TelegramClient(
                    StringSession(os.environ['TELEGRAM_SESSION']),
                    int(os.environ['TELEGRAM_API_ID']),
                    os.environ['TELEGRAM_API_HASH']
                )
                
                try:
                    async with client:
                        updates = await self.find_new_kernels(client)
                except Exception as e:
                    log.error(f"Telegramé”™è¯¯: {str(e)}")
                    return 3
                
                if not updates:
                    log.info("æ²¡æœ‰éœ€è¦æ›´æ–°çš„å†…æ ¸")
                    shutil.rmtree(self.work_dir)
                    return 0
                
                # åº”ç”¨æ›´æ–°
                updated_groups = []
                total_deleted = 0
                
                for group, data in updates.items():
                    try:
                        # å¤åˆ¶ZIPæ–‡ä»¶åˆ°ä»“åº“
                        dest_path = os.path.join(self.kernel_dir, os.path.basename(data["zip_path"]))
                        shutil.copy2(data["zip_path"], dest_path)
                        
                        # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                        self.versions[group] = {
                            "version": data["version"],
                            "date": data["date"]
                        }
                        
                        # æ¸…ç†æ—§ç‰ˆæœ¬
                        deleted = self.cleanup_group(group, data["version"])
                        total_deleted += deleted
                        
                        updated_groups.append(f"{group}@{data['version']}")
                        log.info(f"å·²æ›´æ–° {group}ï¼Œåˆ é™¤ {deleted} ä¸ªæ—§æ–‡ä»¶")
                    except Exception as e:
                        log.error(f"æ›´æ–°{group}å¤±è´¥: {str(e)}")
                
                if not updated_groups:
                    log.info("æ²¡æœ‰æˆåŠŸæ›´æ–°çš„ç»„")
                    return 4
                
                # ä¿å­˜ç‰ˆæœ¬ä¿¡æ¯
                self.save_versions()
                
                # æäº¤æ›´æ”¹
                commit_msg = f"æ›´æ–°å†…æ ¸: {', '.join(updated_groups)}"
                if total_deleted:
                    commit_msg += f"\nåˆ é™¤ {total_deleted} ä¸ªæ—§ç‰ˆæœ¬"
                
                if self.commit_and_push(commit_msg):
                    log.info(f"æˆåŠŸæ›´æ–° {len(updated_groups)} ä¸ªç»„")
                else:
                    log.error("æäº¤æ›´æ”¹å¤±è´¥")
                    return 5
                
                # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                shutil.rmtree(self.work_dir)
                return 0
        
        if __name__ == "__main__":
            syncer = KernelSyncer()
            exit_code = syncer.sync_kernels()
            sys.exit(exit_code)
        EOF

    - name: Release Repository Lock ğŸ”“
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            const issue_number = context.issue.number;
            if (issue_number) {
              await github.rest.issues.createComment({
                issue_number: issue_number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `å·¥ä½œæµå¤±è´¥é€šçŸ¥ - ${{ github.workflow }} #${{ github.run_number }}`,
                body: `ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼å·¥ä½œæµè¿è¡Œ: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            }
          } catch (error) {
            core.error(`ğŸš¨ OpenWrtå†…æ ¸åŒæ­¥å¤±è´¥ï¼è¯¦æƒ…è¯·æŸ¥çœ‹è¿è¡Œ: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`);
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 3
          retain_days: 7
          delete_workflow_pattern: "OpenWrt Kernel Sync from TELEGRAM"
          repository: ${{ github.repository }}