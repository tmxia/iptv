name: OpenWrt Kernel Sync from TELEGRAM

concurrency: 
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  schedule:
    - cron: '0 18 * * 1' # 周一凌晨2点（北京时间）
    - cron: '0 11 * * 1' # 周一下午7点（北京时间）
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
    - name: Acquire Repository Lock 🔒
      uses: softprops/turnstyle@v1
      with:
        same-branch-only: true
        poll-interval-seconds: 30
        abort-after-seconds: 1200
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update > /dev/null
        sudo apt-get install -y jq curl unzip zip > /dev/null
        pip install telethon requests pytz > /dev/null

    - name: Run Kernel Sync
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION: ${{ secrets.TELEGRAM_SESSION }}
        TELEGRAM_CHANNEL: "openwrt_flippy"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_REPO: ${{ github.repository }}
      run: |
        python - << "EOF"
        import os
        import json
        import sys
        import subprocess
        import shutil
        import re
        import logging
        import zipfile
        from datetime import datetime
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from telethon.tl.types import DocumentAttributeFilename
        import pytz
        
        # 配置参数
        KERNEL_GROUPS = {
            "openwrt_flippy6.1": [
                r"dtb-rockchip-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-amlogic-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.1\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.1\..*-flippy-\d+\+.*\.tar\.gz"
            ],
            "openwrt_flippy6.6": [
                r"dtb-rockchip-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-amlogic-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.6\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.6\..*-flippy-\d+\+.*\.tar\.gz"
            ],
            "openwrt_flippy6.12": [
                r"dtb-amlogic-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-rockchip-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"boot-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"dtb-allwinner-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"header-6\.12\..*-flippy-\d+\+.*\.tar\.gz",
                r"modules-6\.12\..*-flippy-\d+\+.*\.tar\.gz"
            ]
        }
        REQUIRED_FILE_COUNT = 6
        
        KERNEL_DIR = "kernels"
        KERNEL_VERSION_FILE = "kernel_versions.json"
        WORK_DIR = "temp_kernels"
        
        # 日志配置
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        log = logging.getLogger()
        
        class KernelSyncer:
            def __init__(self):
                self.git_dir = os.getcwd()
                self.work_dir = os.path.join(self.git_dir, WORK_DIR)
                self.kernel_dir = os.path.join(self.git_dir, KERNEL_DIR)
                self.version_file = os.path.join(self.git_dir, KERNEL_VERSION_FILE)
                self.versions = self.load_versions()
                
            def load_versions(self):
                """加载版本文件，确保包含所有组"""
                if os.path.exists(self.version_file):
                    try:
                        with open(self.version_file, "r") as f:
                            versions = json.load(f)
                    except:
                        versions = {}
                else:
                    versions = {}
                
                # 确保所有组都存在
                for group in KERNEL_GROUPS:
                    if group not in versions:
                        versions[group] = {"version": "", "date": ""}
                return versions
            
            def save_versions(self):
                """保存版本文件，保留其他组信息"""
                with open(self.version_file, "w") as f:
                    json.dump(self.versions, f, indent=2)
            
            def setup_git(self):
                """配置Git用户信息并拉取最新代码"""
                try:
                    actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                    email = f'{actor}@users.noreply.github.com'
                    
                    subprocess.run(["git", "config", "user.name", actor], 
                                   cwd=self.git_dir, check=True, 
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    subprocess.run(["git", "config", "user.email", email], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    
                    # 拉取最新更改
                    subprocess.run(["git", "pull", "origin", "main", "--rebase"], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    return True
                except Exception as e:
                    log.error(f"Git设置失败: {str(e)}")
                    return False
            
            def commit_and_push(self, message):
                """提交更改并推送到仓库"""
                try:
                    # 添加更改
                    subprocess.run(["git", "add", KERNEL_DIR, KERNEL_VERSION_FILE], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    
                    # 检查是否有更改
                    status = subprocess.run(["git", "status", "--porcelain"], 
                                            cwd=self.git_dir, capture_output=True, text=True)
                    if not status.stdout.strip():
                        log.info("无更改需要提交")
                        return True
                    
                    # 提交更改
                    subprocess.run(["git", "commit", "-m", message], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    
                    # 推送更改
                    token = os.environ['GITHUB_TOKEN']
                    actor = os.environ.get('GITHUB_ACTOR', 'github-actions')
                    repo = os.environ['TARGET_REPO']
                    repo_url = f"https://{actor}:{token}@github.com/{repo}.git"
                    
                    subprocess.run(["git", "pull", "--rebase", "origin", "main"], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    subprocess.run(["git", "push", repo_url, "HEAD:main"], 
                                   cwd=self.git_dir, check=True,
                                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    return True
                except Exception as e:
                    log.error(f"Git操作失败: {str(e)}")
                    return False
            
            def pattern_match(self, filename, pattern):
                """检查文件名是否匹配模式"""
                return re.match(pattern, filename) is not None
            
            def find_matching_group(self, filename):
                """查找匹配的内核组"""
                for group, patterns in KERNEL_GROUPS.items():
                    if any(self.pattern_match(filename, p) for p in patterns):
                        return group
                return None
            
            def extract_version(self, filename):
                """从文件名提取版本号"""
                match = re.search(r'(\d+\.\d+\.\d+-flippy-\d+\+[a-z]*)', filename) or \
                       re.search(r'(\d+\.\d+\.\d+-flippy-\d+\+)', filename)
                return match.group(1) if match else None
            
            async def download_file(self, client, message, path):
                """下载文件到指定路径"""
                await client.download_media(message, file=path)
                return True
            
            def get_latest_date(self, messages):
                """获取消息列表中的最新日期"""
                return max(msg.date for msg in messages) if messages else None
            
            async def process_group(self, client, group, version, files, group_dir):
                """处理完整的内核组"""
                os.makedirs(group_dir, exist_ok=True)
                messages = [msg for _, msg in files]
                
                # 下载所有文件
                for filename, msg in files:
                    await self.download_file(client, msg, os.path.join(group_dir, filename))
                
                # 创建ZIP文件
                zip_filename = f"{group}_{version}.zip"
                zip_path = os.path.join(self.work_dir, zip_filename)
                with zipfile.ZipFile(zip_path, 'w') as zipf:
                    for filename in os.listdir(group_dir):
                        file_path = os.path.join(group_dir, filename)
                        zipf.write(file_path, arcname=filename)
                
                # 获取最新日期（UTC+8）
                latest_date = self.get_latest_date(messages)
                date_str = latest_date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                
                return zip_path, date_str
            
            def needs_update(self, group, new_version, new_date):
                """检查是否需要更新"""
                current = self.versions.get(group, {"version": "", "date": ""})
                return (new_version != current["version"]) or \
                       (new_version == current["version"] and new_date > current["date"])
            
            def cleanup_group(self, group, keep_version):
                """清理旧版本的内核文件"""
                if not os.path.exists(self.kernel_dir):
                    return 0
                
                deleted = 0
                for filename in os.listdir(self.kernel_dir):
                    if filename.startswith(f"{group}_") and filename != f"{group}_{keep_version}.zip":
                        os.remove(os.path.join(self.kernel_dir, filename))
                        deleted += 1
                return deleted
            
            async def find_new_kernels(self, client):
                """在Telegram频道查找新内核"""
                channel = os.environ.get('TELEGRAM_CHANNEL', 'openwrt_flippy')
                entity = await client.get_entity(channel)
                
                # 存储找到的文件 {group: {version: {filename: message}}}
                found = {group: {} for group in KERNEL_GROUPS}
                
                # 扫描最新的50条消息
                async for msg in client.iter_messages(entity, limit=50):
                    if not (msg.media and hasattr(msg.media, "document")):
                        continue
                    
                    for attr in msg.media.document.attributes:
                        if isinstance(attr, DocumentAttributeFilename):
                            filename = attr.file_name
                            group = self.find_matching_group(filename)
                            if not group:
                                continue
                            
                            version = self.extract_version(filename)
                            if not version:
                                continue
                            
                            # 添加到found结构
                            if version not in found[group]:
                                found[group][version] = {}
                            found[group][version][filename] = msg
                
                updates = {}
                for group, versions in found.items():
                    if not versions:
                        continue
                    
                    # 按版本号降序排序
                    for version in sorted(versions.keys(), reverse=True):
                        files = versions[version]
                        patterns = KERNEL_GROUPS[group]
                        
                        # 检查是否包含所有必需文件
                        if sum(1 for p in patterns if any(self.pattern_match(f, p) for f in files)) < REQUIRED_FILE_COUNT:
                            continue
                        
                        # 检查是否需要更新
                        latest_date = self.get_latest_date(list(files.values()))
                        if not latest_date:
                            continue
                        
                        date_str = latest_date.astimezone(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
                        if not self.needs_update(group, version, date_str):
                            log.info(f"{group}@{version} 已是最新版本")
                            break
                        
                        # 处理更新
                        group_dir = os.path.join(self.work_dir, f"{group}_{version}")
                        try:
                            zip_path, zip_date = await self.process_group(client, group, version, 
                                                                        list(files.items()), group_dir)
                            updates[group] = {
                                "version": version,
                                "date": zip_date,
                                "zip_path": zip_path
                            }
                            log.info(f"准备更新 {group}@{version} ({zip_date})")
                        except Exception as e:
                            log.error(f"处理{group}失败: {str(e)}")
                        break
                return updates
            
            async def sync_kernels(self):
                """执行同步主流程"""
                # 验证环境变量
                required_vars = ['TELEGRAM_API_ID', 'TELEGRAM_API_HASH', 'TELEGRAM_SESSION', 'GITHUB_TOKEN']
                missing = [v for v in required_vars if not os.environ.get(v)]
                if missing:
                    log.error(f"缺少环境变量: {', '.join(missing)}")
                    return 1
                
                if not self.setup_git():
                    return 2
                
                # 创建临时目录
                os.makedirs(self.work_dir, exist_ok=True)
                os.makedirs(self.kernel_dir, exist_ok=True)
                
                # 初始化Telegram客户端
                client = TelegramClient(
                    StringSession(os.environ['TELEGRAM_SESSION']),
                    int(os.environ['TELEGRAM_API_ID']),
                    os.environ['TELEGRAM_API_HASH']
                )
                
                try:
                    async with client:
                        updates = await self.find_new_kernels(client)
                except Exception as e:
                    log.error(f"Telegram错误: {str(e)}")
                    return 3
                
                if not updates:
                    log.info("没有需要更新的内核")
                    shutil.rmtree(self.work_dir)
                    return 0
                
                # 应用更新
                updated_groups = []
                total_deleted = 0
                
                for group, data in updates.items():
                    try:
                        # 复制ZIP文件到仓库
                        dest_path = os.path.join(self.kernel_dir, os.path.basename(data["zip_path"]))
                        shutil.copy2(data["zip_path"], dest_path)
                        
                        # 更新版本信息
                        self.versions[group] = {
                            "version": data["version"],
                            "date": data["date"]
                        }
                        
                        # 清理旧版本
                        deleted = self.cleanup_group(group, data["version"])
                        total_deleted += deleted
                        
                        updated_groups.append(f"{group}@{data['version']}")
                        log.info(f"已更新 {group}，删除 {deleted} 个旧文件")
                    except Exception as e:
                        log.error(f"更新{group}失败: {str(e)}")
                
                if not updated_groups:
                    log.info("没有成功更新的组")
                    return 4
                
                # 保存版本信息
                self.save_versions()
                
                # 提交更改
                commit_msg = f"更新内核: {', '.join(updated_groups)}"
                if total_deleted:
                    commit_msg += f"\n删除 {total_deleted} 个旧版本"
                
                if self.commit_and_push(commit_msg):
                    log.info(f"成功更新 {len(updated_groups)} 个组")
                else:
                    log.error("提交更改失败")
                    return 5
                
                # 清理临时文件
                shutil.rmtree(self.work_dir)
                return 0
        
        if __name__ == "__main__":
            syncer = KernelSyncer()
            exit_code = syncer.sync_kernels()
            sys.exit(exit_code)
        EOF

    - name: Release Repository Lock 🔓
      if: always()
      uses: softprops/turnstyle@v1
      with:
        continue-on-error: true
        action: unlock
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify on failure
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          try {
            const issue_number = context.issue.number;
            if (issue_number) {
              await github.rest.issues.createComment({
                issue_number: issue_number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `🚨 OpenWrt内核同步失败！工作流运行: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `工作流失败通知 - ${{ github.workflow }} #${{ github.run_number }}`,
                body: `🚨 OpenWrt内核同步失败！工作流运行: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
            }
          } catch (error) {
            core.error(`🚨 OpenWrt内核同步失败！详情请查看运行: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`);
          }

  cleanup_self:
    name: Cleanup Self Workflow History
    runs-on: ubuntu-latest
    needs: sync
    if: ${{ always() }}
    permissions:
      actions: write
      contents: read
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          keep_minimum_runs: 3
          retain_days: 7
          delete_workflow_pattern: "OpenWrt Kernel Sync from TELEGRAM"
          repository: ${{ github.repository }}